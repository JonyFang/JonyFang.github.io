{"meta":{"title":"JonyFang","subtitle":"","description":"","author":"JonyFang","url":"https://blog.jonyfang.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-01-07T06:39:35.374Z","updated":"2021-01-07T06:39:35.374Z","comments":true,"path":"404.html","permalink":"https://blog.jonyfang.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2021-01-07T06:39:35.381Z","updated":"2021-01-07T06:39:35.381Z","comments":true,"path":"about/index.html","permalink":"https://blog.jonyfang.com/about/index.html","excerpt":"","text":"你好，我叫方春，网络 ID @JonyFang，现在是一名 iOS 工程师。 可以通过下面的方式联系到我： E-Mail: jony.chunfang@gmail.com GitHub: JonyFang Weibo: JonyFang Twitter: jony_chunfang Dribbble: JonyFang"},{"title":"所有分类","date":"2021-01-07T06:39:35.381Z","updated":"2021-01-07T06:39:35.381Z","comments":true,"path":"categories/index.html","permalink":"https://blog.jonyfang.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-01-07T06:39:35.381Z","updated":"2021-01-07T06:39:35.381Z","comments":true,"path":"friends/index.html","permalink":"https://blog.jonyfang.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"项目列表","date":"2021-01-07T06:39:35.381Z","updated":"2021-01-07T06:39:35.381Z","comments":true,"path":"projects/index.html","permalink":"https://blog.jonyfang.com/projects/index.html","excerpt":"开源项目越多人参与就越有生命力，希望有兴趣的小伙伴可以加入团队～ 现免费招募文档维护团队，工作内容： 补充疏漏内容 修复错误内容 审核 PR 并对内容正确、格式符合规范的进行合并 本站使用了持续集成，以上轻量级的工作仅仅使用浏览器就可以完成。 加入团队","text":"开源项目越多人参与就越有生命力，希望有兴趣的小伙伴可以加入团队～ 现免费招募文档维护团队，工作内容： 补充疏漏内容 修复错误内容 审核 PR 并对内容正确、格式符合规范的进行合并 本站使用了持续集成，以上轻量级的工作仅仅使用浏览器就可以完成。 加入团队 感谢项目贡献者提交 PR维护文档站点收录非常感谢直接提交了 PR 的朋友！ xaoxuu inkss MHuiG Drew233 CRainyDay ericclose zhaohaihao TRHX Linhk1606 PHIKN1GHT Flexiston ic3evi1 cofm MicDZ lunhui1994 WillyChen123 查看全部 同样感谢那些在评论和 Issue 中互相帮助的网友~ 如果您有一个好点子或者解决了我这里没有解决的问题，欢迎去 GitHub 贡献一下代码。👏如果您发现文档中有错误，或者遗漏内容，欢迎补充和纠正。👏 文档源码 感谢以下网站的收录与分享，让本主题能够被更多人发现，主题就会做的越来越好~ Hexo Themes Valine Easy Hexo 如何参与互动解决问题 渠道 方式 用途 Issue @volantis-x/hexo-theme-volantis 和开发者沟通的唯一渠道，用于跟进和解决问题 交流 渠道 方式 用途 论坛 @volantis-x/forum 慢，相对正式，方便检索，可以给其他用户参考 QQ群 1078948746 (验证码: vlts-2020) 非正式，即时通讯，易于斗图；不利于给其他用户参考 微信群 - - 佛系互动 渠道 方式 用途 评论区 留言 可以测试、灌水、推广自己的博客。"},{"title":"所有标签","date":"2021-01-07T06:39:35.381Z","updated":"2021-01-07T06:39:35.381Z","comments":true,"path":"tags/index.html","permalink":"https://blog.jonyfang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WWDC20 10146 - App Clips 的配置及链接处理","slug":"2020-06-28-configure-and-link-appClips","date":"2020-06-27T16:00:00.000Z","updated":"2021-01-12T09:59:21.362Z","comments":true,"path":"2020/06/28/2020-06-28-configure-and-link-appClips/","link":"","permalink":"https://blog.jonyfang.com/2020/06/28/2020-06-28-configure-and-link-appClips/","excerpt":"视频链接: WWDC 2020 - Configure and link your app clips。 本篇介绍了 App Clips 链接处理所需要知道的所有内容。 App Clips通过最简化的方式，为你的用户提供了一个体验应用程序的入口。当你的用户需要 App 的具体功能来处理某项操作时，App Clips 会通过 deep-linked 的方式无缝将 App 的具体模块呈现给用户。本篇会介绍 App Clip 内链接的处理和配置链接所需的操作。","text":"视频链接: WWDC 2020 - Configure and link your app clips。 本篇介绍了 App Clips 链接处理所需要知道的所有内容。 App Clips通过最简化的方式，为你的用户提供了一个体验应用程序的入口。当你的用户需要 App 的具体功能来处理某项操作时，App Clips 会通过 deep-linked 的方式无缝将 App 的具体模块呈现给用户。本篇会介绍 App Clip 内链接的处理和配置链接所需的操作。 1.前言本篇内容结构： 首先，让我们通过一个示例，来看下如何通过一个 App Clip 来完成一个具体的功能处理。 2.App Clip 应用示例 - 订购冰沙🍧[00:49]￼想象着你现在在经过一个冰沙摊。你想要来一份冷冰沙。这时，你发现了一个带有标语的 NFC 标签，上面写着“贴近此处订购”。你按照提示将手机贴近了 NFC 标签，之后在你的 iPhone 屏幕的底部会弹出一个卡片，上面写着购买沙冰的一些简短说明，而这个卡片即是我们要介绍的 App Clip。当你按照卡片的提示，点击了上面的“打开”按钮后，将在手机上启动 App Clip 的订购处理，这个处理会将你直接带到冰沙的订购页面。之后，你通过 Apple Pay 完成支付，成功买到了冰沙。￼上述购买冰沙的这一过程，即发生了购买的关联处理。 我们从程序的角度来看下这一过程是怎样的。NFC标签实际上是一个编码的 URL，对应注册了一个 App Clip 体验，关于如何注册将在后面部分进行详细展开。NFC 触发弹出 App Clip，当你点击 App Clip 上的“打开”按钮后，App Clip 将启动带有通过 NSUserActivity 传递的URL，之后 App Clip 将你直接带到订购页面。￼ 除了 NFC，活动链接也可以出现在其他地方。你的 URL，可以编码在物理标签中；也可以与地图上的实际位置相关联。下面，让我们逐一介绍这些链接的处理方法。 3. 链接方式[02:03]￼正如在前面的示例中提到的那样，NFC 标签可以编码入一个 App Clip URL，用户可以通过手机放到 NFC 上来打开 App Clip。￼App Clip URL 也可以编码入一个二维码中，人们可以通过扫描二维码来触发 App Clip。￼App Clip可以显示在已注册商家的地图位置卡上，也可以显示在 Siri 附近建议中。￼如果你的网页配置了 App Clip 对应的智能应用横幅，则你也可以从 Safari 打开 App Clip。用户可以通过点击该横幅中的打开按钮以打开 App Clip。￼当用户在 Messages app 中发送该站点的 URL 时，它会以特殊的 App Clip 链接气泡显示，该气泡让用​​户可以选择在 App Clip 或在 Safari 中打开链接。￼此外，为了给大家带来更好的体验，苹果将于今年晚些时候发布新的 App Clip 码，这是让你的用户发现你的 App Clip 的最佳方式。它在视觉上是美观而独特的，因此当用户看到它时，便知道有一个 App Clip 在等待他们去使用。每个 App Clip 码都对应编码了一个 URL。苹果将​​于今年晚些时候发布可以创建这些独特 App Clip 码的工具。 现在我们已经知道了可以让用户进入到你的 App Clip 的不同方法。接下来，让我们逐步了解 App Clip 开发人员在设置链接体验过程中所需要做的步骤。 4. 链接到你的 App Clip[03:38]首先，你必须对 Web 服务器和 App Clip 项目进行更改。以让这些链接可以由 App Clip 处理。接下来，你必须配置 App Clip 卡片，该卡片用于向用户介绍 App Clip 的信息，也是 App Clip 体验的一部分。你可以在 App Store Connect 上设置默认和高级 App Clip 体验。下面，让我们配置一个智能应用横幅，以在网页上显示你的 App Clip。如果你可以通过更好和更简化的 App Clip 体验来交付网页内容，可以考虑添加此标语，以此来为你的用户提供一种可以从该网页访问 App Clip 的方法。首先，让我们开始配置 Web服务器 和 App Clip 以进行链接处理。 4.1 配置Web服务器和 App Clip 以进行链接处理[04:28]￼你的网站和你的 App Clip 之间的关联必须经过验证，以便 App Clip 能够显示内容来代替网站的 URL。为了将你的 App Clip 与服务器安全地关联，你将需要 Web 服务器上的 apple-app-site-association 文件，以及 App Clip 上适当的关联域权限。之后，你必须更新 App Clip 中的代码以处理传入 NSUserActivity 的链接。首先，让我们更新 Web 服务器上的 apple-app-site-association 文件。 4.1.1 更新 apple-app-site-association 文件[05:06]￼该文件位于服务器的根文件夹中的 ./well-known 的子目录中。如果你之前已经为应用程序设置了通用链接（Universal Links），则可能已经在服务器上设置了该文件。根字典已经具有其他条目，例如 Web 凭据和应用程序链接。要在此文件中声明新的 App Clip 关联，请在根字典中添加另一个项，其键为 “appclips” ，并且该值包含一个字典，该字典包含单个 apps 键，该键设置为包含 App Clip 的应用标识符的数组。 4.1.2 添加关联的域权限[05:45]￼接下来，让我们更新 App Clip 项目以添加关联的域权利。在 Xcode 中，进入你的项目设置并添加 Associated Domains 功能。在 Domains 下，添加一个新的字符串 appclips:。现在，你的网站和 App Clip 均已设置了相关的域，让我们添加代码来处理 NSUserActivity，其中包含传递到你的 App Clip中的 URL。 4.1.3 处理 NSUserActivity[06:15]￼如果你的 App Clip 采用了新的 SwiftUI 应用程序生命周期，则可以通过上图中的方法为网络浏览用户活动添加处理程序。在该方法中，你可以从 NSUserActivity 获取 webpageURL 属性。然后，你可以解析该 URL 并将用户定向到链接的内容。请记住，当用户升级或下载了主 App 以后，App Clip 会直接打开主 App。因此，请确保你的应用程序也具有类似的代码来处理通用链接（Universal Links）的网址。￼如果你的 App Clip 使用 UIKit SceneDelegate 生命周期，则上图是一些类似的处理代码，用于处理 UIScene 委托中传入的用户活动。要了解有关如何设置关联域和处理 NSUserActivities 的信息，请参阅会话：What’s New in Universal Link。￼如果你需要在 Xcode 中调试 App Clip 中 URL 处理相关的代码，可以指定要传递到 App Clip 的测试 URL。在 Xcode 中打开 Scheme 编辑器。选择 Arguments 选项卡。在 Environment Variables 下，指定 _XCAppClipURL 变量。现在，当你从 Xcode 运行你的 App Clip 时，它将使用此 URL 启动。现在，我们已经完成了 Web 服务器和 App Clip 的配置，接下来，我们来配置 App Clip 体验。 4.2 在 App Store Connect 上配置 App Clip 体验[07:51]￼每次 App Clip 体验都是从用户触发看到的 App Clip 卡片（App Clip 链接）开始的。它展示了有关 App Clip 的信息，并征得用户的同意以打开它。 4.2.1 App Clip 设计规则[08:04]￼当你在提交用于配置 App Clip 卡的元数据时，请遵循标题和副标题长度上的这些要求，以实现卡片的最佳布局。为了满足所有设备上的最佳用户体验，还有图片大小，宽高比和格式上的要求。你所选择的图片需要遵循此 App Clip 操作所提供的准则。现在，让我们在 App Store Connect 上设置 App Clip 卡片。 4.2.2 在 App Store Connect 上设置 App Clip 卡片[08:34]￼在将包含你的应用程序和你的 App Clip 的构建交付给 App Store Connect 之后，App Clip 会在 App Store Connect 上进行显示，会看到一个新的“App Clip配置”模块。你可以在此处开始设置默认和高级的 App Clip 体验。默认的 App Clip 体验的元数据包括活动卡的宣传图，文案介绍和相关的交互操作。你可以从中选择预定义的操作列表。此元数据将在 Safari 中的智能应用横幅中、“消息”中的 App Clip 链接气泡中以及在显示的 App Clip 卡片中进行使用。￼如果你希望不仅可以从 Safari 和消息中访问 App Clip，你可以通过单击此处的“开始”按钮来进行高级 App Clip 体验的设置。每种高级 App Clip 体验均绑定到可以在物理标签（例如 NFC 标签或二维码）中编码的 URL，因此可以从这些物理调用方法中启动 App Clip。￼确认进行高级设置后，你将到达此页面，你可以在其中指定高级 App Clip 体验的 URL。对于同一个 App Clip，你可以设置多个高级 App Clip 体验，每种体验都有不同的 URL。后面会介绍一些有关多个 Clip 体验的示例。￼进入下一页后，你可以设置图片，标题，副标题，并为 App Clip 卡选择一个触发事件来获得这种体验。你也可以选择将此 App Clip 体验与实际位置相关联。现在，让我们看一下高级 App Clip 体验的一些用例以及为这些体验注册 URL 的最佳实践。 4.2.3 多种 App Clip 的体验[10:28]￼单个 Clip 可以处理不同类型的任务，因此可以为同一个 Clip 自定义不同的 App Clip 体验。例如，这家餐厅的 App Clip 为客户提供两种类型的体验。一种是美食订购体验，用户可以通过 Clip 前往查看菜单并下单；另一种是餐桌预订体验，客人可以通过 Clip 前往预定餐桌。在这种情况下，可以通过设置两个高级 App Clip 体验来满足需求。一个用于 melamela.example/order，其中图片和副标题可以分别是餐厅的菜单图片和菜单描述，方便菜单查看和下单；另一个用于 melamela.example/reservation，其中图片和副标题可以分别是对应餐桌的图片和文字描述，方便餐桌预定。 4.2.4 最佳实践4.2.4.1 指定 App Clip 的体验 URL[11:23] 关于 URL 映射到 App Clip 的方式要记住的一件事是，它是基于最特定的前缀与已注册的 App Clip 体验 URL 的匹配。这意味着你无需为企业注册每个可能的 App Clip URL。但是请记住，即使你注册的体验 URL 仅用作前缀，你的 App Clip 也必须能够处理使用确切的注册 URL 启动的情况。在通过“Siri附近的建议”和“地图”调用你的 App Clip 时，可能会发生这种情况。 4.2.4.2 示例-自行车租赁[12:00]￼￼这个示例，我们将介绍如何通过注册一个 App Clip 体验 URL 来与多个调用 URL 一起使用。自行车商店有在线自行车租赁系统。它有成百上千的自行车出租，由 ID 编号标识。预订这些自行车的 URL 将在查询字符串参数中指定该 ID。幸运的是，由于这些 URL 是基于前缀匹配进行匹配的，因此该自行车商店无需为每​​个 URL 预先注册 App Clip 体验。只需注册一个 App Clip 体验 URL：https://bikesrental.example/rent 。这足以为所有具有该前缀和不同查询字符串参数的所有自行车 URL 提供 App Clip 体验。 4.2.4.3 示例-咖啡店[12:50]￼这是另一个示例，用于说明选择 URL 进行注册以获取高级 App Clip 的策略。在这个示例中，咖啡馆是一个大型连锁店，拥有多个地点，每个地点基本上都为其客户提供相似的体验。由于所有位置的 URL 格式都统一，且均以 https://brighteggcafe.example/store/ 开头，因此我们只需为该 URL 前缀注册 App Clip 体验即可。当客户点击指向其任何商店的链接时，他们将获得相同的 App Clip 卡片。但是，假设咖啡店希望为其库比蒂诺（Cupertino）旗舰店提供更特别的 App Clip 体验。要解决此问题，你还可以使用不同的宣传图和描述文本为特定的 App Clip 体验注册 Cupertino 商店 URL。这里的主要要点是，你可以注册一个更短，更通用的 URL 前缀，以覆盖大多数情况，并仅在需要提供不同的 App Clip 体验时才注册一个更特定的 URL。 有关在 App Store Connect 上设置默认和高级 App Clip 体验的详细信息，请参阅会话： What’s New in App Store Connect 。有关 App Clip 卡片设计的最佳实践，请参阅会话：Design Great App Clips 。 4.3 配置智能应用横幅以打开 App Clip[14:17]￼现在到了最后一步，通过处理链接来触发你的 App Clip。可以通过设置智能应用横幅，以打开你的 App Clip。当发送出配置了此标语的网页 URL 时，接收人可以通过智能应用横幅从 Safari 或“消息”中的网页打开 App Clip。如果你之前已经为应用设置了智能应用横幅，应该已经熟悉了添加到网页 HTML 中的 apple-itunes-app 的元标记，是用来指定应用的唯一标识符。要为你的 App Clip 配置此横幅，请将 app-clip-bundle-id 内容属性设置为 App Clip 的捆绑包标识符。你还应该继续设置 app-id 属性，这样对于使用 iOS 14 之前系统的用户，将保持之前的网页形式。Safari 在显示以下内容之前，将验证网站和 App Clip 之间的域关联情况。￼默认情况下，当用户点击智能应用横幅的“打开”按钮时。他们将看到为此 App Clip 配置的默认 App Clip 卡片。但是，如果使用高级 App Clip 体验注册此URL，则可以自定义体验的元数据，以便用户可以在横幅中看到更具描述性的标题，并获得针对该 App Clip 执行的任务量身定制的 App Clip卡片。 为了演示我们上述内容所谈论到的 App Clip 的链接时涉及的内容，你可以通过下方的视频链接快进到 15分48秒 查看完整的演示视频。 视频链接：https://developer.apple.com/videos/play/wwdc2020/10146/ 5. 在 TestFlight 中为你的 App Clip 添加测试调用点[21:22]￼此外，还需要简要介绍下如何对 App Clip 进行 beta 测试。在你将包含应用程序和 App Clip 的构建交付给 App Store Connect之后，你可以在 TestFlight 中找到一个新的 App Clip 模块，该模块可以用于为你的 App Clip 添加测试调用点，以便 Beta 测试人员可以测试待开放的不同 App Clip 体验的 URL。￼单击 Add App Clip Invocation（添加App Clip调用），然后设置你希望 Beta 测试人员试用的 App Clip 体验的标题和 URL。有关在 App Store Connect 中测试和提交 App Clip 的更多信息，请参阅会话：What’s New in App Store Connect。 6. 总结[22:05]￼在本篇的内容里，我们已经向你展示了以下内容： 如何通过为新的 App Clip 服务类型设置关联的域并在 App Clip 中处理网络浏览 NSUserActivity 来处理到你的 App Clip 中的链接。 如何在 App Store Connect 上配置默认和高级 App Clip 体验，包括有关注册 App Clip 体验时使用哪些 URL 的最佳实践； 如何设置智能应用横幅，以在网页上打开 App Clip； 最后是如何在 TestFlight 中测试 App Clip 的新功能。 感谢您的阅读，也期待您带来精彩的 App Clip~ 相关内容： WWDC 2020 - Create app clips for other businesses WWDC 2020 - Design great app clips WWDC 2020 - Explore app clips WWDC 2020 - Streamline your app clip WWDC 2020 - What’s new in App Store Connect WWDC 2020 - What’s new in Universal Links WWDC 2019 - What’s New in Universal Links","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://blog.jonyfang.com/categories/WWDC/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://blog.jonyfang.com/tags/WWDC/"},{"name":"App Clips","slug":"App-Clips","permalink":"https://blog.jonyfang.com/tags/App-Clips/"}]},{"title":"iOS 内存相关梳理","slug":"2020-04-08-about-ram","date":"2020-04-07T16:00:00.000Z","updated":"2021-01-12T10:11:35.609Z","comments":true,"path":"2020/04/08/2020-04-08-about-ram/","link":"","permalink":"https://blog.jonyfang.com/2020/04/08/2020-04-08-about-ram/","excerpt":"iOS 的内核是 XNU，XNU 是 Darwin 的一部分，而 Darwin 又是基于 FreeBSD 和 NetBSD 开发，集成了 Mach 微内核，BSD 是基于 UNIX。虽然 Linux 也是基于 UNIX，但 Darwin 和 Linux 没有直接继承的关系。内核 Darwin 是 C 写的，中层框架和库时 C 和 Objective-C 写的。 本文先从一般桌面操作系统的内存机制入手；接着从 iOS 系统层进行分析 iOS 的内存机制及 iOS 系统运行时的内存占用情况；最后到 iOS 中单个 App 的内存管理。","text":"iOS 的内核是 XNU，XNU 是 Darwin 的一部分，而 Darwin 又是基于 FreeBSD 和 NetBSD 开发，集成了 Mach 微内核，BSD 是基于 UNIX。虽然 Linux 也是基于 UNIX，但 Darwin 和 Linux 没有直接继承的关系。内核 Darwin 是 C 写的，中层框架和库时 C 和 Objective-C 写的。 本文先从一般桌面操作系统的内存机制入手；接着从 iOS 系统层进行分析 iOS 的内存机制及 iOS 系统运行时的内存占用情况；最后到 iOS 中单个 App 的内存管理。 一般操作系统的内存机制在分析 iOS 内存机制前，先看下一般操作系统（这里的一般操作系统指桌面操作系统）的内存机制是怎样的。 冯·诺伊曼结构冯·诺伊曼结构（Von Neumann architecture），也称冯·诺伊曼模型（Von Neumann model）或普林斯顿结构（Princeton architecture），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。即将计算机指令进行编码后存储在计算机的存储器中，需要的时候可以顺序地执行程序代码，从而控制计算机运行，这就是冯.诺依曼计算机体系的开端。 冯·诺依曼结构的优势。第一次将存储器和运算器分开，指令和数据都放在存储器中，为计算机的通用性奠定了基础。虽然在规范中计算单元依然是核心，但冯·诺依曼结构事实上导致了以存储器为核心的现代计算机的诞生。 冯·诺依曼结构的瓶颈。冯·诺依曼结构实现了计算机大提速，却也埋下了一个隐患：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈。简而言之，由于 CPU 的读写速率比存储器高，在每次去内存里取字节时，CPU 都需要等待存储器。这就造成了 CPU 性能的浪费。目前的解决办法是通过多核+多级缓存来缓解这一瓶颈问题。 存储器的多级缓存冯·诺依曼结构瓶颈的解决方式之一是设置多级缓存。先来看下存储器的层级结构。 如上存储器的层次结构图，能看到用到的存储器有 SRAM、DRAM、磁盘等。这样，操作系统中的存储器就构成了一个金字塔，越往上的存储器速度越快，价格越贵，容量也越小。当 CPU 接收到指令后，它会最先向 CPU 中的一级缓存（L1 Cache）去寻找相关的数据，然一级缓存是与 CPU 同频运行的，但是由于容量较小，所以不可能每次都命中。这时 CPU 会继续向下一级的二级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向 L3 Cache、内存(主存)和硬盘。 存储器分为两大类： 易失性存储： 读写速度快，但断电后数据会丢失，容量小价格高。随机访问存储器（RAM）就属于这一类，RAM 又分为 SRAM（静态）和 DRAM（动态）。如上图的 L1~L3 属于 SRAM，L4 属于 DRAM，通常 SRAM 主要集中在 CPU 芯片内部，价格昂贵，其中 L0 寄存器本身就是 CPU 的组成部分之一，读写速度快。 非易失性存储： 读写速度较慢，但断电后数据不会丢失，容量大价格相对低。计算机使用的硬盘就是 ROM 的一种，手机用的 Flash 也属于 Rom。这里的只读存储器 ROM，随着计算机发展已经支持了读写，只是沿用了之前的名称。 采用多级缓存提升效率，是用到了局部性原理（Principle of locality），即被使用过的存储器内容在未来可能被再次使用，它附近的数据项也大概率会被使用。当我们访问某个数据项是，将它周围数据项也放到对应缓存中，这样一定程度上节约了访问存储器的时间，提高了效率。 虚拟内存在知道存储器分为多级缓存后，这里自然引出了一个概念：物理内存。这里的物理内存指物理存储器为运行时的操作系统及进程提供的存储空间，是真实的物理空间及地址。但如果将这些物理地址直接暴露出去，会存在很多的危险性。为了解决这个问题，随之出现了要介绍的虚拟内存。 对于每个进程来说，操作系统通过虚拟内存，为每个进程提供了一个连续并私有的地址空间，从而保护每个进程的地址空间不被其他进程干扰。如上图，有了虚拟内存后，进程访问的是分配给它的虚拟内存，而虚拟内存实际可能映射到物理内存及磁盘的任何区域。 CPU 寻址方式在存储器里以字节为单位存储信息，为正确地存取信息，每个字节单元给以一个唯一的存储器地址，称为物理地址（Physical Address）。 物理地址之后拓展支持了分段和分页。内存的分段和分页管理方式都属于内存的不连续分配。什么是不连续分配？就是把程序分割成一块一块的装入内存，在物理上不用彼此相连，在逻辑上使用段表或页表将离散分布的这些小块串起来形成逻辑上连续的程序。 在基本的分页概念中，把程序分成等长的小块。这些小块叫做页（Page），同样内存也被分成了和页面同样大小的页框（Frame），一个页可以装到一个页框里。在执行程序的时候，我们根据一个页表去查找某个页面在内存的某个页框中，由此完成了逻辑到物理的映射。 分段和分页有很多类似的地方，但是最大的区别在于分页对于用户来说是没什么逻辑意义的，分页是为了完成离散存储，所有的页面大小都一样，对程序员来说这就像碎纸机一样，出来的东西没有完整意义。但是分段不一样，分段不定长，分页由系统完成，分段有时在编译过程中会指定划分，因此可以保留部分逻辑特征，容易实现分段共享。iOS 下的每个进程空间先分段，每个段内再分页，所以物理地址是由段号 + 段内页号 + 页内地址组成。 上述内容，参考自《计算机操作系统》，更多可自行查看。 在早期计算机系统中，程序员都是直接访问物理地址进行编程，当程序出现错误时，整个系统都会瘫痪，或者在多进程系统中，当一个进程出现问题，对属于另外一个进程的数据或者指令区域进行写操作，会导致另外一个进程崩溃。于是虚拟地址就被提出，软件使用虚拟地址访问内存，而处理器负责虚拟地址到物理地址的映射工作，地址转换是靠 CPU 中的内存管理单元（Memory Management Unit，即 MMU）来完成。处理器采用多级页表来进行多次查找最终找到真正的物理地址。当处理器发现页表中找不到真正对应的物理地址时，就会发出一个异常，挂起寻址错误的进程，但是其他进程仍然可以正常工作。从虚拟地址到物理地址的转换过程可知：由于页表是存放在内存中的，使用一级页表进行地址转换时，每次读/写数据需要访问两次内存，第一次访问一级页表获得物理地址，第二次才是真正的读/写数据；使用两级页表时，每次读/写数据需要访问三次内存，访问两次页表（一级页表和二级页表）获得物理地址，第三次才是真正的读/写数据。 拿处理器访问两级页表举例说明，当处理器拿到一个需要访问内存的虚拟地址 A，首先查找 MMU 里面页表地址寄存器得到页表在内存中的物理地址，然后 MMU 通过访问内存控制器去访问内存中的两级页表得到 A1、A2 两个地址，A1 和 A2 按照一定规则组合得虚拟地址 A 的物理地址 B，然后处理器在通过访问物理地址 B 得到内存数据。 这一地址转换过程大大降低了CPU的性能，有什么改进办法？ 程序执行过程中，所用到的指令、数据的地址往往集中在一个很小的范围内，其中的地址、数据经常多次使用，这称为程序访问的局部性。由此，通过使用一个高速、容量相对较小的存储器来存储近期用到的页表条目（段/大页/小页/极小页描述符），以避免每次地址转换时都到内存去查找，这样可以大幅度地提高性能。这个存储器用来帮助快速地进行地址转换，称为“转译查找缓存”（TLB Cache）。 当 CPU 发出一个虚拟地址时，MMU 首先访问 TLB Cache，如果 TLB Cache 中含有能转换这个虚拟地址的描述符，则直接利用此描述符进行地址转换和权限检查；否则 MMU 访问页表（页表是在主存中）找到描述符后再进行地址转换和权限检查，并将这个描述符填入 TLB Cache 中（如果 TLB Cache 已满，则利用 round-robin 算法找到一个条目，然后覆盖它），下次再使用这个虚拟地址时就可以直接使用 TLB Cache 中的地址描述符了。 TLB 是一个内存管理单元用于改进虚拟地址到物理地址转换速度的缓存，位于 MMU 中。 Swap 内存交换机制（Swap In/Out）物理内存是计算机的实际内存大小，由 RAM 芯片组成。虚拟内存则是虚拟出来的、使用磁盘代替内存。虚拟内存的出现，让机器内存不够的情况得到部分解决。当程序运行起来由操作系统做具体虚拟内存到物理内存的替换和加载（相应的页与段的虚拟内存管理）。这里的虚拟内存交换过程即所谓的 Swap。 当用户提交程序，然后产生进程在机器上运行。机器会判断当前物理内存是否还有空闲允许进程调入内存运行，如果有则直接调入内存进行；如果没有，则会根据优先级选择一个进程挂起，把该进程交换到 Swap Space 中等待，然后把新的进程调入到内存中运行。根据这种换入和换出，实现了内存的循环利用，让用户感觉不到内存的限制。从这也可以看出 Swap 扮演了一个非常重要的角色，就是暂存被换出的进程。 iOS 的内存机制官方给出的关于内存的相关文档介绍：Memory Usage Performance Guidelines，看到最后的更新时间为 2013 年 04 月，可以在需要时拿来作为参考。文档主要介绍的几点内容： 关于虚拟内存系统 内存分配的技巧 缓存和内存清理 跟踪内存的使用情况 查找内存泄露 启用 malloc 调试功能 查看虚拟内存的使用情况 iOS 对比桌面操作系统基于前面对一般桌面操作系统的了解和官方提供的文档，来对比看下在 iOS 中的内存。 首先 iOS 也和其他操作系统一样使用了虚拟内存机制，但区别于桌面操作系统的是：iOS 不支持内存交换机制（Swap）。 iOS 不支持 Swap 机制主要的两个原因： 一方面，因为 iPhone 使用的是闪存 Flash，频繁的读写会影响闪存的寿命 另一方面，相比于桌面操作系统的电脑，手机的闪存空间很有限 iOS 在内存优化上也下了很多心思，用到了内存压缩机制（Compressed memory），后面会具体介绍。Stackoverflow 上面查找看到一份关于 iOS 中单应用可用最大内存的测试报告（iOS app maximum memory budget）。 device: (crash amount&#x2F;total amount&#x2F;percentage of total)iPad1: 127MB&#x2F;256MB&#x2F;49%iPad2: 275MB&#x2F;512MB&#x2F;53%iPad3: 645MB&#x2F;1024MB&#x2F;62%iPad4: 585MB&#x2F;1024MB&#x2F;57% (iOS 8.1)iPad Mini 1st Generation: 297MB&#x2F;512MB&#x2F;58%iPad Mini retina: 696MB&#x2F;1024MB&#x2F;68% (iOS 7.1)iPad Air: 697MB&#x2F;1024MB&#x2F;68%iPad Air 2: 1383MB&#x2F;2048MB&#x2F;68% (iOS 10.2.1)iPad Pro 9.7&quot;: 1395MB&#x2F;1971MB&#x2F;71% (iOS 10.0.2 (14A456))iPad Pro 10.5”: 3057&#x2F;4000&#x2F;76% (iOS 11 beta4)iPad Pro 12.9” (2015): 3058&#x2F;3999&#x2F;76% (iOS 11.2.1)iPad Pro 12.9” (2017): 3057&#x2F;3974&#x2F;77% (iOS 11 beta4)iPad Pro 11.0” (2018): 2858&#x2F;3769&#x2F;76% (iOS 12.1)iPad Pro 12.9” (2018, 1TB): 4598&#x2F;5650&#x2F;81% (iOS 12.1)iPad 10.2: 1844&#x2F;2998&#x2F;62% (iOS 13.2.3)iPod touch 4th gen: 130MB&#x2F;256MB&#x2F;51% (iOS 6.1.1)iPod touch 5th gen: 286MB&#x2F;512MB&#x2F;56% (iOS 7.0)iPhone4: 325MB&#x2F;512MB&#x2F;63%iPhone4s: 286MB&#x2F;512MB&#x2F;56%iPhone5: 645MB&#x2F;1024MB&#x2F;62%iPhone5s: 646MB&#x2F;1024MB&#x2F;63%iPhone6: 645MB&#x2F;1024MB&#x2F;62% (iOS 8.x)iPhone6+: 645MB&#x2F;1024MB&#x2F;62% (iOS 8.x)iPhone6s: 1396MB&#x2F;2048MB&#x2F;68% (iOS 9.2)iPhone6s+: 1392MB&#x2F;2048MB&#x2F;68% (iOS 10.2.1)iPhoneSE: 1395MB&#x2F;2048MB&#x2F;69% (iOS 9.3)iPhone7: 1395&#x2F;2048MB&#x2F;68% (iOS 10.2)iPhone7+: 2040MB&#x2F;3072MB&#x2F;66% (iOS 10.2.1)iPhone8: 1364&#x2F;1990MB&#x2F;70% (iOS 12.1)iPhone X: 1392&#x2F;2785&#x2F;50% (iOS 11.2.1)iPhone XS: 2040&#x2F;3754&#x2F;54% (iOS 12.1)iPhone XS Max: 2039&#x2F;3735&#x2F;55% (iOS 12.1)iPhone XR: 1792&#x2F;2813&#x2F;63% (iOS 12.1)iPhone 11: 2068&#x2F;3844&#x2F;54% (iOS 13.1.3)iPhone 11 Pro Max: 2067&#x2F;3740&#x2F;55% (iOS 13.2.3) 由上数据，可以看到以 iPhone 11 Pro Max 为例，内存的最大空间为 3740MB，应用可使用的最大空间为 2067MB，占了 55%。iOS 的总内存空间虽然很有限，但 iOS 给每个进程分配的虚拟内存空间还是非常大的。 由上，iOS 对比桌面操作系统，同样使用了虚拟地址，没有使用 Swap 内存交换机制，而是通过内存压缩机制（Compressed memory）来最大化利用内存。 iOS 系统内存以下分析参考自苹果在 WWDC 2018 上的 Session：416. iOS Memory Deep Dive 在前面关于操作系统 CPU 寻址方式中提到了内存采用了分段+分页的管理方式。具有 VM 机制的操作系统，会对每个运行的进程创建一个虚拟地址空间，该空间的大小有操作系统决定。虚拟地址空间会被分为相同大小的块，这些块被称为 内存页（Memory Page）。计算机处理器和它的内存管理单元（MMU）维护着一张将程序的虚拟地址空间映射到物理地址上的分页表（Page Table）。iOS 中虚拟内存和物理内存的分页大小都是 16KB。 iOS 的内存页（Memory Page）主要分两类：Clean Page 和 Dirty Page。 Clean Page 对于一般的桌面操作系统，Clean Memory 是能够 Page Out 的部分。Page Out 指将优先级低的内存数据交换到磁盘上，但 iOS 不支持 Swap，所以 Clean Page 在 iOS 是指只能够被系统清理出内存且在需要时能重新加载数据的 Page。包含的类型有： 应用的二进制可执行文件 Memory mapped files：.jpg、.data、.modal 等文件。 Frameworks* ：_DATA_CONST 字段。需要主意的是：这个字段在创建的时候是 Clean Page 类型的，但如果在程序运行起来时，我们对系统方法进行了 Swizzling，就会把这个内存页变成 Dirty Page。 Dirty Page Dirty Page 指不能被系统回收的内存占用。包含的类型有： 所有堆上的对象（如 malloc、Array、NSCache、UIViews、String） 图片解析缓冲（如 CGRasterData、ImageIO） Frameworks（如 _DATA、_DATA_DIRTY） 可以看到 Framework 既有 Clean Page，也有 Dirty Page。 Compressed Memory当内存紧张时，系统会将暂不访问的物理内存进行压缩，直到下一次访问的时候进行解压。例如当我们使用 Dictionary 去缓存数据的时候，假设现在使用了 3 页内存，当不访问的时候可能会被压缩为 1 页，再次使用到时候又会解压成 3 页。如下图： Compressed Memory 是一种用 CPU 时间换空间的方式。 内存警告当 App 收到内存警告时，苹果给出了一些关于内存警告的一些想法： 并不是所有的内存警告都是 App 本身造成的。如使用 App 的过程中接听到电话，也可能触发内存警告。 内存压缩机制使得内存释放变得比较复杂。如前面 Dictinary 的例子。假设我们收到内存警告，我们可能会决定将字典中的一些数据删除。在我们重新访问压缩后的 Page 时，系统会先解压这块内存，Dictionary Page 就会从一个变为 3 个；之后释放 Dictionary 所占的 Page；此时实际释放的 Page 还是 1 个。因为操作过程中有一个解压的过程，很容易造成内存紧张的状态。 不要一味的缓存，要找到 CPU 计算和内存性能之间的平衡点。相比较使用字典缓存，苹果更推荐使用 NSCache。NSCache 分配的内存可以由系统自动释放，官方针对内存警告也做了优化。 我们平时关心的内存占用其实是 Dirty Size 和 Compressed Size 两部分，所以当我们想要优化内存时，尽量从这两部分入手。 App 中内存占用（Memory Footprint）有一定的限制： 不同设备的内存限制不同 App 都具有相当高的占用空间限制 提供给 Extensions 内存比较少 如果内存超过了限制范围，App 会抛出 EXC_RESOURCE_EXCEPTION 异常 附带 Stackoverflow 上查找看到一份关于 iOS 中单应用可用最大内存的测试报告（iOS app maximum memory budget） iOS App 内存iOS 系统层面的内存，大多由系统自动完成。通常开发者讨论的内存管理，实际上是进程内部语言层面的内存管理。iOS 中一个 App 对应一个进程。 App 内存空间 内存分区按高地址到低地址依次为： 栈区（Stack） 堆区（Heap） 静态存储区（Static） 常量区 在程序中使用的常量（如常量字符串）存储在该区域。在程序结束后，由系统释放。 代码区 存放函数体的二进制代码。运行程序实际上是执行代码，代码要执行就需要先加载入内存。 展开介绍下栈区（Stack）、堆区（Heap）和静态存储区（Static）。 栈区（Stack）栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。 在执行函数时，函数内局部变量的存储单元（指非静态的局部变量，如：函数参数、在函数内所声明对象的指针等）都会在栈上进行创建，函数执行结束时（出作用域时），这些存储单元会被自动释放。栈区的内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量是有限的，当系统的栈区大小不够分配时，系统会提示栈溢出。官方也给出了 iOS 中栈空间的大小，子线程为 512KB，主线程为 1MB（官方链接），如下图： 栈是向低地址扩展的，是一块连续的内存区域，且栈顶的地址和栈的最大容量是由系统预先规定的，遵循 FILO，不产生内存碎片。只要栈的剩余空间大于所申请空间，系统讲为程序提供内存；否则将报异常提示栈溢出。因此，能从栈获得的空间较小。开发过程中，需要留意的是：像大量的局部变量，深递归，函数循环调用都可能导致栈溢出而运行崩溃。 堆区（Heap）堆区中的变量由开发者进行分配和释放。操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。大多系统，会在这块内存空间中的首地址处记录本次分配的大小，以使得内存空间释放时正确。另外，由于找到的空闲堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 堆是向高地址扩展的，是不连续的内存区域。这是由于系统使用了链表来存储空闲的内存地址，而链表的遍历方向是由低地址向高地址。堆的大小由系统中有效虚拟内存决定。因此，堆的空间比较灵活，也比较大，由于堆的特性，也容易产生内存碎片，但用起来较为方便。 静态存储区（Static）这块内存在程序编译时就已经分配好，在程序的整个运行期间这块内存都会存在。它主要用来存放静态变量、全局变量和常量。事实上全局变量也是静态的，因此，也叫全局静态存储区。 静态存储区分为两部分： 数据区：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域 BSS 区：未初始化的全局变量和静态变量在相邻的另一块区域。 在程序结束运行后，这块内存由系统释放。 引用计数移动端的内存管理技术，主要有 GC（Garbage Collection 垃圾回收）的标记清楚算法和苹果使用的引用计数方法。 早期的 iOS 开发通过手动引用计数（MRC - Mannul Reference Counting）的方式手动管理引用计数，由于 MRC 维护成本的原因，苹果在 2011 年的 WWDC 提出了自动引用计数（ARC - Automatic Reference Countin）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置插入引用计数管理代码。遵循谁申请谁释放的原则。虽然 ARC 帮助我们解决了引用计数大部分的问题，但开发过程中如果不留意会很容易出现类似循环引用而导致的内存泄露的问题。移动设备的内存资源是有限的，当 App 运行时占用的内存超过限制后，会被强制杀掉，用户体验会被极大降低。为了提升 App 质量，开发者需要重视应用的内存管理问题。 引用计数（Reference Count）是一种管理对象生命周期的方式。在创建一个新对象时，它的引用计数为 1；每当该被引用时，它的引用计数 +1；每当引用该对象的对象释放时，它的引用计数 -1。当该对象的引用计数为 0 时，说明该对象不再被任何对象使用，这时该对象会被销毁，内存回收。过程如下图： 一个需要主意的点：当对象被释放时，它的 retainCount 不一定为 0。如下代码： - (void)testRetainCount &#123; NSObject *object = [[NSObject alloc] init]; NSLog(@\"Reference Count = %u\", [object retainCount]); [object release]; NSLog(@\"Reference Count = %u\", [object retainCount]);&#125; 输出结果如下： Reference Count = 1Reference Count = 1 会发现 object 在 release 前后的引用计数都为 1。这是为什么？ 是因为当最后一次执行 release 时，系统知道马上就要回收内存，没有必要再将 retainCount - 1。因为不管是否 -1，该对象都确定会被回收，而对象被回收后，所在的内存区域包括 retainCount 的值已经没有意义。这里不将 1 变为 0，是为了减少一次内存写操作，进而加速对象的回收。 ARC 虽然帮助开发者解决了 iOS 开发过程中绝大部分的内存管理问题，但底层 Core Foundation 对象的部分不在 ARC 的管理范围内，需要开发者自己维护这些对象的引用计数。 循环引用引用计数管理内存的方式是：当对象自己被销毁时，其成员变量引用计数 -1。但如果出现下面的引用情况： 上图中，对象 A 持有对象 B，同时对象 B 也持有对象 A。在外界对对象 A 和对象 B 没有其他任何引用的情况下，对象 A 若想释放，只能先释放对象 B；但对象 B 若想释放，同样需要先释放对象 A。这样就出现了循环引用（Reference Cycle）的问题。 解决循环引用问题主要有两种方式： 第一种是主动断开循环，通过置 nil 主动释放的方式 第二种是通过使用弱引用 弱引用虽然持有对象，但不会增加被持有对象的引用计数，这样就避免了循环引用的产生。弱引用用的比较多的场景比如：delegate 模式的使用。 如上图的例子，两个 ViewController。场景是 ViewController A 弹出 ViewController B，在 ViewController B 做完一些操作后，将一些数据返回给 ViewController A。这时，因为 delegate 是弱引用，不会变更引用计数，这样就避免了循环引用的产生。 弱引用的实现原理系统对于每一个有弱引用的对象，都维护了一个表来记录它所有弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置为 nil。 更细节的关于弱引用的实现原理，后面会有单独的一篇来分析。 OOMOOM 是 Out of Memory 的缩写，指当 App 占用的内存达到了 iOS 系统对单个 App 占用内存上限后会被系统强杀掉的现象。这是一种由 iOS 的 JetSam 机制导致的一种“另类”崩溃，并且日志无法通过信号捕捉到。 JetSam 机制，指的是操作系统为了控制内存资源过度使用而采用的一种资源管控机制。 在面对 OOM 类问题时，会考虑到两个方面的问题。一方面是，如何知道系统对单个 App 允许占用内存的上限值？另一方面是，如何定位 OOM？依次来看下对应的解决方案。 如何获取内存上限值？JetsamEvent 日志我们可以从设置 - 隐私 - 分析与改进这条路径看到系统的日志，找到以 JetsamEvent 开头的系统日志，我们可以通过隔空投送到电脑或直接在手机上查看这些日志内容。 在这类系统日志中，查找崩溃原因时如果看到&quot;reason&quot; : &quot;pre-process-limit&quot;，则表示崩溃是由于 App 占用的内存超过了系统对单个 App 的内存限制。对应查找&quot;rpages&quot; 对应的值，这个值表示 App 占用的内存页数量。 日志内容的结构如下： &quot;rpages&quot; : 89600,&quot;reason&quot; : &quot;per-process-limit&quot;, 通过 JetsamEvent 日志获取了内存页数量 rpages 为 89600，只要再知道内存页大小的值，就可以计算出单个 App 的内存上限值。 继续在 JetsamEvent 日志中查找以 &quot;pageSize&quot; 对应的值，为 16384。通过下面的计算公式得到值为 1.4G。 内存上限值 = pageSize * rpages / 1024 / 1024 MB JetsamEvent 日志是系统在杀掉 App 后留在手机中的，属于系统级日志，存放在系统目录下，App 上线后开发者是没有权限获得的。 那么 iOS 是怎么监控内存压力的？ iOS 系统会开启优先级最高的线程 vm_pressure_monitor 来监控系统的内存压力情况，并通过一个堆栈来维护所有 App 的进程。此外，iOS 系统还会维护一个内存快照表，用于保存每个进程内存页的消耗情况。 当vm_pressure_monitor线程发现某 App 内存有压力了，会为该 App 发送通知，也就是 didReceiveMemoryWarnning 代理。通过这个代理，可以写需要的内存释放代码，以避免 App 被系统强制杀死。 iOS 系统内核有一个数组，专门用于维护线程的优先级。优先级由高到低依次是：内核用线程的优先级 &gt; 操作系统 &gt; 前台 App &gt; 后台运行 App 苹果考虑到手持设备存储空间有限，在 iOS 中去掉了 Swap，这样虚拟内存就没办法记录到外部的存储上，进而苹果引入了 MemoryStatus 机制。 MemoryStatus 机制的主要思路是，在 iOS 上弹出尽可能多的内存共当前应用使用。把这个机制落到优先级上，就是先强杀后台应用；如果内存还不够就强杀掉当前应用。MemoryStatus 机制会开启一个 memorystatus_jetsam_thread 线程，这个线程和 vm_pressure_monitor 没有关系。memorystatus_jetsam_thread线程只负责强杀应用和记录日志，不会发送通知消息；vm_pressure_monitor线程也无法获取强杀应用的消息。 除了内存过大的原因会被系统强杀，还有三种内存问题也会被强杀： 访问未分配的内存。XNU 会报 EXC_BAD_ACCESS 错误，发出 SIGSEGV Signal #11 信号。这类报错绝大多数是由于对一个已经释放的对象进行 release 操作造成的。 访问已分配但未提交的内存。XNU 会拦截分配物理内存，出现问题的线程分配内存页时会被冻结。 没有遵守权限访问内存。内存页的权限标准类似 UNIX 文件权限，如果对只读权限的内存页进行写入就会出错，XNU 发出 SIGSEGV Signal #7 信号。 第一种和第三种问题可以通过崩溃信息获取到，在收集崩溃信息时如果是这两类，可以把内存分配的记录同时收集，用于分析不合理内存分配和优化。 通过 XNU 获取XNU 中有专门用于获取内存上限值的函数和宏，可以通过 memorystatus_priority_entry 结构体得到进程的优先级和内存上限值。结构体中 priority 表示进程的优先级；limit 表示进程的内存上限值。相关源码如下： // 获取进程的 pid、优先级、状态、内存阈值等信息typedef struct memorystatus_priority_entry &#123; pid_t pid; int32_t priority; uint64_t user_data; int32_t limit; uint32_t state;&#125; memorystatus_priority_entry_t;// 基于下面这些宏可以达到查询内存阈值等信息，也可以修改内存阈值等/* Commands */#define MEMORYSTATUS_CMD_GET_PRIORITY_LIST 1#define MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES 2#define MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT 3#define MEMORYSTATUS_CMD_GET_PRESSURE_STATUS 4#define MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK 5 /* Set active memory limit = inactive memory limit, both non-fatal */#define MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT 6 /* Set active memory limit = inactive memory limit, both fatal */#define MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES 7 /* Set memory limits plus attributes independently */#define MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES 8 /* Get memory limits plus attributes */#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE 9 /* Set the task's status as a privileged listener w.r.t memory notifications */#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE 10 /* Reset the task's status as a privileged listener w.r.t memory notifications *//* Commands that act on a group of processes */#define MEMORYSTATUS_CMD_GRP_SET_PROPERTIES 100 XNU 详细相关源码链接： kern_memorystatus.h kern_memorystatus.c 通过 XNU 宏获取内存限制，需要越狱来获取 root 权限，正常情况下开发者看不到这些信息。 通过内存警告获取前面提到内存警告时，系统的内存监控线程会给相关 App 发送通知didReceiveMemoryWarnning。我们可以利用这个内存压力代理事件来动态获取内存上限值。系统在强制杀死 App 前会有 6s 的时间，这段时间足够我们获取记录内存信息。iOS 系统提供了一个 task_info 函数，我们可以在发生内存警告时，通过 task_info_t 结构内的 resident_size 字段获取当前 App 占用了多少内存。具体代码如下： #import &lt;mach/mach.h&gt;- (int64_t)memoryUsage &#123; int64_t memoryUsageInByte = 0; struct task_basic_info taskBasicInfo; mach_msg_type_number_t size = sizeof(taskBasicInfo); kern_return_t kernelReturn = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t) &amp;taskBasicInfo, &amp;size); if(kernelReturn == KERN_SUCCESS) &#123; memoryUsageInByte = (int64_t) taskBasicInfo.resident_size; NSLog(@\"Memory in use (in bytes): %lld\", memoryUsageInByte); &#125; else &#123; NSLog(@\"Error with task_info(): %s\", mach_error_string(kernelReturn)); &#125; return memoryUsageInByte;&#125; 但测试的时候，我们会发现计算出的值跟 Instruments 里看到的内存大小不一致，甚至相差及时 MB。resident_size（驻留内存）确实无法反映真实的物理内存，而且 Xcode 的 Debug Gauge 使用的也是 phys_footprint，这点从 WebKit 和 XNU 的源码可以佐证。 WebKit 相关源码： size_t memoryFootprint()&#123; task_vm_info_data_t vmInfo; mach_msg_type_number_t count = TASK_VM_INFO_COUNT; kern_return_t result = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count); if (result != KERN_SUCCESS) return 0; return static_cast&lt;size_t&gt;(vmInfo.phys_footprint);&#125; XNU 源码中 JetSam 判断应用内存是否使用过大也是使用的 phys_footprint。WWDC 2018 Session iOS Memory Deep Dive 对 footprint 这块也有介绍。 贴近 JetSam 机制，更准确的内存计算方式应该是通过 phys_footprint: #import &lt;mach/mach.h&gt;- (int64_t)memoryUsage &#123; int64_t memoryUsageInByte = 0; task_vm_info_data_t vmInfo; mach_msg_type_number_t count = TASK_VM_INFO_COUNT; kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count); if(kernelReturn == KERN_SUCCESS) &#123; memoryUsageInByte = (int64_t) vmInfo.phys_footprint; NSLog(@\"Memory in use (in bytes): %lld\", memoryUsageInByte); &#125; else &#123; NSLog(@\"Error with task_info(): %s\", mach_error_string(kernelReturn)); &#125; return memoryUsageInByte;&#125; 如何定位 OOM?OOM 分为两大类，Foreground OOM / Background OOM，即 FOOM 和 BOOM。其中 FOOM 是指 App 在前台因消耗内存过多引起系统强杀。对用户而言，表现跟 crash 一样。 现在主流的 OOM 检测库有两个： FBAllocationTracker OOMDetector Facebook 早在 2015 年 8 月提出 FOOM 检测办法，大致原理是排除各种情况后，剩余的情况是 FOOM，原文：Reducing FOOMs in the Facebook iOS app。可以使用 Facebook 的 FBAllocationTracker 工具监控 OC 对象分配，用 fishhook 工具 hook malloc/free 等接口监控堆内存分配，每隔 1 秒，把当前所有 OC 对象个数、TOP 200 最大堆内存及其分配堆栈，用文本 log 输出到本地。 这个方案的不足点： 监控粒度不够细，像大量分配小内存引起的质变无法监控，另外 fishhook 只能 hook 自身 app 的 C 接口调用，对系统库不起作用； 打 log 间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、I/O 频繁等性能问题； 上报的原始 log 靠人工分析，缺少好的页面工具展现和归类问题。 在这之后微信开源了 OOMDetector，使用了更底层的 malloc_logger_t 记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样符号表地址=堆栈地址-slide。另外，还做了数据归类。具体的实现方案可以查看原文：iOS微信内存监控 OOM 常见问题UIGraphicsEndImageContextUIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 Xcode 的 Analyze 也能扫出这类问题。 UIWebView无论是打开网页，还是执行一段简单的 js 代码，UIWebView 都会占用 App 大量内存。而 WKWebView 不仅有出色的渲染性能，且有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替 UIWebView。 autoreleasepool通常 autoreleased 对象是在 runloop 结束时才释放。如果在循环里产生大量 autoreleased 对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。 互相引用比较容易出现互相引用的地方是 block 里使用了 self，而 self 又持有这个 block，只能通过代码规范来避免。另外 NSTimer 的 target、CAAnimation 的 delegate，是对 Object 强引用。 大图片压缩当我们在缩小一幅图像的时候，会按照取平均值的办法把多个像素点变成一个像素点，这个过程称为 Downsampling。通常图片缩放接口可以如下写法： 但处理大分辨率图片时，往往容易出现 OOM，原因是 -[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的 bitmap，这是很消耗内存。解决方法是使用更底层的 ImageIO 接口，它可以直接读取图像大小和元数据信息，不会带来额外的内存开销。 大图加载显示WWDC 2018 Session 416：iOS Memory Deep Dive提出建议使用 UIGraphicsImageRenderer 代替 UIGraphicsBeginImageContextWithOptions，该方法从 iOS 10 引入了，在 iOS 12 上会自动选择最佳的图片格式，可以减少很多内存。如果想修改颜色，可以直接修改 tintColor，不会有额外的内存开销。 图片在 iOS 上的显示原理：WWDC 2018 Session 219：Image and Graphics Best Practices对应的翻译文稿：《WWDC2018 图像最佳实践》 大图切换前后台时的优化假设在 App 里展示了一张很大的图片，当我们切换到后台去做其它的操作时，这个图片还在占用内存。我们应该考虑在合适的时机去回收这类占用过大的数据。 大视图大视图是指 View 的 size 过大，自身包含要渲染的内容。超长文本如常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个 View 里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个 View 绘制，利用 TableView 的复用机制，减少不必要的渲染和内存占用。 内存检测工具列出一些内存分析的工具： Xcode Memory Gauge在 Xcode 中，你可以通过 Memory Gauge 工具，快速查看 App 运行时的内存情况，包括内存最高占用、最低占用，以及在所有进程中的占用比例等。如果想要查看更详细的数据，就需要用到 Instruments 了。 Instruments 在 Instruments 中，你可以使用 Allocations、Leaks、VM Tracker 和 Virtual Memory Trace 对 App 进行多维度分析。 Allocations：可以查看虚拟内存占用、堆信息、对象信息、调用栈信息，VM Regions 信息等。可以利用这个工具分析内存，并针对地进行代码优化。 Leaks：用于检测内存泄漏。 VM Tracker：可以查看内存占用信息，查看各类型内存的占用情况，比如 dirty memory 的大小等等，可以辅助分析内存过大、内存泄漏等原因。 Virtual Memory Trace：有内存分页的具体信息，具体可以参考 WWDC 2016 - Syetem Trace in Depth。 Debug Debugger - Memory Resource Exceptions 当使用 Xcode 10 以前的版本进行调试时，在内存过大时，debug session 会直接终止，并且在控制台打印出异常。从 Xcode 10 开始，debugger 会自动捕获 EXC_RESOURCE RESOURCE_TYPE_MEMORY 异常，并断点在触发异常抛出的地方，十分方便定位问题。 Xcode Memory Debugger 通过这个工具，可以直观地查看内存中所有对象的内存使用情况，对象相互间的依赖关系，对定位那些因为循环引用导致的内存泄露问题十分有帮助。我们也可以点击 File -&gt; Export Memory Graph 将其导出为 memgraph 文件，在命令行中使用 Developer Tool 对其进行分析。使用这种方式，我们可以在任何时候对过去某时的 App 内存使用进行分析。 vmmap用于查看虚拟内存。 # 查看详细报告vmmap App.memgraph# 查看摘要报告vmmap --summary App.memgraph# vmmap and AWK 查看所有动态库的Ditry Pages的总和vmmap -pages PlanetPics.memgraph | grep '.dylib' | awk '&#123;sum += $6&#125; END &#123; print \"Total Dirty Pages:\"sum&#125;'# 查看vmmap的文档man vmmap leaks用于查看泄露的内存。 # 查看是否有内存泄露leaks MyApp.memgraph# 查看 leaks 的文档man leaks heap查看堆区内存。 # 查看所有堆区对象的内存使用heap App.memgraph# 默认情况下是按照对象数量进行排序，通常情况下它们不会造成什么内存问题。# 我们更关心的那些为数不多但占用大量内存的对象# 参数 -sortBySize，按照内存占用大小顺序来查看所有堆区对象的内存使用heap App.memgraph -sortBySize# 当确定是哪个类型的对象占用了太多内存之后，可以得到每个对象的内存地址heap App.memgraph -addresses all | &lt;classes-pattern&gt;# 查看 heap 的文档man heap Enabling Malloc Stack Logging在 Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics 中，开启 Malloc Stack 功能，建议使用 Live Allocations Only 选项。之后 lldb 会记录调试过程中对象创建的堆栈，配合 malloc_history 工具，就可以定位到那些占用了过大内存的对象是哪里创建的。 malloc_history查看内存分配历史。 # 查看内存分配历史malloc_history App.memgraph [address]# 查看文档man malloc_history 参考文章： iOS Memory 内存详解 存储器层次结构 浅谈CPU寻址内存机制 Memory Usage Performance Guidelines 理解 iOS 的内存管理 iOS微信内存监控 WWDC 2018：iOS 内存深入研究 WWDC 2018 Session 416：iOS Memory Deep Dive","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"基础","slug":"基础","permalink":"https://blog.jonyfang.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"iOS 启动速度优化调研","slug":"2019-12-15-ios-speed","date":"2019-12-14T16:00:00.000Z","updated":"2021-01-12T10:12:14.852Z","comments":true,"path":"2019/12/15/2019-12-15-ios-speed/","link":"","permalink":"https://blog.jonyfang.com/2019/12/15/2019-12-15-ios-speed/","excerpt":"本篇主要是对应用启动时间优化的梳理。","text":"本篇主要是对应用启动时间优化的梳理。 启动过程的技术调研App 总启动时间 t 分为两部分： main() 之前的加载时间 t1 main() 之后的加载时间 t2 即 t = t1 + t2。 其中 t1 = 系统 dylib（动态链接库）加载时间 + App 可执行文件加载时间；t2 = 从 main() 方法执行到 AppDelegate 类中 didFinishLaunchingWithOptions: 方法执行结束前的时间。 依次看下 t1、t2 都做了什么。 main() 调用之前的加载App 启动后，系统会先加载 App 中所有的可执行文件（.o 文件集合）；然后加载动态链接库 dyld（dyld 是专门用来加载动态链接库的）。 dyld 从可执行文件中递归所有依赖的动态链接库。动态链接库有： iOS 中所有系统 framework libobjc（用于加载 OC runtime 方法） libSystem（如 GCD 的 libdispatch、Block 的 libsystem_blocks） 系统链接库和 App 本身的可执行文件，都是 image，每个 App 是以 image 为单位进行加载的。 imageimage 有： 可执行文件（.o 文件） dylib 动态链接库（动态链接库+相应资源包，如 UIKit、Foundation 等） 关于动态链接动态链接的好处： 代码公用。很多程序动态链接这些 lib，但内存和磁盘中只有一份。 易于维护。因被依赖的 lib 在程序运行时才链接，所以这些 lib 可以很容易被更新。 减少了可执行文件的体积。相比静态链接，动态链接不需要在编译时打包到包内，可执行文件小了很多。 所有动态链接库 framework、静态库 .a、所有类编译后的 .o文件，最终都是通过 dyld（动态链接器）加载到内存中。每个 image 都由一个 ImageLoader 的类来负责加载。 ImageLoaderimage 表示二进制文件，ImageLoader 的作用是将这些文件加载到内存，且一一对应，每个 ImageLoader 对应加载一个文件。 在程序运行时，先将动态链接的 image 递归加载，再从可执行文件 image 递归加载所有符号。 动态链接库加载的具体流程加载主要分为 5 步： load dylibs image rebase image bind image objc setup initializers load dylibs image 在加载每个动态库时，dyld 需要： 分析依赖的动态库 找到动态库的 mach-o 文件 打开文件 验证文件 在系统核心注册文件签名 对动态库的每个 segment 调用 mmap() 系统库由于被优化，加载会很快，这里加载可做的优化有： 减少非系统库的依赖 合并非系统库 部分库，通过拷贝代码的方式引入 rebase/bind image 由于 ASLR(address space layout randomization) 的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，需要先修复 image 的指针，再指向正确地址。 rebase 修复指向当前 image 内部的资源指针；bind 指向 image 外部的资源指针。 rebase 的步骤： 将镜像读入内存 以 page 为单位进行加密验证，保证不会被篡改 rebase 之后再进行 bind，bind 步骤： 查询符号表，指向跨 image 的资源 该阶段可优化的点： 减少 objc 类的数量，减少 selector 数量 swift 多使用 struct，以减少符号数量 objc setup 这一步： 注册 objc 类 把 category 的定义插入方法列表 保证每个 selector 唯一 如果前面减少了依赖和减少了 objc 类数量及 selector 数量，则这一步不在需要额外优化。 initializers 前面三步都是在修改 _DATA segment，这一步开始在堆和栈中写入内容。具体有： objc +load 其他构造函数（如 c++） 具体顺序： dyld 开始将程序二进制文件初始化 交由 ImageLoader 读取 image，包含了类、方法及各种符号 由于 runtime 向 dyld 绑定了回调。当 image 加载到内存后，dyld 会通知 runtime 去处理 runtime 收到通知后，调用 mapImages 做析构和处理。接着 loadImages 中调用 callloadmethods 方法。遍历所有加载进来的 class，按继承层级依次调用 class 的 +load 方法及其 category 的 +load 方法 到这里，可执行文件和动态库的所有内容（class、selector、IMP等）都已按格式加载到内存，被 runtime 所管理。接着，runtime 的一些黑科技，如 swizzle 才可以生效。 在初始化完成后，dyld 调用 main 函数。如果 App 是第一次被运行，App 的代码会被 dyld 缓存，因此杀掉进程再次打开 App 时，会发现还是很快。但如果该 App 长时间未启动或当前 dyld 的缓存被其他 App 占用，则需要再进行前面的链接加载过程，时间会长些。这也是冷启动和热启动的概念。 t1 的时间如何得到？真机调试时，Scheme 中 Run 开启 DYLD_PRINT_STATISTICS，会得到类似如下输入（截图来自官方 session）： 根据图可以看到主要耗时在 image 加载和 oc 类的初始化。 所以针对 main() 调用之前的加载可以优化的点有： 减少不必要的 framework，以减少动态链接的耗时 合并或删减一些 oc 类。可以通过 AppCode 检测当前没用的类 无用静态变量 废弃的方法 将 +load 方法中的实现尽量延迟到 +initialize main() 调用之后的加载main() 调用之后，主要进行的是初始化相关的服务，显示首页内容。 视图的渲染分三个阶段： 准备阶段。图片的解码。 布局阶段。首页所有 UIView 的 layoutSubViews 运行 绘制阶段。首页所有 UIView 的 drawRect: 运行 接着，是启动之后的必要初始化、一些数据的创建和读取。 所以针对 main() 调用之后可优化的点有： 使用代码加载首页视图，不使用 xib 一些非必要的初始化可以延后 每次 NSLog 会隐式创建一个 Calendar，只在内测时开启 log 启动时的网络请求异步处理 main() 调用之后的耗时，可以借助 Instruments 的 Time Profiler 工具查看。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"}]},{"title":"iOS IPA 包体积优化","slug":"2019-11-10-ios-ipa","date":"2019-11-09T16:00:00.000Z","updated":"2021-01-12T10:01:18.144Z","comments":true,"path":"2019/11/10/2019-11-10-ios-ipa/","link":"","permalink":"https://blog.jonyfang.com/2019/11/10/2019-11-10-ios-ipa/","excerpt":"记录 IPA 包体积优化过程中的一些思路。","text":"记录 IPA 包体积优化过程中的一些思路。 背景随着业务量的不断增加，应用安装包大小也在迅速的增长，而安装包大小的增加对应用的推广拉新会造成比较大的影响。因为这样，我们进行了 2 期的安装包大小的优化，第一期优化从 107MB 到 84MB，第二期优化 8MB。本篇主要是用于记录优化过程中的一些思路。 优化方向优化前我们首先要确定的是优化指标及优化方向。我们最终是以 ipa 包中 xxx.app 大小作为优化前后的对比项。优化方向上，首先我们需要看下 ipa 包中 xxx.app 有哪些组成。 解压 xxx.app，会看到的模块有： AppIcons。各尺寸的应用图标。 Assets.car。Asset Catalog 的编译产物。 Frameworks。存放着动态库。 编译后的可执行文件 PlugIns。插件路径（如 Today Extension） 其他 通过文件结构，我们大概有的优化思路是： 资源文件（图片或配置文件）的处理 代码的处理，以减小编译后可执行文件大小 Today Extension 的代码优化 编译配置是否有可优化的点 根据这 4 个优化方向，具体看下对应的优化方案。 优化方案资源文件优化图片资源关于图片，我们使用的也是通用的方案，主要是两方面的处理： 无用图片的移除 图片压缩 项目从 3.8.0 版本开始，图片资源除去启动图及部分场景下使用的 AppIcon，其他图片全部迁移到了 Images.xcassets 中，所以针对 Images.xcassets 进行图片处理。 无用图片的移除 通过资源关键字进行全局匹配，筛选出未使用的资源文件 这里我们使用的是 LSUnusedResources 查找出图片后，需要人工再对图片的使用情况做确定。之后对应删除 图片压缩 经过上一步的无用图移除，剩下的图片是当前版本所需要的，可以对这些图片进行无损压缩 因为 TinyPNG有限制，最终我们使用的是批量处理工具 iSparta 比较惊讶的是，我们查找到了 15869.44KB（15MB）的无用图片及压缩了 6MB。 查找重复文件我们通过 fdupes 工具来扫描查找重复文件。fdupes 是通过校验所有资源的 MD5，筛选出项目的重复资源。文件比较顺序依次为： 大小对比 部分 MD5 签名对比 完整 MD5 签名对比 逐字节对比 相关命令： # 安装brew install fdupes# 查看某文件夹下的重复文件fdupes -Sr ./filepath &gt; outlog.txt 大文件转下载非必要的大文件资源，如字体库、皮肤资源、子页面大图，不放到 ipa 包中，转为下载的方式。 关于 Images.xcassetsiOS9 开始苹果建议将图片资源文件放入 Images.xcassets 中。Images.xcassets 中的图片在加载后会有缓存，可以提升加载速度；打包时会进行自动的 PNG 图片压缩，再根据运行设备的不同分发 x2/x3 图片资源。 Pod 库也可以通过 Images.xcassets 来存放图片资源，在 podspec 中指定 resource_bundles： s.resource_bundles = &#123; 'podname' =&gt; ['./Assets/*.xcassets']&#125; 相关的编译配置： Compress PNG Files Remove Text Metadata From PNG Files 代码层面优化按责分配模块，review 代码，去除重复代码。也是工作量比较大的一个模块。 编译选项配置 指定编译生成包所支持的架构 Build Settings -&gt; Valid Architectures 中，因为不再支持 iOS9 以下及 32位，我们去掉了对 armv7 的支持，以减小 ipa 包大小。 编译器优化级别 Build Settings -&gt; Optimization Level 在 release 版选择 Fastest, Smallest。会优化可执行文件的大小，使其尽可能小。 去除符号信息 Build Settings 中 Strip Linked Product / Deployment Postprocessing 在 release 版本设置为 YES，可以去除不必要的调试符号。 Strip Linked Product 默认为 YES，Deployment Postprocessing 默认为 NO，而 Strip Linked Product 在 Deployment Postprocessing 设置为 YES 的时候才生效。 这些配置选项的在旧版 Xcode 生成的项目中不一定默认遵循，可以检查下，以达到一定的编译优化。 App ThinningiOS9 开始引入了 App Thinning，相关 Session 介绍：WWDC15 - App Thinning in Xcode。 App Thinning 的概念是，当用户安装应用时，苹果会根据当前用户的机型来选择合适的资源文件及对应 CPU 架构的二进制可执行文件（即不会同时存在 armv7、arm64 的情况），减少了用户的下载流量和安装占用的空间。 App Thinning 的开启方式是，在上传 App 时，配置 App Thinning 即可。 App Thinning 分为三部分： Slicing Bitcode On-Demand Resources Slicing 原理入图所示。在我们将 Archive 的 App Record 传到 iTunes Connect 后，它会被分割为不同的变体，不同的点是CPU 架构的二进制可执行文件（如 armv7 或 arm64）及 资源文件（如 Image.xcassets 中 x2/x3 的图片）。 当用户从 App Store 下载时，只会下载特定的变体。 BitcodeBitcode 是编译好的程序中间码，在苹果推出新的架构或有新的 LLVM 优化时，不需要重新上传 App。 开启方式是，Build Settings -&gt; Enable Bitcode 置为 YES 即可，需要 App 中所有的静态库和动态库都支持，避免编译失败。 On-Demand Resources 按需加载资源。在 Build Settings 中需要开启 Enable On Demand Resource，接着在 Resource Tags 中添加对应的资源文件，使用时通过 NSBundleResourceRequest 获取按需加载的资源文件。 更多详细介绍：WWDC15 - Introducing On Demand Resources 其他方向 Framework 只保留需要的指令集。可以通过 lipo 命令处理。 App Extension 中使用动态库，以和主 App 共享同一个库。 第三方库在引入时慎重，尽量只引入需要的模块。 总结主要是从资源文件、code review 及编译选项配置几个方面，进行 App 的瘦身。过程中要利用苹果自身的机制，如 Image.xcassets、App Thinning 机制。 iOS 项目在开发初期，我们很容易忽略安装包大小的增长，除去后期的优化，在日常开发中也需要关注的一些点。 资源文件在引入时，需要按需做无损压缩和有损压缩 不要为了一个小功能而引入一个大的库 平时开发过程中，废弃模块要及时清理 同类开源库，只引入一个 最好能够有预警机制，打完包后，能够生产一份分析文件，列出与上次包的大小对比","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"优化相关","slug":"优化相关","permalink":"https://blog.jonyfang.com/categories/%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"优化相关","slug":"优化相关","permalink":"https://blog.jonyfang.com/tags/%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"}]},{"title":"YYText 中的 CoreText","slug":"2019-11-07-yytext","date":"2019-11-06T16:00:00.000Z","updated":"2021-01-12T10:09:55.649Z","comments":true,"path":"2019/11/07/2019-11-07-yytext/","link":"","permalink":"https://blog.jonyfang.com/2019/11/07/2019-11-07-yytext/","excerpt":"富文本框架里YYText在性能方面的表现很出色，它基于 CoreText 做了大量基础处理并实现了两个上层视图组件：YYLabel 和 YYTextView。在了解富文本处理之前，我们还需要对 CoreText 基础知识做一些了解。本篇主要梳理 YYText 中 CoreText 的底层基础部分处理。","text":"富文本框架里YYText在性能方面的表现很出色，它基于 CoreText 做了大量基础处理并实现了两个上层视图组件：YYLabel 和 YYTextView。在了解富文本处理之前，我们还需要对 CoreText 基础知识做一些了解。本篇主要梳理 YYText 中 CoreText 的底层基础部分处理。 框架概述iOS 中我们常会在主线程中进行 UI 的绘制，但当绘制压力过大时会造成页面卡顿情况的出现。一种解决思路是，通过多线程在异步线程进行图形的绘制，以减轻主线程的压力。 YYText 框架的实现思路也是这样的。 创建自定义绘制线程 在该线程中创建图形上下文 通过 CoreText 绘制富文本，通过 CoreGraphics 绘制图片、阴影、边框等 最后将绘制完成得到的位图，回到主线程展示 CoreText 工具类关于 CoreText 的结构图： YYTextRunDelegate富文本中为定制一段区域的大小，可以在富文本中插入 key 为 kCTRunDelegateAttributeName 的 CTRunDelegateRef 实例。通过这种方式来预留空白，以用来填充图片，进行图文的混排。作者可能考虑到 CFRunDelegateRef 本身的使用会比较繁琐，为了简易使用，进行了封装。也就是这里的 YYTextRunDelegate。 内部实现的思路： 通过 CTRunDelegateCreate() 创建一 CTRunDelegateRef 通过 __bridge_retained 转移内存管理，持有一个 YYTextRunDelegate 对象 一些细节处理： 内存管理问题。CTRunDelegateRef 实例持有 YYTextRunDelegate，当 CTRunDelegateRef 实例释放时，会调用 DeallocCallback()，将内存管理权限转移给 YYTextRunDelegate 局部变量的 ARC。 CTRunDelegateCreate() 里做了 copy 操作。这里是深拷贝，目的是为了创建一个副本，以保证配置数据的安全性，不会被篡改。 YYTextLine创建一个富文本，拿到 CTRunRef、CTLineRef 及一些结构数据（如 ascent、descent）。 line 位置及大小的计算// 不考虑竖排版_bounds = CGRectMake(_position.x, _position.y - _ascent, _lineWidth, _ascent + _descent);_bounds.origin.x += _firstGlyphPos; _position 指 line 的 origin 点位于 context 上下文的坐标转换为 UIKit 坐标系的值。 _position.y - _ascent 表示 y 起始位置 _ascent + _descent 表示 line 高度 _firstGlyphPos 表示第一个 run 相对 line 的偏移 找出占位 run基本原理是通过 CTRunDelegateRef 占位，再用 YYTextAttachment 填充。当遍历 line 里的 run 时，若该 run 内有 YYTextAttachment，说明是占位 run，计算这个 run 的位置和大小，便于后面填充。 runPosition.x += _position.x;runPosition.y = _position.y - runPosition.y;runTypoBounds = CGRectMake(runPosition.x, runPosition.y - ascent, runWidth, ascent + descent); runPosition 表示相对 line 的 x/y 偏移量 最后，缓存 YYTextAttachment 和 run 位置大小信息 YYTextContainerCTFrameRef 需要通过 CTFramesetterCreateFrame() 创建，该方法需要 CGPathRef 作为参数，作者封装了 YYTextContainer 类来简化使用。 /* Example: ┌─────────────────────────────┐ &lt;------- container │ │ │ asdfasdfasdfasdfasdfa &lt;------------ container insets │ asdfasdfa asdfasdfa │ │ asdfas asdasd │ │ asdfa &lt;----------------------- container exclusion path │ asdfas adfasd │ │ asdfasdfa asdfasdfa │ │ asdfasdfasdfasdfasdfa │ │ │ └─────────────────────────────┘ */ 开发者可以通过 CGSize 来设定富文本大小，也可以通过 UIBezierPath 定制路径。同时，CoreText 还支持镂空效果，通过 exclusionPaths 控制。 YYTextLayout包含了布局一富文本所有的信息，这个文件里也包含很多绘制相关的 C 代码。YYTextLayout 负责计算各种数据，为后面的绘制做准备。 核心计算方法： + (YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range; 计算绘制路径和路径的位置矩形基于 YYTextContainer 对象计算得到 CGPathRef。UIKit 转为 CoreText 坐标，需要先进行坐标处理。得到 pathBox，pathBox 是真正的绘制区域相对于绘制上下文的位置和大小。在后面计算 line 和 run 位置时，都需要这里的 cgPathBox.origin。 初始化 CTFramesetterRef 和 CTFrameRef计算 line 总 frame 前面 TextContainer 得到 CTFrameRef 接着遍历所有的 line，结合 cgPathBox.origin 计算得到每个 line 的位置和大小 最后将每个 line 的 rect 合并，得到包含所有 line 的最小位置矩形 textBoundingRect。 计算 line 的行数在有排除路径的情况下，一行可能有多个 line。所以需要计算每个 line 所在的行。 当 line 高度大于 lastline 高度时。若 lastline 的 baseline 在 line 的 y0~y1 之间，说明未换行。 当 line 高度小于 lastline 高度时。若 line 的 baseline 在 lastline 的 y0~y1 之间，说明未换行。 确定了 line 的换行规则，可以计算得到 line 的行数。 获取行上下边界的数组上下边界结构体： typedef struct &#123; CGFloat head; CGFloat foot;&#125; YYRowEdge; YYRowEdge 表示每一行的上下边界。遍历所有 line，当当前 line 和 last line 为同一行时，取 line 和 last line 最大上下边界；当当前 line 和 last line 不同行时，取当前 line 的上下边界。 结果如图示： 中间的间隙为行间距，YYText 将行间距进行了均分，如图示： 计算绘制区域的总大小 前面通过 YYTextContainer 计算得到绘制路径的位置矩形 pathBox（上图蓝色区域）。但这是实际绘制区域的大小，但应用场景中还会有 inset、borderWidth 之类的情况。所以实际业务需要的绘制区域会更大。 line 截断当富文本超过限制时，通常会看到文本最后有点省略号：text...。YYText 支持自定义后缀，即 truncationToken。 YYTextLine 总是在富文本最后，当 lastLineText 超出绘制范围，通过 CTLineCreateTruncatedLine(...) 创建自动计算的截断 line，会返回一个 CTLineRef，框架将其转化为 YYTextLine 作为 YYTextLayout 的一个属性 truncatedLine。 自定义富文本属性原理是遍历富文本，找到某个 run 是否包含自定义的 key，接着做对应的绘制逻辑。 图文混排的实现前面提到过，如果想要在富文本中添加 UIImage、UIView 之类的附件，需要先设置一个占位符 CTRunDelegateRef，具体看下占位的逻辑。 对齐方式图文混排添加附件有三种对齐方式：居上对齐、居中对齐、局下对齐。通过 ascent、descent、baseline 控制。 居上对齐 run 的 ascent 对齐文本的 ascent。 居下对齐 run 的 descent 对齐文本的 descent。若 run 太矮，则居上对齐文本的 baseline。 居中对齐 居中相对会复杂些，run 的 center 和文本的 center 对齐。 center &#x3D; (ascent + descent) &#x2F; 2 若 run 太矮，则贴着 baseline。 绘制附件绘制逻辑在 YYTextLayout 的 YYTextDrawAttachment(...) 方法中。 若附件为 UIImage，会根据占位 run 的位置和大小，通过 CoreGraphics API 绘制图片： CGImageRef ref = image.CGImage;if (ref) &#123; CGContextSaveGState(context); CGContextTranslateCTM(context, 0, CGRectGetMaxY(rect) + CGRectGetMinY(rect)); CGContextScaleCTM(context, 1, -1); CGContextDrawImage(context, rect, ref); CGContextRestoreGState(context);&#125; 若附件为 UIView、CALayer，需要传入额外的 superView、superLayer。再将绘制的 UIView、CALayer 添加到 superView、superLayer。 点击高亮的实现YYTextHighlight 包含单击和长按的回调、及一些显示的属性配置。 如 YYLabel 中的触发逻辑。先判断点击的 CGPoint 对应的富文本位置，检测文本是否有对应的手势处理。若有对应的 YYTextHighlight 处理，则更换 YYTextLine 为高亮 YYTextLine，重绘。松手时，恢复 YYTextLine。 简而言之，通过检测点击 CGPoint 是否有对应的手势处理，若有替换对应的 YYTextLine，重新绘制。 总结本篇主要是对 YYText 中 CoreText 处理的原理做了梳理，从 CTFrameRef 到 CTLineRef 到 CTRunRef。接着基于 line 和 run 做具体的展开，如： line 的行数确定 line 的换行规则 line 的截断 run 的对齐 富文本附件的添加原理","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"iOS 编译过程梳理","slug":"2019-09-14-ios-analyse-llvm","date":"2019-09-13T16:00:00.000Z","updated":"2021-01-12T10:07:49.261Z","comments":true,"path":"2019/09/14/2019-09-14-ios-analyse-llvm/","link":"","permalink":"https://blog.jonyfang.com/2019/09/14/2019-09-14-ios-analyse-llvm/","excerpt":"iOS 开发常用的语言是 Objective-C 和 Swift，两者都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率很高。本篇主要用于梳理 Objective-C 的编译过程。","text":"iOS 开发常用的语言是 Objective-C 和 Swift，两者都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率很高。本篇主要用于梳理 Objective-C 的编译过程。 编译器的概述编译器的作用是把我们的高级语言转换成机器可以识别的机器码，经典的设计结构如下： 前端（Frontend）：语法分析，语义分析和生成中间代码。在这个过程中，也会对代码进行检查，如果发现出错的或需要警告的会标注出来。 优化器（Optimizer）：会进行 BitCode 的生成，链接期优化等工作。 后端（Backend）：针对不同的架构，生成对应的机器码。 Clang + LLVM 的编译过程接着通过如下一个实际的例子来看下编译的过程。 #import &lt;Foundation/Foundation.h&gt; int main (int argc, const char * argv[])&#123; @autoreleasepool &#123; NSLog(@\"Hello, Obj\"); &#125; return 0;&#125; 命令行执行： clang -ccc-print-phases -framework Foundation main.m -o main 可以看到编译源文件需要的几个阶段为： $ Desktop clang -ccc-print-phases -framework Foundation main.m -o main0: input, \"Foundation\", object1: input, \"main.m\", objective-c2: preprocessor, &#123;1&#125;, objective-c-cpp-output3: compiler, &#123;2&#125;, ir4: backend, &#123;3&#125;, assembler5: assembler, &#123;4&#125;, object6: linker, &#123;0, 5&#125;, image7: bind-arch, \"x86_64\", &#123;6&#125;, image 注释： 2: preprocessor, {1}, objective-c-cpp-output：预处理，编译器前端 3: compiler, {2}, ir：编译生成中间码 ir 4: backend, {3}, assembler：LLVM 后端生成汇编 5: assembler, {4}, object：生成机器码 6: linker, {0, 5}, image：链接器 7: bind-arch, &quot;x86_64&quot;, {6}, image：生成可执行的二进制文件（image） 梳理下流程： 预处理阶段：import 头文件替换；macro 宏展开；处理预编译指令 词法分析：预处理完成后进入词法分析，将输入的代码转化为一系列符合特定语言的词法单元（token 流）。样式如下： $ xcrun -sdk iphonesimulator clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m annot_module_include '#import &lt;Foundation/Foundation.h&gt;' Loc=&lt;main.m:1:1&gt;int 'int' [StartOfLine] Loc=&lt;main.m:3:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;main.m:3:5&gt;l_paren '(' [LeadingSpace] Loc=&lt;main.m:3:10&gt;int 'int' Loc=&lt;main.m:3:11&gt;identifier 'argc' [LeadingSpace] Loc=&lt;main.m:3:15&gt;comma ',' Loc=&lt;main.m:3:19&gt;const 'const' [LeadingSpace] Loc=&lt;main.m:3:21&gt;char 'char' [LeadingSpace] Loc=&lt;main.m:3:27&gt;star '*' [LeadingSpace] Loc=&lt;main.m:3:32&gt;identifier 'argv' [LeadingSpace] Loc=&lt;main.m:3:34&gt;l_square '[' Loc=&lt;main.m:3:38&gt;r_square ']' Loc=&lt;main.m:3:39&gt;r_paren ')' Loc=&lt;main.m:3:40&gt;l_brace '&#123;' [StartOfLine] Loc=&lt;main.m:4:1&gt;at '@' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:5:5&gt;identifier 'autoreleasepool' Loc=&lt;main.m:5:6&gt;l_brace '&#123;' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:6:5&gt;identifier 'NSLog' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:7:9&gt;l_paren '(' Loc=&lt;main.m:7:14&gt;at '@' Loc=&lt;main.m:7:15&gt;string_literal '\"Hello, Obj\"' Loc=&lt;main.m:7:16&gt;r_paren ')' Loc=&lt;main.m:7:28&gt;semi ';' Loc=&lt;main.m:7:29&gt;r_brace '&#125;' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:8:5&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:9:5&gt;numeric_constant '0' [LeadingSpace] Loc=&lt;main.m:9:12&gt;semi ';' Loc=&lt;main.m:9:13&gt;r_brace '&#125;' [StartOfLine] Loc=&lt;main.m:10:1&gt;eof '' Loc=&lt;main.m:10:2&gt; 语法分析：将词法分析得到的 token 流进行语法静态分析（Static Analysis），输出抽象语法树（AST），过程中会校验语法是否错误。 $ xcrun -sdk iphonesimulator clang -fmodules -fsyntax-only -Xclang -ast-dump main.mTranslationUnitDecl 0x7fbdd301ba08 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; &lt;undeserialized declarations&gt;|-TypedefDecl 0x7fbdd301c2a0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t '__int128'| `-BuiltinType 0x7fbdd301bfa0 '__int128'|-TypedefDecl 0x7fbdd301c310 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t 'unsigned __int128'| `-BuiltinType 0x7fbdd301bfc0 'unsigned __int128'|-TypedefDecl 0x7fbdd301c3b0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit SEL 'SEL *'| `-PointerType 0x7fbdd301c370 'SEL *' imported| `-BuiltinType 0x7fbdd301c200 'SEL'|-TypedefDecl 0x7fbdd301c498 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit id 'id'| `-ObjCObjectPointerType 0x7fbdd301c440 'id' imported| `-ObjCObjectType 0x7fbdd301c410 'id' imported|-TypedefDecl 0x7fbdd301c578 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Class 'Class'| `-ObjCObjectPointerType 0x7fbdd301c520 'Class' imported| `-ObjCObjectType 0x7fbdd301c4f0 'Class' imported|-ObjCInterfaceDecl 0x7fbdd301c5d0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Protocol|-TypedefDecl 0x7fbdd301c948 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString 'struct __NSConstantString_tag'| `-RecordType 0x7fbdd301c740 'struct __NSConstantString_tag'| `-Record 0x7fbdd301c6a0 '__NSConstantString_tag'|-TypedefDecl 0x7fbdd3059000 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list 'char *'| `-PointerType 0x7fbdd301c9a0 'char *'| `-BuiltinType 0x7fbdd301baa0 'char'|-TypedefDecl 0x7fbdd30592e8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list 'struct __va_list_tag [1]'| `-ConstantArrayType 0x7fbdd3059290 'struct __va_list_tag [1]' 1| `-RecordType 0x7fbdd30590f0 'struct __va_list_tag'| `-Record 0x7fbdd3059058 '__va_list_tag'|-ImportDecl 0x7fbdd30b4218 &lt;main.m:1:1&gt; col:1 implicit Foundation`-FunctionDecl 0x7fbdd30b44e0 &lt;line:3:1, line:10:1&gt; line:3:5 main 'int (int, const char **)' |-ParmVarDecl 0x7fbdd30b4270 &lt;col:11, col:15&gt; col:15 argc 'int' |-ParmVarDecl 0x7fbdd30b4390 &lt;col:21, col:39&gt; col:34 argv 'const char **':'const char **' `-CompoundStmt 0x7fbdd30c9190 &lt;line:4:1, line:10:1&gt; |-ObjCAutoreleasePoolStmt 0x7fbdd30c9148 &lt;line:5:5, line:8:5&gt; | `-CompoundStmt 0x7fbdd30c9130 &lt;line:6:5, line:8:5&gt; | `-CallExpr 0x7fbdd30c90f0 &lt;line:7:9, col:28&gt; 'void' | |-ImplicitCastExpr 0x7fbdd30c90d8 &lt;col:9&gt; 'void (*)(id, ...)' &lt;FunctionToPointerDecay&gt; | | `-DeclRefExpr 0x7fbdd30c8fb0 &lt;col:9&gt; 'void (id, ...)' Function 0x7fbdd30b4620 'NSLog' 'void (id, ...)' | `-ImplicitCastExpr 0x7fbdd30c9118 &lt;col:15, col:16&gt; 'id':'id' &lt;BitCast&gt; | `-ObjCStringLiteral 0x7fbdd30c9060 &lt;col:15, col:16&gt; 'NSString *' | `-StringLiteral 0x7fbdd30c9038 &lt;col:16&gt; 'char [11]' lvalue \"Hello, Obj\" `-ReturnStmt 0x7fbdd30c9180 &lt;line:9:5, col:12&gt; `-IntegerLiteral 0x7fbdd30c9160 &lt;col:12&gt; 'int' 0 CodeGen 生成 IR 中间代码：CodeGen 负责将语法树自顶向下遍历翻译成 LLVM IR，IR 是编译过程中前端的输出后端的输入。 Optimize 优化 IR：到这里 LLVM 会做一些优化工作，在 Xcode 的编译设置里可以设置优化级别 -01, -03, -0s，也可以写自己的 Pass，Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。附件：官方 Pass 教程。 LLVM Bitcode 生成字节码：如果开启了 bitcode，苹果会做进一步优化。若有新的后端架构，依旧可以用这份优化过的 bitcode 去生成。 生成汇编 生成目标文件 生成可执行文件 我们通过一个命令行操作来复现上述的编译过程： # 词法分析xcrun -sdk iphonesimulator clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m# 语法分析xcrun -sdk iphonesimulator clang -fmodules -fsyntax-only -Xclang -ast-dump main.m# CodeGen 生成 IRxcrun -sdk iphonesimulator clang -S -fobjc-arc -emit-llvm main.m -o main.ll# Optimize 优化 IRxcrun -sdk iphonesimulator clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll# LLVM Bitcodexcrun -sdk iphonesimulator clang -emit-llvm -c main.m -o main.bc# 生成汇编xcrun -sdk iphonesimulator clang -S -fobjc-arc main.m -o main.s# 生成目标文件xcrun -sdk iphonesimulator clang -fmodules -c main.m -o main.o# 生成可执行文件xcrun -sdk iphonesimulator clang main.o -o main# 至此，即生成了可供 iphonesimulator 执行的 `可执行文件` Xcode Build 的流程我们在 Xcode 中使用 Command + B 或 Command + R 时，即完成了一次编译，我们来看下这个过程做了哪些事情。 编译过程分为四个步骤： 预编译（Pre-process）：宏替换、删除注释、展开头文件，产生 .i 文件。 编译（Compliling）：把前面生成的 .i 文件转化为汇编语言，产生 .s 文件。 汇编（Asembly）：把汇编语言 .s 文件转化为机器码文件，产生 .0 文件。 链接（Link）：对 .o 文件中的对于其他库的引用的地方进行引用，生成最后的可执行文件。也包括多个 .o 文件进行 link。 通过解析 Xcode 编译 log，可以发现 Xcode 是根据 Target 进行编译的。我们可以通过 Xcode 中的 Build Phases、Build Settings 及 Build Rules 来控制编译过程。 Build Settings：这一栏下是对编译的细节进行设定，包含 build 过程的每个阶段的设置选项（包含编译、链接、代码签名、打包）。 Build Phases：用于控制从源文件到可执行文件的整个过程，如编译哪些文件，编译过程中执行哪些自定义脚本。例如 CocoaPods 在这里会进行相关配置。 Build Rules：指定了不同的文件类型该如何编译。一般我们不需要修改这里的内容。如果需要对特定类型的文件添加处理方法，可以在这里添加规则。 每个 Target 的具体编译过程也可以通过 log 日志获得。大致过程为： 编译信息写入辅助文件（如Entitlements.plist），创建编译后的文件架构 写入辅助信息（.hmap 文件）。将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件。 运行预设的脚本。如 Cocoapods 会在 Build Phases 中预设一些脚本（CheckPods Manifest.lock）。 编译 .m 文件，生成可执行文件 Mach-O。每次进行了 LLVM 的完整流程：前端（词法分析 - 语法分析 - 生成 IR）、优化器（优化 IR）、后端（生成汇编 - 生成目标文件 - 生成可执行文件）。使用 CompileC 和 clang 命令。 CompileC 是 xcodebuild 内部函数的日志记录表示形式，它是 build.log 文件中有关编译的基本信息来源。 链接需要的库。如 Foundation.framework，AFNetworking.framework… 拷贝资源文件到目标包 编译 storyboard 文件 链接 storyboard 文件 编译 Asset 文件。如果使用 Asset.xcassets 来管理图片，这些图片会被编译为机器码，除了 icon 和 launchIamge。 处理 infoplist 执行 CocoaPods 脚本，将在编译项目前已编译好的依赖库和相关资源拷贝到包中。 拷贝 Swift 标准库 创建 .app 文件并对其签名 dSYM 文件在每次编译完成之后，都会生成一个 dsym 文件。dsym 文件中，存储了 16 进制的函数地址映射。 当 App 执行打包后的二进制文件时，实际是通过地址来调用方法的。我们可能会用三方的统计工具，例如 Fabric 在 App Crash 时会帮我们抓到 crash 时的调用栈，这些调用栈里会包含 crash 地址的调用信息。这时可以通过 dSYM 文件由地址映射到具体的函数位置。 预处理预处理，即在编译前的处理。预处理能够让我们定义编译器变量，实现条件编译。比如我们常会用到下面这样的判断： #ifdef DEBUG//...#else//...#endif 比如我们常会有这样的场景：测版版本使用测试服务器数据，正式版本使用生产服务器数据。我们可以分别为 debug 和 release 设置相关的预处理宏。假设名为 DEVSERVER。 再通过如下代码，就实现了服务器地址的按需切换： #ifdef DEVSERVER// 测试服务器#else// 生产服务器#endif 插入脚本如果我们的项目中使用了 CocoaPods，在 Build Phase 里会看到 [CP] 开头的脚本。这些是 CocoaPods 插入的脚本。 Check Pods Manifest.lock：检查 cocoapod 管理的三方库是否需要更新 Embed Pods Framework：运行脚本来链接三方库的静态/动态库 这些配置信息都存在 .xcodeproj 文件里。CocoaPods 通过修改 .xcodeproj，配置编译期的脚本，以保证三方库正确的编译链接。 这里也有个比较常用的脚本操作。例如，每当我们 Archive 时，通常情况下都需要手动修改 target 的 build 版本，我们可以让这一步实现自动化。 添加方式： Xcode -&gt; Target -&gt; Build Phase -&gt; New Run Script Phase 写入如下脚本代码 勾选 Run script only when installing 重命名脚本为 [ProjectName]Increase build number # 脚本信息buildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;\")buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;\" 这段脚本实现的是：读取当前 plist 的 build 版本号，在其基础上 +1，再写入 plist 文件中。 脚本编译打包对于 CI 来说，脚本编译打包十分有用，一个自动打包的配置可做参考： monetking/AutoPacking-iOS 提高项目 Build 速度随着项目的迭代，源代码及三方库的引入都在持续增加，很明显会发现编译速度变慢。基于之前对编译过程的了解，可以一定程度上优化编译速度。 指标建立首先，编译的快慢我们需要确定一个度量，最直观的表现是编译时间。我们通过在终端输入如下指令： $ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES 完成后重启 Xcode，进行一次编译，编译完成后在顶栏即可看到对应的编译时间。 代码层面的优化前向声明（Forward Declaration）Objective-C 中 #import 和 @class 都可以引入一个类。他们区别是： #import 会包含这个类的所有信息，包括实体变量和方法；而 @class 只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂不考虑。 在头文件中，一般只需要知道被引用的类的名称就可以。 不需要知道其内部的实体变量和方法，所以在头文件中一般使用 @class 来声明这个名称是类的名称。 而在实现类里面使用 #import 来包含这个被引用类的头文件，因为会用到这个引用类的内部的实体变量和方法。 在编译效率方面考虑，如果你有 100 个头文件都 #import 了同一个头文件，或者这些文件是依次引用的，如 A–&gt;B, B–&gt;C, C–&gt;D 这样的引用关系。当最开始的那个头文件有变化时，后面所有引用它的类都需要重新编译，如果类有很多，这将耗费大量的时间。而是用 @class 不会。 如果有循环依赖关系，如：A–&gt;B, B–&gt;A 这样的相互依赖关系，如果使用 #import 来相互包含，那么就会出现编译错误，如果使用 @class 在两个类的头文件中相互声明，则不会有编译错误出现。 所以，一般 @class 是放在 interface 中的，只是为了在 interface 中引用这个类，把这个类作为一个类型来用的。在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要 import 在 @class 中声明的类进来。使用 @class，只能用来定义变量，不能继承，也不能调用该类的方法和变量。使用 #import 则可以进行。 简而言之，是为了编译器能大大提高 #import 的替换速度。 对常用工具类进行打包（Framework/.a）常用的工具类一般不会有改动，我们可以提前将这部分模块打包成 Framework 或静态库。这样编译时这部分代码不需要重新进行编译了。 常用头文件放到预编译文件里Xcode 中 .pch 文件是预编译文件。这里的内容在执行 Xcode Build 之前就已经被预编译，并引入到每一个 .m 文件中。 编译器选项的优化控制 dSYM 文件的生成Debug 模式下，不生成 dSYM 文件。dSYM 文件内存储的是调试信息，在 Debug 模式下，我们可以借助 Xcode 和 LLDB 完成调试，不需要生成额外的 dSYM 文件。这样可以提高一部分的编译速度。 编译器优化Debug 模式下，关闭编译器优化。 Xcode 11 中已默认关闭。 参考内容： Build Rules iOS 编译过程的原理和应用 深入剖析 iOS 编译 Clang / LLVM","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"技术","slug":"技术","permalink":"https://blog.jonyfang.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"编译原理","slug":"编译原理","permalink":"https://blog.jonyfang.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"编译原理","slug":"编译原理","permalink":"https://blog.jonyfang.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"iOS 中 JS 与原生交互","slug":"2019-07-01-ios-js-native","date":"2019-06-30T16:00:00.000Z","updated":"2021-01-12T10:02:50.390Z","comments":true,"path":"2019/07/01/2019-07-01-ios-js-native/","link":"","permalink":"https://blog.jonyfang.com/2019/07/01/2019-07-01-ios-js-native/","excerpt":"本篇用于梳理 WKWebView 中 JS 与原生的交互，及 JavaScriptCore 框架在交互过程中起的作用。","text":"本篇用于梳理 WKWebView 中 JS 与原生的交互，及 JavaScriptCore 框架在交互过程中起的作用。 WKWebView 中 JS 调用 OC核心方法： // 添加 scriptMessageHandler- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;// WKScriptMessageHandler 中对应处理 scriptMessage- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message; 使用示例，在初始化 WKWebView 时，初始化 WKWebViewConfiguration，添加对应的 ScriptMessageHandler。实例代码： WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];configuration.userContentController = [WKUserContentController new];[configuration.userContentController addScriptMessageHandler:self name:@\"btnClick\"];#pragma mark - WKScriptMessageHandler- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; if ([message.name isEqualToString:@\"btnClick\"]) &#123; NSDictionary *jsData = message.body; NSLog(@\"%@\", message.name, jsData); // 读取 js function 的字符串 NSString *jsFunctionString = jsData[@\"result\"]; // 拼接调用该方法的 js 字符串 // convertDictionaryToJson: 方法将 NSDictionary 转成 JSON 格式的字符串 NSString *jsonString = [NSDictionary convertDictionaryToJson:@&#123;@\"test\":@\"123\", @\"data\":@\"321\"&#125;]; NSString *jsCallBack = [NSString stringWithFormat:@\"(%@)(%@);\", jsFunctionString, jsonString]; // 执行回调 [self.weWebView evaluateJavaScript:jsCallBack completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; if (error) &#123; NSLog(@\"err is %@\", error.domain); &#125; &#125;]; &#125;&#125; 注：message 的 body 只能是 NSNumber、NSString、NSDate、NSArray、NSDictionary、NSNull 这几种类型。我们需要在回调环境下，将 js 回调转为 string 后传给原生，执行回调方法。 WKWebView 中 OC 调用 JS核心方法： - (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler; OC 调用 JS： NSString *jsFounction = [NSString stringWithFormat:@\"getAppConfig('%@')\", APP_CHANNEL_ID];[self.weWebView evaluateJavaScript:jsFounction completionHandler:^(id object, NSError * _Nullable error) &#123; NSLog(@\"obj:%@---error:%@\", object, error);&#125;]; JavaScriptCore 框架苹果从 iOS7 开始将 JavaScriptCore 框架引入了 iOS 系统中，成为了系统内置框架，框架名为 JavaScriptCore.framework。 框架结构苹果官方对 JavaScriptCore 框架的说明：JavaScriptCore。 结构上 JavaScriptCore 框架主要分为： JSVirtualMachine JSContext JSValue JSVirtualMachineJSVirtualMachine 为 JavaScript 代码的运行提供的一个虚拟机环境。同一时间内，JSVirtualMachine 只能执行一个线程，若想执行对个线程执行任务，需要创建多个 JSVirtualMachine。每个 JSVirtualMachine 都有自己的 GC（垃圾回收器 Garbage Collector），多个 JSVirtualMachine 之间的对象无法传递。 JSVirtualMachine 是一个抽象的 JavaScript 虚拟机，是提供给开发者开发使用的。它的核心是 JavaScriptCore，JavaScriptCore 引擎是一个真实的虚拟机，包含了虚拟机的解释器和运行时部分。解释器用来将高级脚本语言编译成字节码，运行时用来管理运行时的内存空间。 JSContextJSContext 是 JavaScript 运行环境的上下文，负责原生和 JavaScript 的数据传递。 JSValueJSValue 是 JavaScript 的值对象。用来记录 JavaScript 的原始值，并提供进行原生值对象转换的接口方法。 三者的关系： 入图可以看到，一个 JSVirtualMachine 里包含了多个 JSContext， 同一个 JSContext 中又可以有多个 JSValue。 JSVirtualMachine、JSContext、JSValue 类提供的接口，可以让原生： 执行 JS 代码 访问 JS 变量 访问和执行 JS 函数 也可以让 JS 调用原生方法 那执行 JavaScript 代码的 JavaScriptCore 和原生应用是怎么交互的？ JSCore 与原生的交互 如图可以看到每个 JSVirtualMachine 对应一个原生的线程，JSVirtualMachine 使用 JSValue 与原生线程通信，遵循 JSExport 协议。这样原生线程可以将类方法和属性提供给 JavaScriptCore 使用，JavaScriptCore 也可以将 JSValue 提供给原生线程使用。 当然 JavaScriptCore 与原生的交互，必须有 JSContext。JSContext 若 init 初始化，默认会使用系统创建的 JSVirtualMachine。若想指定 JSVirtualMachine，需要通过 initWithVirtualMachine 来指定： // 创建 JSVirtualMachine 对象 jsvmJSVirtualMachine *jsvm = [[JSVirtualMachine alloc] init];// 使用 jsvm 的 JSContext 对象 ctJSContext *ct = [[JSContext alloc] initWithVirtualMachine:jsvm]; 原生调用 JS再看下 JavaScriptCore 在原生代码中调用 JavaScript 的示例： JSContext *context = [[JSContext alloc] init];// 解析执行 JavaScript 脚本[context evaluateScript:@\"var i = 4 + 8\"];// 转换 i 变量为原生对象NSNumber *number = [context[@\"i\"] toNumber];NSLog(@\"var i is %@, number is %@\", context[@\"i\"], number); 可以看到 JSContext 通过 evaluateScript: 方法返回 JSValue 对象。苹果官方 JSValue 的相关说明。 官方提供了 3 个可以将 JavaScript 对象值类型直接转化为原生类型的接口： toNumber 方法。将 js 值转为 NSNumber 对象 toArray 方法。将 js 值转为 NSArray 对象 toDictionary 方法。如果变量是 object 类型，可以通过 toDictionary 将 js 值转为 NSDictionary 对象 如若想在原生中使用 JS 的函数方法，可以通过 callWithArguments 方法，传入对应参数调用即可。示例代码： // 解析执行 JavaScript 脚本[context evaluateScript:@\"function addition(x, y) &#123; return x + y&#125;\"];// 获得 addition 函数JSValue *addition = context[@\"addition\"];// 传入参数执行 addition 函数JSValue *resultValue = [addition callWithArguments:@[@(4), @(8)]];// 将 addition 函数执行的结果转成原生 NSNumber 来使用。NSLog(@\"function is %@; reslutValue is %@\",addition, [resultValue toNumber]); 简而言之，我们可以通过 evaluateScript 方法，在原生中执行 JS 脚本，并使用 JS 的值对象和函数对象。 那 JavaScript 有如何调用原生的代码？ JS 调用原生// 在 JSContext 中使用原生 Block 设置一个减法 subtraction 函数context[@\"subtraction\"] = ^(int x, int y) &#123; return x - y;&#125;;// 在同一个 JSContext 里用 JavaScript 代码来调用原生 subtraction 函数JSValue *subValue = [context evaluateScript:@\"subtraction(4,8);\"];NSLog(@\"substraction(4,8) is %@\",[subValue toNumber]); 如上代码即完成了一次 JS 对原生的调用。 先在 JSContext 中使用原生 Block 设置一个减法函数 在通过这个 context 用 JavaScript 代码调用原生减法函数 除了使用 Block 的方式，还可以通过 JSExport 协议来实现在 JS 中调用原生代码。即原生代码遵循 JSExport 协议，以提供给 JavaScript 调用。 JSCore 引擎的组成JavaScriptCore 是一个很复杂的模块，更多的放到后面再深：深入剖析 JavaScriptCore 总结 WKWebView 中 JS 调用 OC WKWebView 中 OC 调用 JS JavaScriptCore 框架结构 JSVirtualMachine JSContext JSValue JavaScriptCore 与原生的交互 OC 调用 JS JS 调用 OC","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"}]},{"title":"OSSpinLock 与 os_unfair_lock","slug":"2018-07-11-osspinlock-to-osUnfairLock","date":"2018-07-10T16:00:00.000Z","updated":"2021-01-07T06:39:35.379Z","comments":true,"path":"2018/07/11/2018-07-11-osspinlock-to-osUnfairLock/","link":"","permalink":"https://blog.jonyfang.com/2018/07/11/2018-07-11-osspinlock-to-osUnfairLock/","excerpt":"OSSpinLock 因为线程安全问题已被 Apple 废弃。苹果建议使用 os_unfair_lock 替换，os_unfair_lock 是互斥锁。","text":"OSSpinLock 因为线程安全问题已被 Apple 废弃。苹果建议使用 os_unfair_lock 替换，os_unfair_lock 是互斥锁。 使用示例： #import &lt;os/lock.h&gt;// 声明锁os_unfair_lock _lock;// 初始化锁_lock = OS_UNFAIR_LOCK_INIT;// 加锁os_unfair_lock_lock(&amp;_lock);// 解锁os_unfair_lock_unlock(&amp;_lock); 相关阅读： iOS 中的锁","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"RunLoop 梳理","slug":"2018-06-14-ios-runloop","date":"2018-06-13T16:00:00.000Z","updated":"2021-01-12T09:14:28.482Z","comments":true,"path":"2018/06/14/2018-06-14-ios-runloop/","link":"","permalink":"https://blog.jonyfang.com/2018/06/14/2018-06-14-ios-runloop/","excerpt":"RunLoop 是 iOS 比较的核心之一，本篇用于梳理 RunLoop 相关的概念和底层实现。","text":"RunLoop 是 iOS 比较的核心之一，本篇用于梳理 RunLoop 相关的概念和底层实现。 什么是 RunLoop？对于一个线程，一般情况下一次只执行一个任务，如果任务执行完成线程也会立刻退出。而对于一个 App，我们希望的是，即使 App 内没有任何的任务需要线程去处理了，但不能够让这些线程退出。即不能退出应用。这时就需要一种机制既能让线程能随时处理事件，且在处理完成后不退出。比如主线程，在我们启动应用之后就会一直存在，当有交互发生时，对应去处理相关的事件。RunLoop 就很好了满足了这个需求，它能够在没有收到消息的时候让线程休眠以避免资源浪费，当有消息来时会立刻唤醒线程处理。 这也是我们需要 RunLoop 的原因。 RunLoop 与线程之间的关系苹果不允许直接创建 RunLoop，它提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。CFRunLoop 是基于 pthread 来管理的。 // 全局的 Dictionary，// key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; // 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局 Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; // 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread); if (!loop) &#123; // 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); // 注册一个回调，当线程销毁时，同时销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 可以看到，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。第一次进入时，初始化全局 Dictionary，并先为主线程创建一个 RunLoop，将关系保存在 Dictionary 中。线程结束时销毁 RunLoop。我们只能在一个线程的内部获取其 RunLoop（主线程除外）。 NSRunLoop 和 CFRunLoopRef 的关系NSRunLoop 是基于 CFRunLoopFef 封装。CGRunLoopRef 属于 CoreFoundation 框架，提供的是纯 c 函数的 API，这些 API 是线程安全的。NSRunLoop 提供的是面向对象的 API，这些 API 不是线程安全的。 RunLoop 的内部实现逻辑RunLoop 的内部实现逻辑大致如下： 内部实现逻辑的代码如下： // 用 DefaultMode 启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; // 用指定的 Mode 启动，允许设置 RunLoop 超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; // RunLoop 的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; // 首先根据 modeName 找到对应 mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); // 如果 mode 里没有 source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; // 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); // 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; // 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); // 3. 通知 Observers: RunLoop 即将触发 Source0 (非 port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); // 执行被加入的 block __CFRunLoopDoBlocks(runloop, currentMode); // 4. RunLoop 触发 Source0 (非 port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); // 执行被加入的 block __CFRunLoopDoBlocks(runloop, currentMode); // 5. 如果有 Source1 (基于 port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; // 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; // 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 // • 一个基于 port 的 Source 的事件。 // • 一个 Timer 到时间了 // • RunLoop 自身的超时时间到了 // • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; // 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); // 收到消息，处理消息。 handle_msg: // 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; // 9.2 如果有 dispatch 到 main_queue 的 block，执行 block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; // 9.3 如果一个 Source1 (基于 port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; // 执行加入到 Loop 的 block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; // 进入 loop 时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; // source/timer/observer 一个都没有了 retVal = kCFRunLoopRunFinished; &#125; // 如果没超时，mode 里没空，loop 也没被停止，那继续 loop。 &#125; while (retVal == 0); &#125; // 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; RunLoop 的 Mode开发过程中常遇到的一个场景是，在我们写 NSTimer 时为了避免滑动事件影响 NSTimer 的回调，我们通常会把 mode 置为 NSRunLoopCommonModes。 这里的 NSRunLoopCommonModes 是什么？ 先看下 CFRunLoopMode 和 CFRunLoop 的结构： struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 主线程的 RunLoop 里有两种 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两种 Mode 都被标记为Common属性。App 平常所处的 mode 是 kCFRunLoopDefaultMode；当有滑动事件触发时，RunLoop 会切换 mode 到 UITrackingRunLoopMode。 前面提到创建一个 Timer，默认会被加到 DefaultMode，正常情况下 Timer 会得到重复回调。但如果此时滑动一个 ScrollView，RunLoop 就会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被正常的回调。当然，此时 Timer 也不会影响到滑动操作。 到这里，我们大概知道了 RunLoop 系统预置的 model 有这几种： NSDefaultRunLoopMode(kCFRunLoopDefaultMode)：默认模式 UITrackingRunLoopMode：滑动模式 NSRunLoopCommonModes：通用模式，无论处于滑动或默认状态都能够响应实践 CommonModes一个 Mode 可以通过将其 ModeName 添加到 RunLoop 的 commonModes 中，来将自己设置为 CommonMode。每当 RunLoop 的内容发生变化时，RunLoop 都会将事件同步到 CommonMode 的 mode item，什么是 mode item 后文会讲到。这也解释了为什么 timer 加入到 NSRunLoopCommonModes 中会被正确的回调。 在 NSRunLoop 这一层没有提供操作 Mode 的接口，在 CFRunLoopRef 对外提供了两个操作 Mode 的接口，只有增加 mode 的接口： CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); mode itemstruct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; 在 __CFRunLoopMode 结构体中的 _sources0、_sources1、_observers、_timers 都属于 mode item。结构图如下： Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。 Timer 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 Observer 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 一个 mode item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是无效的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 启动和退出启动这边以 NSRunLoop 为例，CFRunLoopRef 类似， 启动有 3 个方法： run runUntilDate: runMode:beforeDate: run 底层是不断（循环）调用 runMode:beforeDate: 来达到运行目的。runUntilDate: 底层也是调用 runMode:beforeDate: 来运行，和 run 不同的是，在指定的时间也就是 UntilDate 参数到后会停止调用。 退出在系统提供的停止 RunLoop 方法只有 CFRunLoopStop()，CFRunLoopStop() 方法只会结束当前的 RunLoop 调用，而不会结束后续的调用。也就意味着 如果你是用方法一也就是 run 的方式启动 RunLoop，那么这个 RunLoop 不会被退出，因为它会不断的启动，因为 run 底层是不断（循环）调用 runMode:beforeDate: 来达到运行目的。如果你是使用 runUntilDate: 启动的，那么超时结束后会自动终止 RunLoop，如果是 runMode:beforeDate: 那么你可以精确的控制 RunLoop 的停止。 RunLoop 的应用RunLoop 用途广泛，如 AutoreleasePool，PerformSelecter，GCD，AsyncDisplayKit 等都有涉及到。 参考文章： CoreFoundation 源码 深入理解 RunLoop RunLoop","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"底层原理","slug":"底层原理","permalink":"https://blog.jonyfang.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"技术","slug":"技术","permalink":"https://blog.jonyfang.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"底层原理","slug":"底层原理","permalink":"https://blog.jonyfang.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}]},{"title":"AutoreleasePool 实现原理","slug":"2018-06-12-objc-autoreleasePool","date":"2018-06-11T16:00:00.000Z","updated":"2021-01-12T10:08:58.589Z","comments":true,"path":"2018/06/12/2018-06-12-objc-autoreleasePool/","link":"","permalink":"https://blog.jonyfang.com/2018/06/12/2018-06-12-objc-autoreleasePool/","excerpt":"AutoreleasePool（自动释放池）是 OC 中一种内存自动回收的机制。在 MRC 中，可以通过 [obj autorelease] 来延迟内存的释放；而 ARC 中的 autorelease 方法是被禁用的，无法主动调用，但对象的内存任在我们不知情的情况下被很好的管理。这就是依赖于背后的 Autorelease 机制，那么是如何管理的呢？","text":"AutoreleasePool（自动释放池）是 OC 中一种内存自动回收的机制。在 MRC 中，可以通过 [obj autorelease] 来延迟内存的释放；而 ARC 中的 autorelease 方法是被禁用的，无法主动调用，但对象的内存任在我们不知情的情况下被很好的管理。这就是依赖于背后的 Autorelease 机制，那么是如何管理的呢？ AutoreleasePool在 main.m 中我们会看到下面这段代码： int main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; @autoreleasepool &#123; // Setup code that might create autoreleased objects goes here. appDelegateClassName = NSStringFromClass([AppDelegate class]); &#125; return UIApplicationMain(argc, argv, nil, appDelegateClassName);&#125; 我们通过编译： xcrun -sdk iphonesimulator clang -rewrite-objc main.m 得到如下编译后的代码： int main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; appDelegateClassName = NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\"))); &#125; return UIApplicationMain(argc, argv, __null, appDelegateClassName);&#125; 看到 @aotoreleasepool 被编译器转换成了 __AtAutoreleasePool __autoreleasepool。查找得到 __AtAutoreleasePool 对应的结构如下： struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 结构体内实际上是两个 objc 方法：objc_autoreleasePoolPush() 和 objc_autoreleasePoolPop()。 打开 objc 源码 - DeveloperErenLiu/RuntimeAnalyze/objc4-750，对应查找到它们在 NSObject.mm 的实际实现： void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;voidobjc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125; 这两个函数实际上都是对 AutoreleasePoolPage 的封装。所以自动释放机制的核心也在这个类。 AutoreleasePoolPageAutoreleasePoolPage 的结构图如下： 我们会注意到两个字段：child 和 parent。AutoreleasePool 是由若干 AutoreleasePoolPage 以双向链表的形式组合而成。 需要注意的几个点： 每个 AutoreleasePoolPage 对象会开启 4096字节（4kb）内存（4kb 对齐的原因，虚拟内存每个扇区 4096 字节）。 depth 表示链表深度，即节点个数。 id *next 指针作为游标指向当前页栈顶（即最新加入的 autorelease 对象的下一个位置）。 单个 AutoreleasePoolpage 的结构如下： objc_autoreleasePoolPush()每个 AutoreleasePoolPage 对象会开启 4096字节（4kb）内存，除了自身实例变量所占空间，剩下的空间全部拿来存储 autorelease 对象的地址。 每当进行一次 objc_autoreleasePoolPush 调用时，runtime 都会向当前的 AutoreleasePoolPage 中添加一个哨兵对象，值为 nil， 哨兵对象的定义为： # define POOL_BOUNDARY nil 注：图中的 obj1、obj2 表示 AutoreleasePoolPage 自身除了 autorelease 对象的实例。 到这里会有个疑问：为什么需要插入一个哨兵对象？放到后面解释。 添加完哨兵对象后，将 next 指针指向下一个添加 Autorelease 对象的位置。当当前 AutoreleasePoolPage 满了，开启一个新的 AutoreleasePoolPage，并更新 child 和 parent 指针，以组成双向链表。 objc_autoreleasePoolPop()objc_autoreleasePoolPush 会有个返回值，这个返回值正是前面提到的哨兵对象。objc_autoreleasePoolPop() 调用时会把哨兵对象作为入参。之后根据传入的哨兵对象地址找到哨兵对象对应的 AutoreleasePoolPage；在当前 page 中，对所有晚于哨兵对象插入的 Autorelease 对象发送 release 消息，到哨兵对象后，销毁当前 page；再根据 parent 向前继续进行 pop，知道第一个哨兵对象所在 page 释放完成。 关于 AutoreleasePool 的几个问题AutoreleasePool 是怎么释放的？第一种是 main.m 里的 AutoreleasePool。 App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 第二种是手动创建的局部 AutoreleasePool。 根据当前 loop 的情况，进行创建和释放。 什么对象会加入 autoreleasePool? alloc/new/copy/mutableCopy等持有对象的方法，不会加入 autoreleasePool；其他不持有对象的方法通过 objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue 来判断是否需要加入 autoreleasePool，这是编译器的优化。 // 自己生成并持有对象，不需要加入 autoreleasePoolid object = [[NSObject alloc] init]; // MRC：不是自己生成并且不持有对象，需要加入autoreleasePoolid object2 = [NSMutableArray array];// MRC：不是自己生成，但持有对象，不需要加入autoreleasePoolid object3 = [NSMutableArray array];[object3 retain]; iOS5 及之前的编译器，关键字 __weak 修饰的对象，会自动加入 autoreleasePool；iOS5 及之后的编译器，则直接调用的 release，不会加入 autoreleasePool。 id 指针(id *)和对象指针（NSError **），会自动加上关键字 __autorealeasing，加入 autoreleasePool。 子线程中使用 autorelease 对象会内存泄漏吗？子线程的 runloop 默认是不开启的，如果产生了 Autorelease 对象，会调用 autoreleaseNoPage 方法。这个方法里会自动创建一个 hotpage，默认生成一个 AutoreleasePoolPage 来添加 autorelease 对象。 参考内容： 黑幕背后的 Autorelease","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"weak 源码分析","slug":"2018-06-10-objc-weak","date":"2018-06-09T16:00:00.000Z","updated":"2021-01-12T10:07:26.275Z","comments":true,"path":"2018/06/10/2018-06-10-objc-weak/","link":"","permalink":"https://blog.jonyfang.com/2018/06/10/2018-06-10-objc-weak/","excerpt":"iOS 内是通过引用计数来管理内存，引用计数的管理，很容易会出现“循环引用”问题。weak 修饰符，也是开发日常最常用的打破循环引用方式。被 weak 修饰符修饰的弱引用除了不会增加对象的引用计数外；在引用对象被释放后，这个弱引用会自动失效并置为 nil。本篇总结分析下 Objective-C 中 weak 都是怎么实现的。 分析源码基于：DeveloperErenLiu/RuntimeAnalyze/objc4-799.1。","text":"iOS 内是通过引用计数来管理内存，引用计数的管理，很容易会出现“循环引用”问题。weak 修饰符，也是开发日常最常用的打破循环引用方式。被 weak 修饰符修饰的弱引用除了不会增加对象的引用计数外；在引用对象被释放后，这个弱引用会自动失效并置为 nil。本篇总结分析下 Objective-C 中 weak 都是怎么实现的。 分析源码基于：DeveloperErenLiu/RuntimeAnalyze/objc4-799.1。 objc_initWeak()在入口文件 KCObjcTest/main.m 中写入如下代码： int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *obj = [[NSObject alloc] init]; __weak id weakObj = obj; &#125; return 0;&#125; 单步运行后，进入了 NSObject.mm 中的 objc_initWeak() 方法。在 runtime 源码中的实现如下： id objc_initWeak(id *location, id newObj)&#123; // 查看对象是否有效 // 无效对象立刻置空指针 if (!newObj) &#123; *location = nil; return nil; &#125; return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);&#125; 从源码中可以看到 objc_initWeak() 内部最后会调用storeWeak() 方法，传入了三个模板参数，自己理解的这段代码的意思是： 该弱引用不存在已有指向的对象（DontHaveOld），同时需要指向新的对象（DoHaveNew），如果目标对象正在释放就崩溃处理（DoCrashIfDeallocating）。 到了 storeWeak() 这一步，看下它的内部实现。 storeWeak()storeWeak() 在 runtime 源码中的实现如下： // 这里传递了三个 bool 数值// 使用 template 进行常量参数传递是为了优化性能/** HaveOld: - true：变量有值 - false：需要被及时清理，当前值可能为 nil HaveNew： - true：需要被分配的新值，当前值可能为 nil - false：不需要分配新值 CrashIfDeallocating: - true：newObj 已经释放或 newObj 不支持弱引用，该过程需要暂停 - false：用 nil 代替存储*/enum HaveOld &#123; DontHaveOld = false, DoHaveOld = true &#125;;enum HaveNew &#123; DontHaveNew = false, DoHaveNew = true &#125;;enum CrashIfDeallocating &#123; DontCrashIfDeallocating = false, DoCrashIfDeallocating = true&#125;;template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123; ASSERT(haveOld || haveNew); if (!haveNew) ASSERT(newObj == nil); // 初始化 previouslyInitializedClass 指针 // 用于标记已经初始化的类 Class previouslyInitializedClass = nil; id oldObj; // 声明新旧 SideTable SideTable *oldTable; SideTable *newTable; // 获得新值和旧值（若存在）辅助表的锁 // 如果新旧值辅助表同时存在时，以锁的地址大小排序，防止锁的顺序问题 // 若旧值在下面改变了，则重试 retry: if (haveOld) &#123; // 若有旧值，通过指针获取目标对象 // 再以目标对象的地址为索引，取得旧值对应的辅助表 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (haveNew) &#123; // 若有新值，以新值的地址为索引，取得新值对应的辅助表 newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 加锁操作，防止多线程中数据竞争 SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); // 线程冲突处理 // 若有旧值，但 location 指向的对象地址不为 oldObj，那很可能被其它线程修改过 // 解锁并重试 if (haveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; &#125; // 确保新值的 isa 已经调用 +initialize 初始化 // 避免弱引用机制和 +initialize 机制间的死锁 if (haveNew &amp;&amp; newObj) &#123; // 获取新值的 isa Class cls = newObj-&gt;getIsa(); // 若 newObj isa 与 previouslyInitializedClass 不同， // 且 newObj 未被初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; // 解锁 SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); // 初始化 newObj class_initialize(cls, (id)newObj); // 若 newObj 已经完成执行 +initialize，这是最理想情况 // 若这个 newObj 正在当前线程运行 +initialize // 如在 +initialize 方法里对自己的实例调用了 storeWeak // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记 previouslyInitializedClass = cls; goto retry; &#125; &#125; // 清理旧值 if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // 设置新值 if (haveNew) &#123; // 把弱引用地址注册到 newObj 的弱引用条目 newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // 如果 weakStore 操作应该被拒绝，weak_register_no_lock 会返回 nil // 否则，对被引用对象设置弱引用标记位（is-weakly-referenced bit） if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; // 之前不要设置 *location，这里需要更改指针指向 *location = (id)newObj; &#125; else &#123; // 无新值，则不更改 &#125; // 解锁，让其他线程可以访问 oldTable, newTable SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 上述代码可以看到，方法中核心的两个方法：weak_unregister_no_lock 和 weak_register_no_lock。他们都是对 SideTable 的实例进行操作。实际上 SideTable 也是作为全局对象用于管理所有对象的引用计数和 weak 表，在 runtime 启动时和主线程的 AutoreleasePool 一起创建。 接着来看下 SideTable。 SideTable在 NSObject.mm 文件中 SideTable 结构体的源码为： struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; // ...&#125; 可以看到 SideTable 结构体主要的三个部分： spinlock_t slock： 用于原子操作的自旋锁，用于给 SideTable 上锁和解锁 RefcountMap refcnts： 引用计数的 hash 表。仅在未开启 isa 优化或在 isa 优化开启且 isa_t 的引用计数溢出时才会用到。 weak_table_t weak_table： 弱引用指针的 hash 表。OC 中 weak 功能实现的核心数据结构。 前面的 storeWeak() 里，runtime 是通过如下方式获取对象的 SideTable： oldTable = &amp;SideTables()[oldObj]; 先看下 SideTables() 的源码实现： class ExplicitInit &#123; alignas(Type) uint8_t _storage[sizeof(Type)];public: template &lt;typename... Ts&gt; void init(Ts &amp;&amp;... Args) &#123; new (_storage) Type(std::forward&lt;Ts&gt;(Args)...); &#125; Type &amp;get() &#123; // reinterpret_cast 是 C++ 标准转换运算符 // 用来处理无关类型之间的转换，它会产生一个新的值 // 这个值会有与原始参数（_storage）有完全相同的比特位 return *reinterpret_cast&lt;Type *&gt;(_storage); &#125;&#125;;static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return SideTablesMap.get();&#125; 看到 SideTables() 返回的是一个 StripedMap 哈希表，以对象的地址作为键值返回对应的 SideTable。 StripedMapStripedMap 是一个模板类，定义于 objc-private.h 文件中，提供了一个以地址为键值的哈希结构。 template&lt;typename T&gt;class StripedMap &#123;#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR enum &#123; StripeCount = 8 &#125;;#else enum &#123; StripeCount = 64 &#125;;#endif // ... static unsigned int indexForPointer(const void *p) &#123; uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); // 哈希操作 return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; &#125; public: T&amp; operator[] (const void *p) &#123; return array[indexForPointer(p)].value; &#125; const T&amp; operator[] (const void *p) const &#123; return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p]; &#125; // ... StripedMap 重定义了数组运算符，传入对象的地址，通过哈希运算获得对应内容。在 runtime 初始化后，会根据系统的不同，对应生成 8 或 64 个 SideTable 留作以后使用。 SideTable 里与弱引用有直接关系的是 weak 表。weak 表通过哈希表实现，将目标对象的地址作为键值进行检索以获得对应的弱引用变量地址。由于一个对象可同时赋值给多个弱引用变量，所以对于一个键值，可以注册多个弱引用变量的地址。 接着看下 weak_table 的实现。 weak_table在 objc-weak.h 文件中 weak_table_t 的源码为： struct weak_table_t &#123; // 弱引用条目列表 weak_entry_t *weak_entries; // 弱引用条目的数量 size_t num_entries; // 弱引用条目列表的大小 uintptr_t mask; // 最大哈希偏移量 uintptr_t max_hash_displacement;&#125;; 结构体中的 weak_entries 是一个动态列表，用来存储 weak_entry_t 类型的元素，需要对应到具体的内容。所以当出现冲突时还需要再处理，max_hash_displacement 就是用于出现冲突后辅助检查检索的内容是否存在。 那 weak_entry_t 的结构又是怎样的？ weak_entry_t在 objc-weak.h 文件中 weak_entry_t 的源码为： #define WEAK_INLINE_COUNT 4#define REFERRERS_OUT_OF_LINE 2struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;; bool out_of_line() &#123; return (out_of_line_ness == REFERRERS_OUT_OF_LINE); &#125; weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123; memcpy(this, &amp;other, sizeof(other)); return *this; &#125; weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) &#123; inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; inline_referrers[i] = nil; &#125; &#125;&#125;; 在 weak_entry_t 的结构中，目标对象和弱引用变量的指针都被封装在 DisguisedPtr 里。 同时用到了联合体，在联合体的内部有定长数组 inline_referrers[WEAK_INLINE_COUNT] 和动态数组 weak_referrer_t *referrers 两种方式来存储弱引用对象的指针地址。通过 out_of_line() 方法来判断采用哪种存储方式。当弱引用该对象的指针数目小于等于 WEAK_INLINE_COUNT 时，使用定长数组。当超过 WEAK_INLINE_COUNT 时，会将定长数组中的元素转移到动态数组中，且之后都是用动态数组存储。 结合前面可以知道：弱引用表的结构是一个哈希表，key 是所指对象的地址，value 是 weak 指针的地址（它的值是所指对象的地址）数组。 那么弱引用表是怎么维护这些数据的？ weak_register_no_lock()在 objc-weak.mm 文件中 weak_register_no_lock 方法的源码为： /** * 在弱引用表中查找对应的 weak_entry * 若找到，则向其中插入 weak 指针地址 * 若未找到，新建一个 weak_entry * * @param weak_table 全局弱引用表，类型为 weak_table_t * @param referent_id 弱指针 * @param referrer_id 弱指针地址 * @patam crashIfDeallocating 若被弱引用的对象正在析构，再次弱引用该对象是否 crash */id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; // 如果 referent 为 nil // 或 referent 是 TaggedPointer 计数方式，直接返回，不做任何操作 if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // 确保被引用的对象可用（不在析构，且支持 weak 引用） bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, @selector(allowsWeakReference)); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, @selector(allowsWeakReference)); &#125; // 正在析构的对象，不能够被弱引用 if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // 在 weak_table 中找到 referent 对应的 weak_entry // 将 referrer 插入到 weak_entry_t 的引用数组中 weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; // 若未找到，新建一个 weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; 根据代码过一下 weak_register_no_lock() 的内部实现。 首先判断 referent 是否为 nil 或 referent 是否用了 TaggedPointer 计数方式，如果是，直接返回不做任何操作。 再判断对象是否在析构，若是，根据 crashIfDeallocating 判断是否抛出异常 如果对象不能被 weak 引用，直接返回 nil 当对象没有在析构且可以被 weak 引用，则调用 weak_entry_for_referent 方法根据 weak 指针从 weak_table 中查找对应的 weak_entry。如果找到，则调用 append_referrer方法，向 weak_entry 中插入 weak 指针地址 referrer；反之，新建一个 weak_entry。 weak_entry_for_referent（）weak_entry_for_referent 方法主要是通过 weak 指针 referent 在 weak_table 查找对应的 weak_entry_t。在 objc-weak.mm 文件中 weak_entry_for_referent 方法的源码为： /** * Return the weak reference table entry for the given referent. * If there is no entry for referent, return NULL. * Performs a lookup. * * @param weak_table 弱引用表 * @param referent 弱指针，非 nil * * @return 返回查找到的 weak_entry_t */static weak_entry_t *weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)&#123; ASSERT(referent); weak_entry_t *weak_entries = weak_table-&gt;weak_entries; if (!weak_entries) return nil; // 通过 &amp; weak_table-&gt;mask 位操作，确保 index 不会越界 size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask; size_t index = begin; size_t hash_displacement = 0; while (weak_table-&gt;weak_entries[index].referent != referent) &#123; index = (index+1) &amp; weak_table-&gt;mask; // 触发 bad weak table crash if (index == begin) bad_weak_table(weak_table-&gt;weak_entries); hash_displacement++; // 当 hash_displacement(偏移量) 超过了 max_hash_displacement // 说明元素不在 hash 表中，返回 nil if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123; return nil; &#125; &#125; return &amp;weak_table-&gt;weak_entries[index];&#125; append_referrer（）在 objc-weak.mm 文件中 append_referrer 方法的源码为： /** * Add the given referrer to set of weak pointers in this entry. * Does not perform duplicate checking (b/c weak pointers are never * added to a set twice). * * @param entry The entry holding the set of weak pointers. * @param new_referrer The new weak pointer to be added. */static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)&#123; // 判断 weak_entry 是否使用动态数组 if (! entry-&gt;out_of_line()) &#123; // 插入 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125; &#125; // 若未插入，代表静态数组已存满 // 转换为动态数组 weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // 将原静态数组中的项存储入动态数组 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[i]; &#125; entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; &#125; ASSERT(entry-&gt;out_of_line()); // 如果动态数组中元素数 &gt;= 数组总空间的3/4，则扩展数组空间为当前长度的一倍 // 扩容完成，插入 if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123; return grow_refs_and_insert(entry, new_referrer); &#125; // 如果不需要扩容，直接插入 // '&amp; (entry-&gt;mask)' 确保 begin 的位置只能大于或等于 mask (弱引用表大小) size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t index = begin; // 用于记录 hash 偏移量 size_t hash_displacement = 0; while (entry-&gt;referrers[index] != nil) &#123; hash_displacement++; index = (index+1) &amp; entry-&gt;mask; if (index == begin) bad_weak_table(entry); &#125; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement; &#125; // 存入并更新 num_refs weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;&#125; weak_unregister_no_lock()若 weak 指针之前指向了弱引用，则会调用 weak_unregister_no_lock 方法将旧的 weak 指针地址移除。在 objc-weak.mm 文件中 weak_unregister_no_lock 方法的源码为： /** * Unregister an already-registered weak reference. * This is used when referrer's storage is about to go away, but referent * isn't dead yet. (Otherwise, zeroing referrer later would be a * bad memory access.) * Does nothing if referent/referrer is not a currently active weak reference. * Does not zero referrer. * * FIXME currently requires old referent value to be passed in (lame) * FIXME unregistration should be automatic if referrer is collected * * @param weak_table The global weak table. * @param referent The object. * @param referrer The weak reference. */voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; // 查找到 referent 所对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; // 移除 referrer remove_referrer(entry, referrer); // 移除后，要检查一下 weak_entry_t 的 hash 数组是否已经空了 bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125; // 如果 weak_entry_t 的 hash 数组为空 // 则需要将 weak_entry_t 从 weak_table 中移除 if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; 上述即为对一个对象做弱引用时底层所做的处理。通过弱引用对象，不会使其引用计数加一。那当对象释放时，所有弱引用该对象的指针有时如何自动置为 nil 的？ dealloc当对象的引用计数为 0 时，该对象会进行释放，对应的源码如下： - (void)dealloc &#123; _objc_rootDealloc(self);&#125;void_objc_rootDealloc(id obj)&#123; ASSERT(obj); obj-&gt;rootDealloc();&#125;inline voidobjc_object::rootDealloc()&#123; // 判断对象是否为 TaggedPointer，是则直接 return if (isTaggedPointer()) return; // fixme necessary? // 如果对象是采用了优化的 isa 计数方式 // 且 对象没有被弱引用 !isa.weakly_referenced // 且 没有关联对象 !isa.has_assoc // 且 没有自定义的 C++ 析构方法 !isa.has_cxx_dtor // 且 没有用到 SideTable 来引用计数 !isa.has_sidetable_rc // =&gt; 则直接释放 if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) &#123; assert(!sidetable_present()); free(this); &#125; else &#123; object_dispose((id)this); &#125;&#125; 可以看到底层调用了 rootDealloc 方法。 object_dispose()在 objc-runtime-new.mm 文件中 object_dispose 方法的源码为： /************************************************************************ object_dispose* fixme* Locking: none**********************************************************************/id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125;/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory. * Calls C++ destructors.* Calls ARC ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.**********************************************************************/void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // 如果有自定义的 C++ 析构方法，则调用 C++ 析构函数 if (cxx) object_cxxDestruct(obj); // 如果有关联对象则移除关联对象 // 并将其自身从 Association Manager 的 map 中移除 if (assoc) _object_remove_assocations(obj); // 清除对象的相关引用 obj-&gt;clearDeallocating(); &#125; return obj;&#125; clearDeallocating()在 objc-object.h 文件中 clearDeallocating 方法的源码为： inline void objc_object::clearDeallocating()&#123; // 判断对象是否采用了优化 isa 引用计数 if (slowpath(!isa.nonpointer)) &#123; // 没有，则清理对象存储在 SideTable 中的引用计数数据 sidetable_clearDeallocating(); &#125; // 当采用了优化 isa 引用计数，则判断 // 是否使用了 SideTable 的辅助引用计数 (isa.has_sidetable_rc) // 或是否有 weak 引用 (isa.weakly_referenced) else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125; clearDeallocating_slow()// Slow path of clearDeallocating() // for objects with nonpointer isa// that were ever weakly referenced // or whose retain count ever overflowed to the side table.NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; ASSERT(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); // 在全局的 SideTables 中，通过 this 指针为key，找到对应的 SideTable SideTable&amp; table = SideTables()[this]; table.lock(); // 如果 obj 被弱引用 // 在 SideTable 的 weak_table 中对 this 进行清理工作 if (isa.weakly_referenced) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; // 如果采用了 SideTable 做引用计数 // 在 SideTable 的引用计数中移除 this if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock();&#125; weak_clear_no_lock()/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; // 找出弱引用 referent 的弱指针地址数组以及数组长度 if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; // 去除每一项对比置 nil 或报错 objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; // 由于 referent 要被释放了 // 因此 referent 的 weak_entry_t 也要移除出 weak_table weak_entry_remove(weak_table, entry);&#125; 总结weak 的实现原理在于底层维护了一份 weak_table_t 结构的哈希表，key 为所指对象的地址，value 为 weak 指针的地址数组。weak 关键字修饰的对象，代表弱引用，所引用对象的引用计数不会 +1，在引用对象被释放时会自动置为 nil。 对象释放的过程中，通过底层触发 clearDeallocating 函数方法，根据被释放对象地址通过查找获取得到所有 weak 指针地址的数组，之后逐个遍历将它们置为 nil，最后把相关的 entry 从 weak 表移除，最后清理对象的记录。 弱引用的核心部分有：SideTable、weak_table_t、weak_entry_t。关系图如下： 参考内容： weak 弱引用的实现方式 weak 引用的底层实现原理","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"}]},{"title":"记一次 clang 编译错误的解决","slug":"2018-05-03-clang-fatal-error","date":"2018-05-02T16:00:00.000Z","updated":"2021-01-07T06:39:35.378Z","comments":true,"path":"2018/05/03/2018-05-03-clang-fatal-error/","link":"","permalink":"https://blog.jonyfang.com/2018/05/03/2018-05-03-clang-fatal-error/","excerpt":"记录 clang 编译错误的解决。 $ clang -rewrite-objc main.m","text":"记录 clang 编译错误的解决。 $ clang -rewrite-objc main.m 错误信息： main.m:9:9: fatal error: 'UIKit/UIKit.h' file not found#import &lt;UIKit/UIKit.h&gt; ^~~~~~~~~~~~~~~1 error generated. 替换方法： $ $ clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m$ xcrun -sdk iphonesimulator clang -rewrite-objc main.m$ xcrun -sdk iphoneos clang -rewrite-objc main.m$ xcrun -sdk iphonesimulator13.0 clang -rewrite-objc main.m note warning TODO：错误的原因，后续再查找定位。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"开发报错","slug":"开发报错","permalink":"https://blog.jonyfang.com/categories/%E5%BC%80%E5%8F%91%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"开发报错","slug":"开发报错","permalink":"https://blog.jonyfang.com/tags/%E5%BC%80%E5%8F%91%E6%8A%A5%E9%94%99/"}]},{"title":"NSHashTable 和 NSMapTable","slug":"2017-10-03-nshashtable-and-nsmaptable","date":"2017-10-02T16:00:00.000Z","updated":"2021-01-07T06:39:35.378Z","comments":true,"path":"2017/10/03/2017-10-03-nshashtable-and-nsmaptable/","link":"","permalink":"https://blog.jonyfang.com/2017/10/03/2017-10-03-nshashtable-and-nsmaptable/","excerpt":"NSSet，NSDictionary，NSArray 是 Foundation 框架关于集合操作的常用类。在 NSSet 中，objects 是被强引用的（strongly referenced），同样 NSDictionary 中的 keys 和 values 也会被 NSDictionary 复制。如果我们想要存储一个 weak 类型的值或者使用一个没有实现 NSCopying 协议的 object 作为 NSDictionary 的 key，就可以分别使用和 NSSet，NSDictionary 地位相同的 NSHashTable，NSMapTable。","text":"NSSet，NSDictionary，NSArray 是 Foundation 框架关于集合操作的常用类。在 NSSet 中，objects 是被强引用的（strongly referenced），同样 NSDictionary 中的 keys 和 values 也会被 NSDictionary 复制。如果我们想要存储一个 weak 类型的值或者使用一个没有实现 NSCopying 协议的 object 作为 NSDictionary 的 key，就可以分别使用和 NSSet，NSDictionary 地位相同的 NSHashTable，NSMapTable。 NSHashTableNSHashTable 是更广泛意义的 NSSet，NSHashTable 相比 NSSet/NSMutableSet 有如下特性： NSHashTable 是可变的 NSHashTable 可以持有 weak 类型的成员变量 NSHashTable 可以在添加成员变量是复制成员 NSHashTable 可以随意存储指针并利用指针的唯一性来进行 hash 查重和对比（equal）操作 用法示例： NSHashTable *hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsCopyIn];[hashTable addObject:@\"a\"];[hashTable addObject:@\"b\"]; [hashTable addObject:@11];[hashTable removeObject:@\"b\"];NSLog(@\"Items: %@\", [hashTable allObjects]); NSHashTable 是根据一个 option 参数来进行初始化，option 可选项有： NSHashTableStrongMemory：对成员变量进行强引用，这是一个默认值，如果采用这个默认值，NSHashTable 和 NSSet 就没有了区别。 NSHashTableWeakMemory：对成员变量进行弱引用，object 引用在最后释放的时候会被指向 NULL。 NSHashTableCopyIn：在对象被加入集合之前进行复制。 NSHashTableObjectPointerPersonality：用指针来等同代替实际的值，当打印这个指针的时候相当于调用 description 方法。 NSHashTableZeroingWeakMemory：已被抛弃，使用 NSHashTableWeakMemory 代替。 NSMapTableNSDictionary/NSMutableDictionary 会复制 keys 并通过强引用 values 来实现存储。NSMapTable 是更广泛意义的 NSDictionary。NSMapTable 相比 NSDictionary/NSMutableDictionary 有如下特性： NSMapTable 是可变的。 NSMapTable 可以通过弱引用来持有 keys 和 values。当 key 或 value 被 deallocated 时，对应存储的内容也会被移除。 NSMapTable 可以在添加 value 的时候对 value 进行复制。 NSMapTable 和 NSHashTable 类似，可以随意的存储指针，并利用指针的唯一性来进行 hash 查重。 应用假设用 NSMapTable 来存储不用被复制的 keys 和被若引用的 value，这里的 value 就可以是某个 delegate 或者一种弱类型。 id delegate = ...;NSMapTable *mapTable = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory];[mapTable setObject:delegate forKey:@\"foo\"];NSLog(@\"Keys: %@\", [[mapTable keyEnumerator] allObjects]); 总结日常开发过程中 NSSet 和 NSDictionary 可以解决我们的大多数需求，如果有内存相关处理问题时，可以借助于 NSHashTable 和 NSMapTable。 参考内容： NSHash​Table &amp; NSMap​Table","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"}]},{"title":"YYCache 源码梳理","slug":"2017-10-01-yycache","date":"2017-09-30T16:00:00.000Z","updated":"2021-01-12T09:17:05.370Z","comments":true,"path":"2017/10/01/2017-10-01-yycache/","link":"","permalink":"https://blog.jonyfang.com/2017/10/01/2017-10-01-yycache/","excerpt":"本篇是对 YYCache 源码阅读过程中的梳理。YYCache 是一个线程安全的高性能 Key-Value 缓存框架。代码质量很高，值得拿来学习。","text":"本篇是对 YYCache 源码阅读过程中的梳理。YYCache 是一个线程安全的高性能 Key-Value 缓存框架。代码质量很高，值得拿来学习。 YYCache 的框架结构 如上是 YYCache 的框架结构图，本篇按照下面的分类来进行梳理： YYCache YYMemoryCache YYDiskCache NSMapTable 如何保证的线程安全 YYCacheYYCache.h 做一个简化： @interface YYCache : NSObject@property (copy, readonly) NSString *name; //缓存名@property (strong, readonly) YYMemoryCache *memoryCache;@property (strong, readonly) YYDiskCache *diskCache;//- (BOOL)containsObjectForKey:(NSString *)key;- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block;//- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block;//- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block;//- (void)removeObjectForKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;//- (void)removeAllObjects;- (void)removeAllObjectsWithBlock:(void(^)(void))block;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;@end 接口内容包含了缓存框架所需要的增删改查，函数的命名很清晰，不一一注释了。 接口实现从接口文件可以看到，YYCache 内的增删改查都提供了有无 Block 回调的两种方式。以有 Block 回调来看下，增删改查的实现。 - (void)containsObjectForKey:(NSString *)key withBlock:(void (^)(NSString *key, BOOL contains))block &#123; if (!block) return; if ([_memoryCache containsObjectForKey:key]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; block(key, YES); &#125;); &#125; else &#123; [_diskCache containsObjectForKey:key withBlock:block]; &#125;&#125;- (void)objectForKey:(NSString *)key withBlock:(void (^)(NSString *key, id&lt;NSCoding&gt; object))block &#123; if (!block) return; id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; if (object) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; block(key, object); &#125;); &#125; else &#123; [_diskCache objectForKey:key withBlock:^(NSString *key, id&lt;NSCoding&gt; object) &#123; if (object &amp;&amp; ![_memoryCache objectForKey:key]) &#123; [_memoryCache setObject:object forKey:key]; &#125; block(key, object); &#125;]; &#125;&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(void (^)(void))block &#123; [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key withBlock:block];&#125;- (void)removeObjectForKey:(NSString *)key withBlock:(void (^)(NSString *key))block &#123; [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key withBlock:block];&#125;- (void)removeAllObjectsWithBlock:(void(^)(void))block &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjectsWithBlock:block];&#125;- (void)removeAllObjectsWithProgressBlock:(void(^)(int removedCount, int totalCount))progress endBlock:(void(^)(BOOL error))end &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjectsWithProgressBlock:progress endBlock:end]; &#125; 如上实现可以看到： YYCache 每次的增删改查操作都是优先操作_memoryCache，再操作_diskCache。 关于回调： -containsObjectForKey:withBlock: 与 -objectForKey:withBlock: 优先以 _memoryCache 的返回数据回调。 其他方法，以 _diskCache 的回调为准。 到这里我们已经知道，YYCache 有哪些对数据项的操作接口；也可以看出在 YYCache 这一层实际上并没有自身去处理数据，而是借助于 _memoryCache 和 _diskCache。 依次来看下他们是如何操作数据的。 LRU前面提到 YYCache 对数据的操作借助于 _memoryCache 和 _diskCache。这里延伸出一个问题：为什么缓存设计框架，需要同时存在内存缓存和磁盘缓存呢？ 对于数据有个命中率的概念。所谓命中率，即： 命中率 &#x3D; 命中数 &#x2F; (命中数 + 未命中数) 命中率是判断一个缓存框架加速效果好坏的重要标准之一。对于缓存框架为什么分内存缓存与磁盘缓存，自己的理解是，命中数代表拿到了数据，未命中数据代表没拿到数据；而拿到数据的过程也分快和满，我们知道的是读取内存缓存会比磁盘缓存快很多。借助于这一点，在保证数据命中率的前提下，如果能够尽量使用内存缓存进行操作，是一个很好的提速方案。 当然，随着自我发问，这里也引出了另一个问题： 内存是有限的，怎样在合适的时机将数据放到内存？ YYCache 内部使用了 LRU 来达到这个目的。我们来看下 LRU 的源码实现，以 YYMemoryCache 内实现为例。 YYMemoryCache 是通过一个链表节点类（_YYLinkedMapNode）来保存某个单独的内存缓存；再通过一个双向链表类（_YYLinkedMap）来保存和管理这些链表节点。依次看下它们的源码接口的结构： @interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; // 缓存 key id _value; // 缓存内容 NSUInteger _cost; // 缓存消耗 NSTimeInterval _time; // 上次访问时间&#125;@end@implementation _YYLinkedMapNode@end @interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // 存放节点（_YYLinkedMapNode） NSUInteger _totalCost; // 总消耗 NSUInteger _totalCount; // 节点总数 _YYLinkedMapNode *_head; // 链表头节点 _YYLinkedMapNode *_tail; // 链表尾节点 BOOL _releaseOnMainThread; // 是否主线程释放，默认 NO BOOL _releaseAsynchronously; // 是否异步释放，默认 YES&#125;- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;- (void)bringNodeToHead:(_YYLinkedMapNode *)node;- (void)removeNode:(_YYLinkedMapNode *)node;- (_YYLinkedMapNode *)removeTailNode;- (void)removeAll;@end@implementation _YYLinkedMap// 方法实现省略...@end 从分析 LRU 实现角度出发，核心的几个属性分别为： _YYLinkedMapNode _prev：前指针 _next：后指针 _YYLinkedMap _dic：存放节点 _head：头节点 _tail：尾节点 带着这些属性，看下具体的源码对双向链表 LRU 的实现过程。 insertNodeAtHead:将节点插入为头节点。 - (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123; // 将 node 的 key-value 存入 Map 的 _dic CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node)); _totalCost += node-&gt;_cost; _totalCount++; if (_head) &#123; node-&gt;_next = _head; _head-&gt;_prev = node; _head = node; &#125; else &#123; _head = _tail = node; &#125;&#125; 过程描述： 将 node 的 key-value 存入_YYLinkedMap的 _dic。 更新 _totalCost 和 _totalCount。 若 map 中有 _head，将 node 插到 headNode，并更新 _head 若 map 中无 _head，初始化 _head、_tail 为 node bringNodeToHead:- (void)bringNodeToHead:(_YYLinkedMapNode *)node &#123; if (_head == node) return; if (_tail == node) &#123; _tail = node-&gt;_prev; _tail-&gt;_next = nil; &#125; else &#123; node-&gt;_next-&gt;_prev = node-&gt;_prev; node-&gt;_prev-&gt;_next = node-&gt;_next; &#125; node-&gt;_next = _head; node-&gt;_prev = nil; _head-&gt;_prev = node; _head = node;&#125; 过程描述： 若已经是 _head，return 若 node 为 _tail，更新 _tail 为 node 前节点。将 node 放入当前头节点前，并修改 _head 若 node 不为 _tail，更新 node 前后节点的 _next 和 _prev（可以理解为先删除 node）。将 node 放入当前头节点前，并修改 _head。 removeNode:- (void)removeNode:(_YYLinkedMapNode *)node &#123; // 在 _dic 中移除 node 对应的 key-value CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key)); _totalCost -= node-&gt;_cost; _totalCount--; if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev; if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next; if (_head == node) _head = node-&gt;_next; if (_tail == node) _tail = node-&gt;_prev;&#125; 过程描述： 从 Map 的 _dic 中移除 node 对应的 key-value 更新 _totalCost、_totalCount 更新 node 后前节点的指针，需判断是否有 _next 和 _prev 若 node 为 _head，更新 _head 若 node 为 _tail，更新 _tail removeTailNode:- (_YYLinkedMapNode *)removeTailNode &#123; if (!_tail) return nil; // 取出 _tail，并从 map 的 _dic 中移除 key-value _YYLinkedMapNode *tail = _tail; CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key)); _totalCost -= _tail-&gt;_cost; _totalCount--; if (_head == _tail) &#123; _head = _tail = nil; &#125; else &#123; _tail = _tail-&gt;_prev; _tail-&gt;_next = nil; &#125; return tail;&#125; 过程描述： 根据 Map 的 _tail 取出尾节点 node，并从 _dic 中移除 key-value 更新 _totalCost、_totalCount 若链表只有一个节点（_head == _tail），置空 _head 和 _tail 否则更新 _tail 返回被移除的尾节点 node removeAll:- (void)removeAll &#123; _totalCost = 0; _totalCount = 0; _head = nil; _tail = nil; if (CFDictionaryGetCount(_dic) &gt; 0) &#123; CFMutableDictionaryRef holder = _dic; _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); if (_releaseAsynchronously) &#123; dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else &#123; CFRelease(holder); &#125; &#125;&#125; 过程描述： 重置 _totalCost、_totalCount、_head、_tail 判断是否 _dic 是否有内容，有则继续 若异步释放 _dic，再判断是否主线程释放： 主线程释放 YYMemoryCacheGetReleaseQueue() 释放 若主线程释放，判断当前是否在主线程： 不在主线程，放到主线程释放 在主线程，直接释放 LRU 小结到这里，我们已经完成了针对 node 增删改查的所有操作。在每次的操作过程中，都会根据需要修改链表中的节点和指针。这些也是实现 LRU 的基础。YYCache 中 LRU 的实现依赖于这里的双向链表。 YYMemoryCache简化后的 YYMemoryCache.h @interface YYMemoryCache : NSObject@property (nullable, copy) NSString *name;@property (readonly) NSUInteger totalCount;@property (readonly) NSUInteger totalCost;@property NSUInteger countLimit;@property NSUInteger costLimit;@property NSTimeInterval ageLimit;@property NSTimeInterval autoTrimInterval;@property BOOL shouldRemoveAllObjectsOnMemoryWarning;@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);@property BOOL releaseOnMainThread;@property BOOL releaseAsynchronously;- (BOOL)containsObjectForKey:(id)key;- (nullable id)objectForKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;- (void)removeObjectForKey:(id)key;- (void)removeAllObjects;#pragma mark - Trim- (void)trimToCount:(NSUInteger)count;- (void)trimToCost:(NSUInteger)cost;- (void)trimToAge:(NSTimeInterval)age;@end 顾名思义的接口，看的很舒服，不需要额外的注释。对应看下实现文件的源码实现。 初始化- (instancetype)init &#123; self = super.init; pthread_mutex_init(&amp;_lock, NULL); _lru = [_YYLinkedMap new]; _queue = dispatch_queue_create(\"com.ibireme.cache.memory\", DISPATCH_QUEUE_SERIAL); _countLimit = NSUIntegerMax; _costLimit = NSUIntegerMax; _ageLimit = DBL_MAX; _autoTrimInterval = 5.0; _shouldRemoveAllObjectsOnMemoryWarning = YES; _shouldRemoveAllObjectsWhenEnteringBackground = YES; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidReceiveMemoryWarningNotification) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidEnterBackgroundNotification) name:UIApplicationDidEnterBackgroundNotification object:nil]; [self _trimRecursively]; return self;&#125; 其中 _lru 是 YYMemoryCache 与 _YYLinkedMap 的一个联系点，所有的增删改查操作，都需要通过 _lru 来实现。 除此之外，我们看到了一些属性的默认值，如： 不限制 _countLimit、_costLimit、_ageLimit _autoTrimInterval 自动清理时间为 5 s 默认内存警告时，清空内存缓存 默认进入后台时，清空内存缓存 开启自动清理，后面再细说清理过程 增删改查的接口实现- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125;- (void)setObject:(id)object forKey:(id)key &#123; [self setObject:object forKey:key withCost:0];&#125;- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123; if (!key) return; if (!object) &#123; [self removeObjectForKey:key]; return; &#125; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); NSTimeInterval now = CACurrentMediaTime(); if (node) &#123; _lru-&gt;_totalCost -= node-&gt;_cost; _lru-&gt;_totalCost += cost; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_value = object; [_lru bringNodeToHead:node]; &#125; else &#123; node = [_YYLinkedMapNode new]; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_key = key; node-&gt;_value = object; [_lru insertNodeAtHead:node]; &#125; if (_lru-&gt;_totalCost &gt; _costLimit) &#123; dispatch_async(_queue, ^&#123; [self trimToCost:_costLimit]; &#125;); &#125; if (_lru-&gt;_totalCount &gt; _countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;- (void)removeAllObjects &#123; pthread_mutex_lock(&amp;_lock); [_lru removeAll]; pthread_mutex_unlock(&amp;_lock);&#125; 需要知道的几个点： 我们把增删改查统一称为访问数据 在每次的访问数据开始前，加锁 pthread_mutex_lock(&amp;_lock); 每次访问数据（增、改）时，会更新 _time 在每次的访问数据结束后，解锁 pthread_mutex_unlock(&amp;_lock); 关于锁的内容，放到后面和 YYDiskCache 一起对比分析。 缓存清理策略我们从 _YYLinkedMapNode 的头文件结构可以知道，每份缓存 node 都带有2个属性： NSUInteger _cost;：内存消耗 NSTimeInterval _time;：最新访问时间 从 _YYLinkedMap 的头文件结构中可以知道，缓存 map 带有的2个属性： NSUInteger _totalCost;：总缓存消耗 NSUInteger _totalCount;：总缓存数 再从 YYMemoryCache 的头文件中，知道了三个参数： NSUInteger countLimit：缓存数量上限值 NSUInteger costLimit：缓存消耗上限值 NSTimeInterval ageLimit：缓存访问时间距离现在最久允许值 由这些维护，我们大概知道了缓存清理策略的过程，及清理依据。具体看下代码实现： - (void)_trimRecursively &#123; __weak typeof(self) _self = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; __strong typeof(_self) self = _self; if (!self) return; [self _trimInBackground]; [self _trimRecursively]; &#125;);&#125;- (void)_trimInBackground &#123; dispatch_async(_queue, ^&#123; [self _trimToCost:self-&gt;_costLimit]; [self _trimToCount:self-&gt;_countLimit]; [self _trimToAge:self-&gt;_ageLimit]; &#125;);&#125; 过程描述： _trimRecursively： 初始化 YYMemoryCache 后即开始递归调用 _autoTrimInterval 自动清理时间默认为 5s _trimInBackground： 根据 cost、count、age 三个维度清理缓存 清理过程实现代码： - (void)_trimToCost:(NSUInteger)costLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); if (costLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCost &lt;= costLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCost &gt; costLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125;- (void)_trimToCount:(NSUInteger)countLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); if (countLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCount &lt;= countLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCount &gt; countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125;- (void)_trimToAge:(NSTimeInterval)ageLimit &#123; BOOL finish = NO; NSTimeInterval now = CACurrentMediaTime(); pthread_mutex_lock(&amp;_lock); if (ageLimit &lt;= 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (!_lru-&gt;_tail || (now - _lru-&gt;_tail-&gt;_time) &lt;= ageLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_tail &amp;&amp; (now - _lru-&gt;_tail-&gt;_time) &gt; ageLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125; 过程梳理： _trimToCost:： 非空判断 若有缓存，判断 _lru-&gt;_totalCost &gt; costLimit，从链表尾部依次取出 nodes 根据 _lru-&gt;_releaseOnMainThread 判断释放线程，释放 nodes _trimToCount:： 非空判断 若有缓存，判断 _lru-&gt;_totalCount &gt; countLimit，从链表尾部依次取出 nodes 根据 _lru-&gt;_releaseOnMainThread 判断释放线程，释放 nodes _trimToAge:： 非空判断 若有缓存，判断 _lru-&gt;_tail &amp;&amp; (now - _lru-&gt;_tail-&gt;_time) &gt; ageLimit，从尾节点依次向头节点判断，若尾节点的时间不满足，则取出加入 nodes；直到第一个满足时间要求的节点为止。（本身链表的排序也是按照 time 来的，越旧未访问的内容，越靠近尾部） 根据 _lru-&gt;_releaseOnMainThread 判断释放线程，释放 nodes 自己的思考： _trimToAge: 中的 age 指的是最近访问时间，而不是创建时间。带着这个认知，再看 _trimToAge: 的实现，思路就会很清楚了。 缓存清理策略小结缓存清理策略的维度： cost：缓存消耗 count：缓存数量 age：缓存的最近访问时间 缓存清理的方式： 默认支持自动缓存清理 也支持手动清理 YYDiskCache简化后的 YYDiskCache.h： @interface YYDiskCache : NSObject@property (nullable, copy) NSString *name;@property (readonly) NSString *path;@property (readonly) NSUInteger inlineThreshold;@property (nullable, copy) NSData *(^customArchiveBlock)(id object);@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data);@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key);@property NSUInteger countLimit;@property NSUInteger costLimit;@property NSTimeInterval ageLimit;@property NSUInteger freeDiskSpaceLimit;@property NSTimeInterval autoTrimInterval;@property BOOL errorLogsEnabled;#pragma mark - Initializer- (instancetype)init UNAVAILABLE_ATTRIBUTE;+ (instancetype)new UNAVAILABLE_ATTRIBUTE;- (nullable instancetype)initWithPath:(NSString *)path;- (nullable instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold NS_DESIGNATED_INITIALIZER;#pragma mark - Access Methods- (BOOL)containsObjectForKey:(NSString *)key;- (void)containsObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key, BOOL contains))block;- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)objectForKey:(NSString *)key withBlock:(void(^)(NSString *key, id&lt;NSCoding&gt; _Nullable object))block;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(void(^)(void))block;- (void)removeObjectForKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key))block;- (void)removeAllObjects;- (void)removeAllObjectsWithBlock:(void(^)(void))block;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;- (NSInteger)totalCount;- (void)totalCountWithBlock:(void(^)(NSInteger totalCount))block;- (NSInteger)totalCost;- (void)totalCostWithBlock:(void(^)(NSInteger totalCost))block;#pragma mark - Trim- (void)trimToCount:(NSUInteger)count;- (void)trimToCount:(NSUInteger)count withBlock:(void(^)(void))block;- (void)trimToCost:(NSUInteger)cost;- (void)trimToCost:(NSUInteger)cost withBlock:(void(^)(void))block;- (void)trimToAge:(NSTimeInterval)age;- (void)trimToAge:(NSTimeInterval)age withBlock:(void(^)(void))block;#pragma mark - Extended Data+ (nullable NSData *)getExtendedDataFromObject:(id)object;+ (void)setExtendedData:(nullable NSData *)extendedData toObject:(id)object;@end 需要注意的点： YYDiskCache 禁用了 init 和 new 的初始化方法。通过 UNAVAILABLE_ATTRIBUTE，将这两种初始化方法设为私有。 NS_DESIGNATED_INITIALIZER 为什么用这个宏？ 为了告诉调用者需要用这个方法来初始化类对象 使用的注意事项： 如果子类指定了新的初始化器，在这个初始化器的内部必须调用父类 Designated Initializer，并重写父类 Designated Initializer，将其指向子类新的初始化器。例如：- (instancetype)initWithName:(NSString *)name NS_DESIGNATED_INITIALIZER;- (instancetype)init &#123; return [self initWithName:@\"\"];&#125;- (instancetype)initWithName:(NSString *)name &#123; self = [super init]; if (self) &#123; // do something &#125; return self; &#125; 配合使用 配合使用 UNAVAILABLE_ATTRIBUTE 和 NS_DESIGNATED_INITIALIZER，目的在于指定初始化方法。格式如下：+ (instancetype)new NS_UNAVAILABLE;- (instancetype)init NS_UNAVAILABLE;- (instancetype)initWithName:(NSString *)name NS_DESIGNATED_INITIALIZER; 接着对应看下实现文件的源码实现。 初始化- (instancetype)initWithPath:(NSString *)path &#123; return [self initWithPath:path inlineThreshold:1024 * 20]; // 20KB&#125;- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; self = [super init]; if (!self) return nil; YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path); if (globalCache) return globalCache; YYKVStorageType type; if (threshold == 0) &#123; type = YYKVStorageTypeFile; &#125; else if (threshold == NSUIntegerMax) &#123; type = YYKVStorageTypeSQLite; &#125; else &#123; type = YYKVStorageTypeMixed; &#125; YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type]; if (!kv) return nil; _kv = kv; _path = path; _lock = dispatch_semaphore_create(1); _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT); _inlineThreshold = threshold; _countLimit = NSUIntegerMax; _costLimit = NSUIntegerMax; _ageLimit = DBL_MAX; _freeDiskSpaceLimit = 0; _autoTrimInterval = 60; [self _trimRecursively]; _YYDiskCacheSetGlobal(self); [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil]; return self;&#125; 其中 _kv 是 YYMemoryCache 与 YYKVStorage 的一个联系点，所有的增删改查操作，都需要通过 _kv 来实现。我们看下 YYKVStorage 内部的是怎么操作数据的。 另一个是 DiskCache 真实的存储分为文件和 SQLite 存储，在初始化时，可以指定存储方式。即设置： @property (readonly) NSUInteger inlineThreshold; // 默认 1024 * 20，20kb KVStorageYYKVStorageTypetypedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; YYKVStorageTypeFile = 0, YYKVStorageTypeSQLite = 1, YYKVStorageTypeMixed = 2,&#125;; 梳理： YYKVStorageTypeFile：在 SQLite 中直接存文件的路径，不在 SQLite 中存要存储的值 YYKVStorageTypeSQLite：只在 SQLite 中存要存储的值 YYKVStorageTypeMixed：根据文件大小来确定要存储的值存放形式（File 或 SQLite），默认使用它。 选用通过 inlineThreshold 确定。 YYKVStorageItem 与 YYKVStorageYYKVStorage 类似于 MemoryCache 里面的 node。DiskCache 每一项被封装成了 YYKVStorageItem 实例，再通过 YYKVStorage 来管理 YYKVStorageItem。 YYKVStorageItem 结构如下： @interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; ///&lt; key@property (nonatomic, strong) NSData *value; ///&lt; value@property (nullable, nonatomic, strong) NSString *filename; ///&lt; filename (nil if inline)@property (nonatomic) int size; ///&lt; value's size in bytes@property (nonatomic) int modTime; ///&lt; 修改时间戳@property (nonatomic) int accessTime; ///&lt; 最后访问时间戳@property (nullable, nonatomic, strong) NSData *extendedData; ///&lt; extended data (nil if no extended data)@end KVStorage 的接口： #pragma mark - Save Items- (BOOL)saveItem:(YYKVStorageItem *)item;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(nullable NSString *)filename extendedData:(nullable NSData *)extendedData;#pragma mark - Remove Items- (BOOL)removeItemForKey:(NSString *)key;- (BOOL)removeItemForKeys:(NSArray&lt;NSString *&gt; *)keys;- (BOOL)removeItemsLargerThanSize:(int)size;- (BOOL)removeItemsEarlierThanTime:(int)time;- (BOOL)removeItemsToFitSize:(int)maxSize;- (BOOL)removeItemsToFitCount:(int)maxCount;- (BOOL)removeAllItems;- (void)removeAllItemsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;#pragma mark - Get Items- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;- (nullable YYKVStorageItem *)getItemInfoForKey:(NSString *)key;- (nullable NSData *)getItemValueForKey:(NSString *)key;- (nullable NSArray&lt;YYKVStorageItem *&gt; *)getItemForKeys:(NSArray&lt;NSString *&gt; *)keys;- (nullable NSArray&lt;YYKVStorageItem *&gt; *)getItemInfoForKeys:(NSArray&lt;NSString *&gt; *)keys;- (nullable NSDictionary&lt;NSString *, NSData *&gt; *)getItemValueForKeys:(NSArray&lt;NSString *&gt; *)keys; Save/Update 的过程- (BOOL)saveItem:(YYKVStorageItem *)item &#123; return [self saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];&#125;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value &#123; return [self saveItemWithKey:key value:value filename:nil extendedData:nil];&#125;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123; if (key.length == 0 || value.length == 0) return NO; if (_type == YYKVStorageTypeFile &amp;&amp; filename.length == 0) &#123; return NO; &#125; if (filename.length) &#123; if (![self _fileWriteWithName:filename data:value]) &#123; return NO; &#125; if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123; [self _fileDeleteWithName:filename]; return NO; &#125; return YES; &#125; else &#123; if (_type != YYKVStorageTypeSQLite) &#123; NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; &#125; return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData]; &#125;&#125; 过程描述: 校验 key value type 为 YYKVStorageTypeFile 时，校验 filename 是否存在 判断是否有 filename（_kv.type != YYKVStorageTypeSQLite &amp;&amp; value.length &gt; _inlineThreshold时创建 filename) 疑问：如果 YYKVStorageTypeFile 的话，依旧会按照上面进行文件大小判断，再创建文件名 若有 filename，value 以 filename 写入文件；文件写入成功后，将相关数据写入数据库 db 若没有 filename，且 type 不为 YYKVStorageTypeSQLite 从 db 查询 filename，若有，清空对应文件 将相关数据写入 db，只是不写入文件 Remove 的过程- (BOOL)removeItemForKey:(NSString *)key &#123; if (key.length == 0) return NO; switch (_type) &#123; case YYKVStorageTypeSQLite: &#123; return [self _dbDeleteItemWithKey:key]; &#125; break; case YYKVStorageTypeFile: case YYKVStorageTypeMixed: &#123; NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; return [self _dbDeleteItemWithKey:key]; &#125; break; default: return NO; &#125;&#125;- (BOOL)removeItemForKeys:(NSArray *)keys &#123; if (keys.count == 0) return NO; switch (_type) &#123; case YYKVStorageTypeSQLite: &#123; return [self _dbDeleteItemWithKeys:keys]; &#125; break; case YYKVStorageTypeFile: case YYKVStorageTypeMixed: &#123; NSArray *filenames = [self _dbGetFilenameWithKeys:keys]; for (NSString *filename in filenames) &#123; [self _fileDeleteWithName:filename]; &#125; return [self _dbDeleteItemWithKeys:keys]; &#125; break; default: return NO; &#125;&#125;- (BOOL)removeAllItems &#123; if (![self _dbClose]) return NO; [self _reset]; if (![self _dbOpen]) return NO; if (![self _dbInitialize]) return NO; return YES;&#125;- (void)removeAllItemsWithProgressBlock:(void(^)(int removedCount, int totalCount))progress endBlock:(void(^)(BOOL error))end &#123; int total = [self _dbGetTotalItemCount]; if (total &lt;= 0) &#123; if (end) end(total &lt; 0); &#125; else &#123; int left = total; int perCount = 32; NSArray *items = nil; BOOL suc = NO; do &#123; items = [self _dbGetItemSizeInfoOrderByTimeAscWithLimit:perCount]; for (YYKVStorageItem *item in items) &#123; if (left &gt; 0) &#123; if (item.filename) &#123; [self _fileDeleteWithName:item.filename]; &#125; suc = [self _dbDeleteItemWithKey:item.key]; left--; &#125; else &#123; break; &#125; if (!suc) break; &#125; if (progress) progress(total - left, total); &#125; while (left &gt; 0 &amp;&amp; items.count &gt; 0 &amp;&amp; suc); if (suc) [self _dbCheckpoint]; if (end) end(!suc); &#125;&#125; 部分 Remove 的过程，以 removeAllItemsWithProgressBlock:endBlock: 为例： 若无缓存，结束，end block 若有缓存，每次从 db 最多取出 32 个缓存项，遍历移除文件和 db 内容 每删除 32 个缓存，回调一次 progressBlock（progress = (total - left)/total） 删除完成 endBlock Get 的过程- (YYKVStorageItem *)getItemForKey:(NSString *)key &#123; if (key.length == 0) return nil; YYKVStorageItem *item = [self _dbGetItemWithKey:key excludeInlineData:NO]; if (item) &#123; [self _dbUpdateAccessTimeWithKey:key]; if (item.filename) &#123; item.value = [self _fileReadWithName:item.filename]; if (!item.value) &#123; [self _dbDeleteItemWithKey:key]; item = nil; &#125; &#125; &#125; return item;&#125; 以 getItemForKey: 为例： 校验 key 从 db 中根据 key 取出 YYKVStorageItem 格式的数据 更新 db 中这条数据的时间 如果有 filename，以 filename 从文件中取出 value 并返回给 item.value 若 item.value 为空，从 db 中移除这条无效缓存 返回 item YYDiskCache 的对应处理了解了 YYKVStorage 的存取实现逻辑后，回过头再来看下上层 YYDiskCache 是如何实现对应方法的。 - (BOOL)containsObjectForKey:(NSString *)key &#123; if (!key) return NO; Lock(); BOOL contains = [_kv itemExistsForKey:key]; Unlock(); return contains;&#125;- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123; if (!key) return nil; Lock(); YYKVStorageItem *item = [_kv getItemForKey:key]; Unlock(); if (!item.value) return nil; id object = nil; if (_customUnarchiveBlock) &#123; object = _customUnarchiveBlock(item.value); &#125; else &#123; @try &#123; object = [NSKeyedUnarchiver unarchiveObjectWithData:item.value]; &#125; @catch (NSException *exception) &#123; // nothing to do... &#125; &#125; if (object &amp;&amp; item.extendedData) &#123; [YYDiskCache setExtendedData:item.extendedData toObject:object]; &#125; return object;&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; if (!key) return; if (!object) &#123; [self removeObjectForKey:key]; return; &#125; NSData *extendedData = [YYDiskCache getExtendedDataFromObject:object]; NSData *value = nil; if (_customArchiveBlock) &#123; value = _customArchiveBlock(object); &#125; else &#123; @try &#123; value = [NSKeyedArchiver archivedDataWithRootObject:object]; &#125; @catch (NSException *exception) &#123; // nothing to do... &#125; &#125; if (!value) return; NSString *filename = nil; if (_kv.type != YYKVStorageTypeSQLite) &#123; if (value.length &gt; _inlineThreshold) &#123; filename = [self _filenameForKey:key]; &#125; &#125; Lock(); [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData]; Unlock();&#125; 列出了 -containsObjectForKey:、objectForKey:、setObject:forKey: 方法对应的源码。在每次的 _kv 操作时，都会进行加锁和解锁。 这里使用了宏来代替加锁解锁的代码： #define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)#define Unlock() dispatch_semaphore_signal(self-&gt;_lock) 后面结合 YYMemoryCache，一起看下两种锁的区别。 NSMapTableNSMapTable 是类似于字典的集合，但具有更广泛的可用内存语义。NSMapTable 是 iOS6 之后引入的类，它基于 NSDictionary 建模，但是具有以下差异： key-value 可以选择弱持有，以便于在回收其中一个对象时删除对应条目。 它可以包含任意指针（其内容不被约束为对象）。 我们可以将 NSMapTable 实例配置为对任意指针进行操作，而不仅仅是对象。 官方文档：NSMapTable 官方文档 YYDiskCache 内部是基于一个单例 NSMapTable 管理的。 /// weak reference for all instancesstatic NSMapTable *_globalInstances; // _globalInstances 管理所有 YYDiskCache 实例static dispatch_semaphore_t _globalInstancesLock; // 使用 dispatch_semaphore 保障 NSMapTable 线程安全static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; 每当初始化 YYDiskCache 时，先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例。如果获取不到，会重新初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做也会提升不少性能。 - (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; // ... // 先从 NSMapTable 单例中通过 path 获取 YYDiskCache 实例 // 如果获取到，直接返回该实例 YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path); if (globalCache) return globalCache; YYKVStorageType type; if (threshold == 0) &#123; type = YYKVStorageTypeFile; &#125; else if (threshold == NSUIntegerMax) &#123; type = YYKVStorageTypeSQLite; &#125; else &#123; type = YYKVStorageTypeMixed; &#125; // 弱没有获取到，初始化一个新的 YYDiskCache 实例 YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type]; if (!kv) return nil; _kv = kv; _path = path; _lock = dispatch_semaphore_create(1); _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT); _inlineThreshold = threshold; _countLimit = NSUIntegerMax; _costLimit = NSUIntegerMax; _ageLimit = DBL_MAX; _freeDiskSpaceLimit = 0; _autoTrimInterval = 60; [self _trimRecursively]; // 向 NSMapTable 单例注册新生成的 YYDiskCache 实例 _YYDiskCacheSetGlobal(self); // ... return self;&#125; 如何保证的线程安全通过前面的代码分析，我们已经知道了 YYCache 在增删改查的过程中，会进行加解锁操作。锁的目的也是为了保证线程的安全。分别看下 MemoryCache 和 DiskCache 分别是怎么实现线程安全的。 YYMemoryCache 线程安全处理YYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全。ibireme 使用 pthread_mutex 的缘由：不再安全的 OSSpinLock。简单言之，处于安全考虑选用了现在的 pthread_mutex。 pthread_mutex 的基本用法： // 申明一个互斥锁pthread_mutex_t _lock;// 初始化pthread_mutex_init(&amp;_lock,NULL);// 使用 _lock 之前一定要初始化，否则不生效// 锁定互斥锁pthread_mutex_lock(&amp;_lock);// 解除锁定互斥锁pthread_mutex_unlock(&amp;_lock);// pthread_mutex_lock() 的非阻塞版本// 如果 _lock 所引用的互斥对象被任何线程（包括当前线程）锁定，将立刻返回该调用// 否则该互斥锁将被锁定，调用线程为当前线程// pthread_mutex_lock() 成功锁定后会返回 0，返回`其他任何值`表示`出错`pthread_mutex_trylock(&amp;_lock);// 销毁互斥锁pthread_mutex_destroy(&amp;_lock); pthread_mutex 表示互斥锁。互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，会导致线程休眠。 YYMemoryCache 中： - (instancetype)init &#123; self = super.init; pthread_mutex_init(&amp;_lock, NULL); // ...&#125;- (void)dealloc &#123; // ... pthread_mutex_destroy(&amp;_lock);&#125;- (void)_trimToCount:(NSUInteger)countLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); if (countLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCount &lt;= countLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCount &gt; countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125; 我们看到 YYCache 中每次对 _lru 操作时都会进行锁定和解除。也用到了 pthread_mutex_trylock(&amp;_lock)。 YYDiskCache 线程安全处理YYDiskCache 使用了信号量（dispatch_semaphore）来保证线程的安全。Dispatch Semaphore 是持有计数的信号，计数为 0 时等待，计数 &gt;= 1 时放行。 dispatch_semaphore 的基本用法： dispatch_semaphore_create 可以生成信号量，参数 value 是信号量计数的初始值； dispatch_semaphore_wait 会让信号量值 -1，当信号量值为 0 时进入等待（直到超时），否则正常执行； dispatch_semaphore_signal 会让信号量值 +1，如果有通过 dispatch_semaphore_wait 函数等待 Dispatch Semaphore 的计数值增加的线程，会由系统唤醒最先等待的线程执行。 YYDiskCache 中： @implementation YYDiskCache &#123; YYKVStorage *_kv; dispatch_semaphore_t _lock; dispatch_queue_t _queue;&#125;- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; // ... _lock = dispatch_semaphore_create(1); // ...&#125;// 通过宏来替换加锁解锁代码#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)#define Unlock() dispatch_semaphore_signal(self-&gt;_lock)- (BOOL)containsObjectForKey:(NSString *)key &#123; if (!key) return NO; Lock(); BOOL contains = [_kv itemExistsForKey:key]; Unlock(); return contains;&#125; 可以看到 YYDiskCache 中每次对 _kv 操作时，都会进行加解锁操作。 为什么线程安全的处理方式不同？先了解一个概念，信号量和互斥锁的区别： 互斥锁用户用于线程的互斥，信号量用于线程的同步。 同步和互斥是针对线程的。同步允许多线程按序访问；互斥只允许单个线程访问。 互斥：指某个资源同时只允许一个访问者对其访问，具有排他性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步：指在互斥的基础上，通过其他机制实现访问者对资源的有序访问。即信号量可以让多个线程有序访问某个资源。 YYDiskCache 在写入较大缓存时，会有较长的等待时间，而 dispatch_semaphore 是不消耗 CPU 资源的，所以选用信号量。 总结 YYCache 框架结构 YYCache YYMemoryCache _YYLinkedMap _YYLinkedMapNode YYDiskCache YYKVStorage YYKVStorageItem YYCache 增删改查方法 先操作 _memoryCache，再操作 _diskCache 回调以 _diskCache 为准 这一层没有真实的做数据处理 LRU Least Recently Used 最近最少使用 缓存命中率 MemoryCache LRU 的实现 通过双向链表类_YYLinkedMap，保存和管理链表节点 _YYLinkedMapNode。 _YYLinkedMapNode _prev _next value _YYLinedMap _dic：存放链表节点 _head：头节点 _tail：尾节点 每次数据访问时，将被访问节点调整到 head 位置 YYMemoryCache 初始化 pthread_mutex 互斥锁 三个缓存管理维度（count、cost、age） 自动清理时间 5s 默认内存警告、进入后台时，清空 memoryCache 增删改查 每次数据访问 pthread_mutex_lock 加锁 访问修改数据，更新相关属性（time 等） pthread_mutex_unlock 解锁 缓存清理 手动或自动 三个维度（count、cost、age） 从双向链表尾部开始清理 YYDiskCache 初始化 内有一单例 NSMapTable 先通过 path 从 NSMapTable 中查是否有对应实例，有则用，无责新建并存 _kv 实例，类似 MemoryCache 的 _dic dispatch_semaphore 信号量，自旋锁 三个缓存维度（count、cost、age） 自动清理 增删改查 YYKVStorageType File SQLite Mixed YYKVStorage 管理 YYKVStorageItem 增删改查过程中既要修改文件、又要修改 SQLite 的数据 dispatch_semaphore_wait 加锁 处理数据 dispatch_semaphore_signal 解锁 NSMapTable NSHashTable 更广泛意义的 NSSet、NSMutableSet NSMapTable 更广泛意义的 NSDictionary、NSMutableDictionary 可以存储指针，内容不被约束为对象 缓存清理 类似memorycache 线程安全处理 pthread_mutex dispatch_semaphore","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"YYImage 源码梳理","slug":"2017-09-10-yyimage","date":"2017-09-09T16:00:00.000Z","updated":"2021-01-12T10:00:28.710Z","comments":true,"path":"2017/09/10/2017-09-10-yyimage/","link":"","permalink":"https://blog.jonyfang.com/2017/09/10/2017-09-10-yyimage/","excerpt":"图片相关的处理，在移动应用中属于比较重要的一个角色。本篇主要是对 YYImage 的源码实现做一个梳理，内容结构： UIImage 相关的处理 YYImage 框架结构 YYImage YYFrameImage YYSpriteSheetImage YYAnimatedImage YYAnimatedImageView YYImageCoder","text":"图片相关的处理，在移动应用中属于比较重要的一个角色。本篇主要是对 YYImage 的源码实现做一个梳理，内容结构： UIImage 相关的处理 YYImage 框架结构 YYImage YYFrameImage YYSpriteSheetImage YYAnimatedImage YYAnimatedImageView YYImageCoder UIImage 相关处理一张图片从磁盘到显示到屏幕的大致过程为： 从磁盘加载图片信息 解码图片二进制数据为位图 通过 CoreAnimation 框架处理最终绘制到屏幕上 这一过程中耗时较大的操作是图片解码的过程。 图片的加载和解压日常开发中，我们常会通过 UIImage 的 imageNamed: 或 imageWithData: 方法从内存中加载图片生成 UIImage 对象。在这一过程中，图片不会进行解压，当 RunLoop 准备处理图片显示的处理（CATransaction）时，才进行解压，而这个解压过程是在主线程中执行的，所以大图解压也是导致卡顿的一个重要因素。 imageNamed:在我们使用 imageNamed: 加载图片信息生成 UIImage 对象的同时，图片的信息会被缓存起来。所以在使用该方法第一次加载某图片时，会消耗较多时间，而之后再加载该图会快很多。 到这里图片还未进行解压操作，当某图片要绘制到屏幕前，会进行解压操作，系统也会将解压信息缓存到内存中。这些缓存是全局的，也就是说，即使当前 UIImage 对象被释放也不会影响该图片的缓存，只有当应用收到内存警告会应用进入后台才会进行缓存处理。具体的缓存清理策略是由系统决定的。 imageWithData:在我们使用 imageWithData: 加载图片生成 UIImage 对象时，从加载图片信息到解压图片进行屏幕上绘制的这一过程中。都不会将图片信息及解压信息以全局的形式缓存，在该 UIImage 对象释放时，相关的图片信息及解压信息都会被销毁。 对比 imageNamed: 会产生全局的内存占用，但第二次使用同一张图时，可以直接使用缓存数据，性能更好。 imageWIthData: 可以理解为即用即生成，即使是同一张图的重复使用，每次都需要走一遍加载和解压的过程。 对比来看，imageNamed: 方法适合小而高频次使用的图片；imageWithData: 方法适合大而低频次的图片。 基于前面的了解可以对图片的加载和解压过程做一些优化。 加载的优化：可以在异步线程中通过 imageWithContentsOfFile: 方法加载图片。 解压的优化：系统默认将解压的耗时操作放到了主线程中执行，比较通用的做法是在异步线程中通过 CGBitmapContextCreate 方法主动将二进制图片数据解压成位图数据， 大图处理主流 iOS 设备最高支持 4096x4096 的纹理尺寸，若图片像素过大，在显示时会额外消耗资源来处理图片。且常会的图片加载过程会占用过多的内存。 大图加载的出发点是，这张图最终的展示效果是需要怎样的？如果大图展示能够满足展示窗口的展示效果，一定程度上我们可以进行大图的压缩。 在我们缩小图片是，会按取平均值的方式把多个像素点变为一个像素点，但超大图处理的过程中，老设备很可能会出现 OOM 的情况。原因是常规图片绘制的过程中，会先解码图片，再生成原始分辨率大小的 bitmap，这会很消耗内存。 解决办法是使用更底层的 ImageIO 接口，它可以直接读取图像大小和元数据信息，不带来额外的内存开销。 另一种解决办法是，WWDC2018 苹果工程师建议开发者使用 UIGraphicsImageRenderer 来代替 UIGraphicsBeginImageContextWithOptions。该方法从 iOS10 引入，在 iOS12 中自动选择最佳的图片格式，可以减少很多的内存。 YYImage 框架结构前面铺垫了解了一些 UIImage 相关的处理过程。再来看下 YYImage 的框架结构。 YYImage 特性（来自 README）： 支持以下类型动画图像的播放/编码/解码: WebP, APNG, GIF。 支持以下类型静态图像的显示/编码/解码: WebP, PNG, GIF, JPEG, JP2, TIFF, BMP, ICO, ICNS。 支持以下类型图片的渐进式/逐行扫描/隔行扫描解码: PNG, GIF, JPEG, BMP。 支持多张图片构成的帧动画播放，支持单张图片的 sprite sheet 动画。 高效的动态内存缓存管理，以保证高性能低内存的动画播放。 完全兼容 UIImage 和 UIImageView，使用方便。 保留可扩展的接口，以支持自定义动画。 每个类和方法都有完善的文档注释。 YYImage 的目录结构： YYImage YYFrameImage YYSpriteSheetImage YYAnimatedImageView YYImageCoder 主要分为三个层级，分别为： 继承自 UIImage 的图像层 继承自 UIImageView 的视图层 编解码层 其中 YYImage、YYFrameImage、YYSpriteSheetImage 都继承自 UIImage。YYAnimatedImageView 继承自 UIImageView，用于处理框架自定义的图片类。YYImageCoder 负责编码和解码。 YYImageYYImage 是 UIImage 的子类，支持 png、jpeg、jpg、gif、webp、apng 格式图片的解码，提供了类似 UIImage 的初始化方法。其中为了避免 imageName: 方法产生全局缓存，重载了该方法。源码如下： + (YYImage *)imageNamed:(NSString *)name &#123; if (name.length == 0) return nil; if ([name hasSuffix:@\"/\"]) return nil; NSString *res = name.stringByDeletingPathExtension; NSString *ext = name.pathExtension; NSString *path = nil; CGFloat scale = 1; // If no extension, guess by system supported (same as UIImage). NSArray *exts = ext.length &gt; 0 ? @[ext] : @[@\"\", @\"png\", @\"jpeg\", @\"jpg\", @\"gif\", @\"webp\", @\"apng\"]; NSArray *scales = _NSBundlePreferredScales(); for (int s = 0; s &lt; scales.count; s++) &#123; scale = ((NSNumber *)scales[s]).floatValue; NSString *scaledName = _NSStringByAppendingNameScale(res, scale); for (NSString *e in exts) &#123; path = [[NSBundle mainBundle] pathForResource:scaledName ofType:e]; if (path) break; &#125; if (path) break; &#125; if (path.length == 0) return nil; NSData *data = [NSData dataWithContentsOfFile:path]; if (data.length == 0) return nil; return [[self alloc] initWithData:data scale:scale];&#125; 根据图片名取得拓展名，若未指定拓展名，遍历查询所有支持的类型 scales 为根据设备拿到的对应分辨率，@[@1,@2,@3] 得到有效 path 后，break 调用 initWithData:scale: 方法进行初始化 初始化方法最终都会调用 -initWithData:scale: 来进行初始化，源码如下： - (instancetype)initWithData:(NSData *)data scale:(CGFloat)scale &#123; if (data.length == 0) return nil; if (scale &lt;= 0) scale = [UIScreen mainScreen].scale; _preloadedLock = dispatch_semaphore_create(1); @autoreleasepool &#123; YYImageDecoder *decoder = [YYImageDecoder decoderWithData:data scale:scale]; YYImageFrame *frame = [decoder frameAtIndex:0 decodeForDisplay:YES]; UIImage *image = frame.image; if (!image) return nil; self = [self initWithCGImage:image.CGImage scale:decoder.scale orientation:image.imageOrientation]; if (!self) return nil; _animatedImageType = decoder.type; if (decoder.frameCount &gt; 1) &#123; _decoder = decoder; _bytesPerFrame = CGImageGetBytesPerRow(image.CGImage) * CGImageGetHeight(image.CGImage); _animatedImageMemorySize = _bytesPerFrame * decoder.frameCount; &#125; self.yy_isDecodedForDisplay = YES; &#125; return self;&#125; 方法实现过程： 初始化信号量 _preloadedLock 初始化图像解码器 _decoder（YYImageDecoder ） 通过解压器获取第一帧解压后的图像 通过 -initWithCGImage:scale:orientation: 初始化得到 YYImage 实例 若帧数 &gt; 1 暂存解码器 _decoder 暂存每帧内存占用大小 _bytesPerFrame 暂存总内存占用大小 _animatedImageMemorySize return 初始化完成的 YYImage 需要注意的几个点： _preloadedLock：dispatch_semaphore_t 信号量锁，的目的是为了保证 _preloadedFrames 在内存中的读写安全。 _preloadedFrames：对应 preloadAllAnimatedImageFrames 对外属性。若开启预加载所有帧到内存，_preloadedFrames 数组会保存所有帧的图像。 为什么锁选信号量：原因是 _preloadedFrames 的读写本身不会太耗时，不会有长时间的等待，使用信号量这样的自旋锁会比较合适。 YYFrameImageYYFrameImage 是专门用来处理帧动画图片的类，可以配置每一帧的图片信息和显示时长，也是 UIImage 的子类，仅支持 png 和 jpeg 格式。 主要的初始化方法： - (nullable instancetype)initWithImagePaths:(NSArray&lt;NSString *&gt; *)paths frameDurations:(NSArray&lt;NSNumber *&gt; *)frameDurations loopCount:(NSUInteger)loopCount;- (nullable instancetype)initWithImageDataArray:(NSArray&lt;NSData *&gt; *)dataArray frameDurations:(NSArray *)frameDurations loopCount:(NSUInteger)loopCount; 方法实现过程： 通过 path 拿到 NSData（或直接使用传入的 NSData） 通过 yy_imageByDecoded 解压 data，得到 UIImage 通过 UIImage，再带上帧动画相关的私有变量，封装得到 YYFrameImage return YYFrameImage YYSpriteSheetImageYYSpriteSheetImage 是用于支持 SpriteSheet 动画显示的图像类，也是 UIImage 的子类。SpriteSheet 动画可以理解为在一张大图上分布有很多块小图，不同时刻显示不同的小图，已达到动画展示的目的。一张图的加载耗时相对多图会好很多，避免了一些非必要的资源浪费。 接口源码如下： - (nullable instancetype)initWithSpriteSheetImage:(UIImage *)image contentRects:(NSArray&lt;NSValue *&gt; *)contentRects frameDurations:(NSArray&lt;NSNumber *&gt; *)frameDurations loopCount:(NSUInteger)loopCount;@property (nonatomic, readonly) NSArray&lt;NSValue *&gt; *contentRects;@property (nonatomic, readonly) NSArray&lt;NSValue *&gt; *frameDurations;@property (nonatomic, readonly) NSUInteger loopCount; 方法实现过程： 根据传入数据，初始化 SpriteSheet 动画播放过程中需要的参数 _contentRects _frameDurations _loopCount 封装得到 YYSpriteSheetImage，并返回 YYAnimatedImage 协议YYAnimatedImage 协议将 YYAnimatedImageView 和 YYImage、YYFrameImage、YYSpriteSheetImage 之间构成了联系。不论是这三种图像类或以后会有拓展的图像类，他们之间虽然存在区别，但最终动画展示的原理是不变的。可以将共性的模块通过 YYAnimatedImage 协议来实现。 对应协议源码： @protocol YYAnimatedImage &lt;NSObject&gt;@required// 总帧数- (NSUInteger)animatedImageFrameCount;// 循环次数，0 表示无限循环- (NSUInteger)animatedImageLoopCount;// 每帧在内存中的占用大小- (NSUInteger)animatedImageBytesPerFrame;// 获取某一帧图像- (nullable UIImage *)animatedImageFrameAtIndex:(NSUInteger)index;// 获取某一帧的显示时间- (NSTimeInterval)animatedImageDurationAtIndex:(NSUInteger)index;@optional// 为 SpriteSheet 动画提供，获取某一动画的 contentsRect- (CGRect)animatedImageContentsRectAtIndex:(NSUInteger)index;@end 共性抽离的思路在我们的日常开发中也常会用到，这里通过协议来统一接口的实现方式，使得逻辑看上去很清晰。 YYAnimatedImageViewYYAnimatedImageView 是用来展示 YYImage、YYFrameImage、YYSpriteSheetImage 的类。由于 YYImage、YYFrameImage、YYSpriteSheetImage 都实现了 YYAnimatedImage 的协议方法，YYAnimatedImageView 可以根据不同的类型来对应展示图片。具体看下内部的实现。 YYAnimatedImageView 可以理解为中间展示层，通过图像层解压的图像解码进行显示。 初始化- (void)setImage:(UIImage *)image &#123; if (self.image == image) return; [self setImage:image withType:YYAnimatedImageTypeImage];&#125;- (void)setHighlightedImage:(UIImage *)highlightedImage &#123; if (self.highlightedImage == highlightedImage) return; [self setImage:highlightedImage withType:YYAnimatedImageTypeHighlightedImage];&#125;- (void)setAnimationImages:(NSArray *)animationImages &#123; if (self.animationImages == animationImages) return; [self setImage:animationImages withType:YYAnimatedImageTypeImages];&#125;- (void)setHighlightedAnimationImages:(NSArray *)highlightedAnimationImages &#123; if (self.highlightedAnimationImages == highlightedAnimationImages) return; [self setImage:highlightedAnimationImages withType:YYAnimatedImageTypeHighlightedImages];&#125; 方法实现过程： 在 YYAnimatedImageView 中可以看到四种 setImage 的方式 先与已有 image 进行对比，如果不同则调用 -setImage:withType: - (void)setImage:(id)image withType:(YYAnimatedImageType)type &#123; [self stopAnimating]; if (_link) [self resetAnimated]; _curFrame = nil; switch (type) &#123; case YYAnimatedImageTypeNone: break; case YYAnimatedImageTypeImage: super.image = image; break; case YYAnimatedImageTypeHighlightedImage: super.highlightedImage = image; break; case YYAnimatedImageTypeImages: super.animationImages = image; break; case YYAnimatedImageTypeHighlightedImages: super.highlightedAnimationImages = image; break; &#125; [self imageChanged];&#125; 方法实现过程： 根据不同的 type 重置对应 type 的 image 实例 最终调用 -imageChanged。 - (void)imageChanged &#123; // 获取当前 type 和 image 实例 YYAnimatedImageType newType = [self currentImageType]; id newVisibleImage = [self imageForType:newType]; NSUInteger newImageFrameCount = 0; BOOL hasContentsRect = NO; // 特殊处理 SpriteSheet 类型 Image // 通过判断 protocol 是否有对应实现来判断，是否是 SpriteSheetImage if ([newVisibleImage isKindOfClass:[UIImage class]] &amp;&amp; [newVisibleImage conformsToProtocol:@protocol(YYAnimatedImage)]) &#123; newImageFrameCount = ((UIImage&lt;YYAnimatedImage&gt; *) newVisibleImage).animatedImageFrameCount; if (newImageFrameCount &gt; 1) &#123; hasContentsRect = [((UIImage&lt;YYAnimatedImage&gt; *) newVisibleImage) respondsToSelector:@selector(animatedImageContentsRectAtIndex:)]; &#125; &#125; // 若之前展示过 SpriteSheetImage，这里进行 layer 复位 if (!hasContentsRect &amp;&amp; _curImageHasContentsRect) &#123; // 复位 rect，且过程中取消隐式动画 if (!CGRectEqualToRect(self.layer.contentsRect, CGRectMake(0, 0, 1, 1)) ) &#123; [CATransaction begin]; [CATransaction setDisableActions:YES]; self.layer.contentsRect = CGRectMake(0, 0, 1, 1); [CATransaction commit]; &#125; &#125; _curImageHasContentsRect = hasContentsRect; // 若是 SpriteSheetImage，取第一帧的 contentsRect // 并定位到 image 中 contentsRect 对应的位置 if (hasContentsRect) &#123; CGRect rect = [((UIImage&lt;YYAnimatedImage&gt; *) newVisibleImage) animatedImageContentsRectAtIndex:0]; [self setContentsRect:rect forImage:newVisibleImage]; &#125; // 多帧图特殊处理 // 初始化属性 - totalLoop、_totalFrameCount 等 if (newImageFrameCount &gt; 1) &#123; [self resetAnimated]; _curAnimatedImage = newVisibleImage; _curFrame = newVisibleImage; _totalLoop = _curAnimatedImage.animatedImageLoopCount; _totalFrameCount = _curAnimatedImage.animatedImageFrameCount; [self calcMaxBufferCount]; &#125; [self setNeedsDisplay]; [self didMoved];&#125; 方法实现过程： 获取 imageType 和图像实例（image 或 images） 通过 protocol 的实现情况，判断是否是 SpriteSheetImage 若不是 SpriteSheetImage 且之前展示过 SpriteSheetImage，进行 layer 复位，且取消过程中的隐式动画 若是 SpriteSheetImage，取第一帧的 contentsRect，并定位到对应 image 的位置 多帧图的一些属性处理，调用 -resetAnimated 重置动画的配置项 调用 didMoved 来执行动画 动画过程- (void)didMoved &#123; if (self.autoPlayAnimatedImage) &#123; if(self.superview &amp;&amp; self.window) &#123; [self startAnimating]; &#125; else &#123; [self stopAnimating]; &#125; &#125;&#125; 会判断是否有 superView 及 window，都满足的情况下，开启动画。 解压过程前面 -resetAnimated 方法执行的过程中，会重置队列 _requestQueue。该队列的 maxConcurrentOperationCount 为 1，是一个串行队列。该队列作用是用来处理解压任务。 -resetAnimated 方法执行过程中会判断是否创建了定时器 _link，若未创建，则创建（关于定时器，放后面单独看）： _link = [CADisplayLink displayLinkWithTarget:[_YYImageWeakProxy proxyWithTarget:self] selector:@selector(step:)];// _runloopMode 为 NSRunLoopCommonModesif (_runloopMode) &#123; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:_runloopMode];&#125;_link.paused = YES; 看到会定时执行 -step: 方法，其内会判断当前 _requestQueue 是否无在执行的任务，如果没有加入新的 operation。该 operation 为 _YYAnimatedImageViewFetchOperation： if (!bufferIsFull &amp;&amp; _requestQueue.operationCount == 0) &#123; // if some work not finished, wait for next opportunity _YYAnimatedImageViewFetchOperation *operation = [_YYAnimatedImageViewFetchOperation new]; operation.view = self; operation.nextIndex = nextIndex; operation.curImage = image; [_requestQueue addOperation:operation];&#125; _YYAnimatedImageViewFetchOperation 继承自 NSOperation，重写了 main 来自定义解压任务。源码如下： - (void)main &#123; __strong YYAnimatedImageView *view = _view; if (!view) return; if ([self isCancelled]) return; view-&gt;_incrBufferCount++; if (view-&gt;_incrBufferCount == 0) [view calcMaxBufferCount]; if (view-&gt;_incrBufferCount &gt; (NSInteger)view-&gt;_maxBufferCount) &#123; view-&gt;_incrBufferCount = view-&gt;_maxBufferCount; &#125; NSUInteger idx = _nextIndex; NSUInteger max = view-&gt;_incrBufferCount &lt; 1 ? 1 : view-&gt;_incrBufferCount; NSUInteger total = view-&gt;_totalFrameCount; view = nil; for (int i = 0; i &lt; max; i++, idx++) &#123; @autoreleasepool &#123; if (idx &gt;= total) idx = 0; if ([self isCancelled]) break; __strong YYAnimatedImageView *view = _view; if (!view) break; LOCK_VIEW(BOOL miss = (view-&gt;_buffer[@(idx)] == nil)); if (miss) &#123; UIImage *img = [_curImage animatedImageFrameAtIndex:idx]; img = img.yy_imageByDecoded; if ([self isCancelled]) break; LOCK_VIEW(view-&gt;_buffer[@(idx)] = img ? img : [NSNull null]); view = nil; &#125; &#125; &#125;&#125; 核心代码为： UIImage *img = [_curImage animatedImageFrameAtIndex:idx];img = img.yy_imageByDecoded; -animatedImageFrameAtIndex: 方法调用过程中会触发 yy_imageByDecoded，会进行解码操作。作者为了保证解码成功，又进行了第二次的解码（yy_imageByDecoded 方法内部会判断如果已经解码，不会再进行解码）。 解码完成后进行缓存。 缓存机制我们可以看到 YYAnimatedImageView 中声明的关于缓存的私有变量： NSMutableDictionary *_buffer; ///&lt; frame bufferBOOL _bufferMiss; ///&lt; whether miss frame on last opportunityNSUInteger _maxBufferCount; ///&lt; maximum buffer countNSInteger _incrBufferCount; ///&lt; current allowed buffer count (will increase by step) 缓存的节点在解码的过程中，会将解码的内容赋值给 _buffer。 容量限制源码如下： // dynamically adjust buffer size for current memory.- (void)calcMaxBufferCount &#123; int64_t bytes = (int64_t)_curAnimatedImage.animatedImageBytesPerFrame; if (bytes == 0) bytes = 1024; int64_t total = _YYDeviceMemoryTotal(); int64_t free = _YYDeviceMemoryFree(); int64_t max = MIN(total * 0.2, free * 0.6); max = MAX(max, BUFFER_SIZE); // BUFFER_SIZE = 10MB if (_maxBufferSize) max = max &gt; _maxBufferSize ? _maxBufferSize : max; double maxBufferCount = (double)max / (double)bytes; if (maxBufferCount &lt; 1) maxBufferCount = 1; else if (maxBufferCount &gt; 512) maxBufferCount = 512; _maxBufferCount = maxBufferCount;&#125; 最大缓存容量是动态计算的： 设备允许容量 = min(总内存x0.2, 总空闲内存x0.6) 最大计算容量 = max(设备允许容量, BUFFER_SIZE) //BUFFER_SIZE=10MB 最大容量 = min(最大计算容量, 自定义最大容量) 清理机制在 resetAnimation 时会注册两个 Notification：内存警告、进入后台。 在应用进入后台时： 先取消全部异步的解压操作 计算下一帧的下标 移除不是下一帧的所有缓存，保证进入前台时，能及时显示下一帧 定时器 _link_link 是基于 CADisplayLink 创建的定时器，帧率刷新的特性适合用来处理帧率相关的 UI 逻辑。单独拿出来梳理，是因为作者使用了 _YYImageWeakProxy 类进行消息转发来避免循环应用。源码如下： /** A proxy used to hold a weak object. It can be used to avoid retain cycles, such as the target in NSTimer or CADisplayLink. */@interface _YYImageWeakProxy : NSProxy@property (nonatomic, weak, readonly) id target;- (instancetype)initWithTarget:(id)target;+ (instancetype)proxyWithTarget:(id)target;@end@implementation _YYImageWeakProxy- (instancetype)initWithTarget:(id)target &#123; _target = target; return self;&#125;+ (instancetype)proxyWithTarget:(id)target &#123; return [[_YYImageWeakProxy alloc] initWithTarget:target];&#125;- (id)forwardingTargetForSelector:(SEL)selector &#123; return _target;&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; void *null = NULL; [invocation setReturnValue:&amp;null];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [NSObject instanceMethodSignatureForSelector:@selector(init)];&#125;- (BOOL)respondsToSelector:(SEL)aSelector &#123; return [_target respondsToSelector:aSelector];&#125;- (BOOL)isEqual:(id)object &#123; return [_target isEqual:object];&#125;- (NSUInteger)hash &#123; return [_target hash];&#125;- (Class)superclass &#123; return [_target superclass];&#125;- (Class)class &#123; return [_target class];&#125;- (BOOL)isKindOfClass:(Class)aClass &#123; return [_target isKindOfClass:aClass];&#125;- (BOOL)isMemberOfClass:(Class)aClass &#123; return [_target isMemberOfClass:aClass];&#125;- (BOOL)conformsToProtocol:(Protocol *)aProtocol &#123; return [_target conformsToProtocol:aProtocol];&#125;- (BOOL)isProxy &#123; return YES;&#125;- (NSString *)description &#123; return [_target description];&#125;- (NSString *)debugDescription &#123; return [_target debugDescription];&#125;@end 消息转发过程： 若 _target 存在，向 _YYImageWeakProxy 实例发送消息，会正常转发给 target 在 _target 释放时，forwardingTargetForSelector: 重定向失败，会调用 methodSignatureForSelector: 来获取有效方法。 若未获取到有效方法，抛出异常 若获取到有效方法，调用 forwardInvocation: 进行消息转发。作者认为控制返回 null YYImageCoder该类主要包含： YYImageFrame 类（图片帧信息） YYImageDecoder 解码器 YYImageEncoder 编码器 解码过程描述： 将 CGImageRef 转化为位图 bitmap 先通过 CGBitmapContextCreate() 创建图片上下文 再通过 CGContextDrawImage() 将图片绘制到上下文 最后通过 CGBitmapContextCreateImage() 结合上下文生成位图 也通过 ImageIO 实现了渐进式解码。 多帧解码的过程中，会出现递归操作，作者选用了互斥锁 pthread_mutex_t。pthread_mutex_t 本身不支持递归，可以通过设置打开递归选项。 总结YYImage 可以理解为是基于 UIImage 的一个拓展。 功能上。一方面支持了更多的业务需求场景，如 webp 格式图片的展示。另一方面把图片的解码缓存，变为用户可控状态。我们可以根据自己的业务需求调整缓存的设定。 框架结构上。线程安全的处理、重叠模块的解耦都做的很棒。日常开发过程中，可以借鉴一些结构上的思路。 UIImage 加载、解码 bitmap、CA 框架绘制 imageNamed: imageWithData: 大图 4096x4096 最大纹理，老设备 OOM ImageIO 取图像元数据 WWDC18 iOS10 引入 UIGraphicsImageRenderer YYImage 框架 图像层 视图层 编解码 YYImage 重写 imageNamed 初始化信号量 _preloadedLock，保证_preloadedFrames 读写安全 _preloadedFrames 保存所有帧图像 YYFrameImage 帧动画 帧图片 + 显示时长 png、jpeg YYSpriteSheetImage SpriteSheet 动画 rect duration loopCount YYAnimatedImage 协议 图像展示原理相同，展示通过该协议来实现 @required @optional YYAnimatedImageView 展示上面的 Image 解码的图像 setImage/setHighlightedImage setAnimationImages/setHighlightedAnimationImages 根据 image type 拿到具体的 image 实例 拿到实例后，imageChange SpriteSheet 单独处理 重置 rect，取消隐式动画 frameCount &gt; 1，进行 resetAnimation resetAnimation 做的几件事 重置定时器（commonModes） 使用了 NSProxy 避免循环引用 添加 _YYAnimatedImageViewFetchOperation 进行预解码 继承自 NSOperation，重写了 main 来自定义解压任务（二次解压保险） 解码 image 时会进行 buffer 缓存 缓存容量计算公式 设备允许容量 = min(总内存x0.2, 总空闲内存x0.6) 最大计算容量 = max(设备允许容量, BUFFER_SIZE) //BUFFER_SIZE=10MB 最大容量 = min(最大计算容量, 自定义最大容量) 缓存清理 resetAnimation 注册两通知（内存警告、进入后台） 先取消全部异步解码操作 计算下一帧的下标 移除下一帧之外的所有缓存，以保证进入前台，可以立刻显示下一帧 YYImageCoder YYImageFrame YYImageDecoder 解码过程 将 CGImageRef 转为 bitmap 通过 CGBitmapContextCreate() 创建上下文 多帧解码过程中使用了 pthread_mutex_t，因为存在递归操作，这里使用了互斥锁","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"WWDC17 505 - Photos APIs 新特性","slug":"2017-08-30-wwdc17-505-whats-new-in-photos-apis","date":"2017-08-29T16:00:00.000Z","updated":"2021-01-12T10:09:26.370Z","comments":true,"path":"2017/08/30/2017-08-30-wwdc17-505-whats-new-in-photos-apis/","link":"","permalink":"https://blog.jonyfang.com/2017/08/30/2017-08-30-wwdc17-505-whats-new-in-photos-apis/","excerpt":"视频链接：WWDC 2017 Session 505 - What’s New in Photos APIs 本节要介绍的是 Photos APIs 的一些新特性。简单的概括有下面这几点内容： UIImagePickerController 的大幅优化 授权模式的改进 动图的支持 iCloud 照片图库的优化 照片项目的扩展 后续内容，会对这几个点依次展开。","text":"视频链接：WWDC 2017 Session 505 - What’s New in Photos APIs 本节要介绍的是 Photos APIs 的一些新特性。简单的概括有下面这几点内容： UIImagePickerController 的大幅优化 授权模式的改进 动图的支持 iCloud 照片图库的优化 照片项目的扩展 后续内容，会对这几个点依次展开。 UIImagePickerController 的大幅优化UIImagePickerController是系统提供的和相册及相机交互的一个类，通过这个类，你可以在应用中选择照片和视频。在 iOS 11 里，图片选择器有了许多的改进和新功能的引入。 隐私授权的改进一直以来，Apple 十分关注用户的隐私安全。所以，之前在任何情况下，如果获取 Photos 资源，都需要获取用户的授权才可以进行。正如下面弹窗这样，请求用户的授权。 正因为授权过程的存在，使得应用程序与用户之间产生了矛盾。对于用户而言，需要他们打开一级隐私，这不是用户想要的；而对于应用程序来说，应用在未获取权限的情况下，无法执行相应的程序和操作，即便它自身有很多优秀的功能，都会因为未授权而无法使用。 在 iOS 11 中，如果通过UIImagePickerController 访问相册资源，这个警告弹窗不会再出现，会直接进行程序运行。看到这里，你或许会问：那用户的隐私保护怎么办？ 首先需要介绍一下UIImagePickerController 新的授权模式。自 iOS 11 开始，UIImagePickerController成为了一个自动授权 API。也就是说，当应用程序要显示 API 的内容，将会是从一个自动处理的沙盒和安全环境中获取，应用不再访问用户的Photo Library。 并且，只有用户本人可以和UIImagePickerController UI进行互动。当用户做出一个选择，系统会取出选中的照片或视频，发送到应用中。这样就消除了前面提出的在应用中因为授权而产生的矛盾，同时这也让用户有了更高级别的隐私。因为不存在授权，也就不会再有请求授权。使用起来更为方便了。 元数据的获取更为方便Photos 拥有丰富的元数据(metadata)，内容包括创建日期、照片的格式，及一些其他不同类型的元数据。在 iOS 11 中，获取这些信息变得容易了很多。系统提供了一个全新的键值 UIImagePickerControllerImageURL，会包含所有UIImagePickerController的结果。我们可以使用这里的 URL，将对应数据读入应用并按照需要进行处理。该 URL 是文件 URL，指向一个应用中的临时文件，如果之后想对文件继续操作，建议把文件移动到更永久的文件路径中。 public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let imageURL = info[UIImagePickerControllerImageURL] as? URL &#123; print(imageURL) &#125;&#125; HEIF 图片格式的引入iOS 11 中，Photos 引入了一种新的图片格式HEIF。同时，Apple 意识到生态系统完全接受HEIF需要一段时间，考虑到新类型图片格式的兼容性。Apple 为UIIMagePickerController提供了一个新属性imageExportPresent，让兼容过程变得更为容易。 var imageExportPreset: UIImagePickerControllerImportExportPreset &#123; get set &#125;let imagePicker = UIImagePickerController() imagePicker.imageExportPreset = .compatible self.present(imagePicker, animated: true, completion: nil)let imagePicker = UIImagePickerController() imagePicker.imageExportPreset = .current self.present(imagePicker, animated: true, completion: nil) imageExportPresent拥有两种类型： .compatible (兼容模式) .current (当前模式) 在compatible (兼容模式)下，如果用户选中的源图片是HEIF 格式，系统会通过转换，提供一个 JPEG 格式的图片。当然，JPEG 是该属性的默认值，如果不需要有什么改变，就不用再做更多的事情。 如果，需要获取的照片格式与拍摄时的格式相同，只需把属性值设为current (当前模式)，这样就会得到与 Photo Library 里相同格式的图片，包括HEIF 格式。 视频文件的获取更为方便iOS 11 中，对视频选择的功能，也有了很好的改进。暂时把这部分内容放在一边，先来简单了解下AVFoundation。AVFoundation是 Apple 提供的框架，用于丰富编辑及照片播放。通过AVFoundation导出的素材可以拥有丰富的格式。 值得称赞的是，UIImagePickerController现在也有了类似的功能，引入了一个新属性videoExportPreset。 var videoExportPreset: String &#123; get set &#125; 你可以通过这个方法来告诉系统，你所选中的视频需要以哪种格式返回。这样，你就可以轻松得到预设格式的资源内容了。 我们来看一个例子： import AVFoundationlet imagePicker = UIImagePickerController() imagePicker.videoExportPreset = AVAssetExportPresetHighestQuality self.present(imagePicker, animated: true, completion: nil) 如上代码中，首先，导入AVFoundation；接着，创建一个UIIMagePickerController实例，并描述我们想要资源文件以哪种格式返回（这里我们请求的是最高品质）；之后显示选择器。 当用户做出选择时，无论是什么格式，系统都对其进行交叉编译，得到匹配格式，之后返回给用户。关于可用预设的完整清单，可以通过接口AVAssetExportSession查看。 照片和视频的保存有了新的隐私模式前面，通过一些巧妙的设计，在保护用户隐私的情况下，已经实现了无缝选取。实际上，iOS 11 也对图片和视频的保存做了很多的优化。 在 iOS 11 中，保存一张照片或一段视频到用户的图片库中，系统提供了一个全新的安全模型及权限级别。UIImagePickerController对于保存图片资源及视频资源分别提供了权限级别。一个是UIImageWriteToSavedPhotosAlbum，另一个是UISaveVideoAtPathToSavedPhotosAlbum。 public func UIImageWriteToSavedPhotosAlbum(_ image: UIImage, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?)public func UISaveVideoAtPathToSavedPhotosAlbum(_ videoPath: String, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?) 这两种方式都只会请求添加授权，对于用户来说添加授权是很小的要求。因为这个权限只允许添加内容到用户的 Photo Library，而不涉及到读取权限。所以，很大程度上，用户会愿意给出这个权限。 PHAsset 获取的改进我们来看一个例子： public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let asset = info[UIImagePickerControllerPHAsset] as? PHAsset &#123; print(asset) &#125;&#125; 上述代码中，我们实现了一个代理方法。在获得结果词典时，有了一个全新的键，键名为UIIMagePickerControllerPHAsset。取得该键的值，将会得到对应的资产对象，可以对其进行自由使用。 通过这些改变，增强了用户的隐私保护，也让UIIMagePickerController成为更强大而功能齐全的 API，满足了市面上大部分应用的需求。然而，有时会出现需要和照片框架进行更深入集成的需求，在这些场景下，Apple 推荐使用PhotoKit。 PhotoKit和照片相关的应用，一直以来是 App Store 里最受欢迎的一类。这一次，PhotoKit做了一些改进，可以让你写出拥有更棒用户体验的新功能。 Live Photo 介绍首先一起了解下Live Photo的效果。Live Photo 效果包含： 循环效果 弹跳效果 长曝光效果等 其中循环效果，是通过仔细分析视频帧，并无缝地和这些视频帧无止境循环缝合在一起；弹跳效果，它的工作原理和循环效果也是相似的；最后是长曝光效果，它将分析 Live Photo 的视频帧，创造令人惊艳的静物。 现存的PhotoKit媒体类型有这些： enum PHAssetMediaType : Int &#123; case unknown case image case video case audio &#125; struct PHAssetMediaSubtype : OptionSet &#123; static var photoPanorama static var photoHDR static var photoScreenshot static var photoLive static var photoDepthEffect static var videoStreamed static var videoHighFrameRate static var videoTimelapse &#125; 如果用户拍摄了一段视频，会想在应用中进行观看，并将拍摄的内容以视频方式使用。如果用户拍摄了一张Live Photo，同样会想要在应用中看到内容以Live Photo的方式呈现。为此，iOS 11 提供了三种媒体类型来实现对应目标： image video photoLive Live Photo效果比较复杂。为此，iOS 11 中引入了全新的PHAsset属性playbackStyle，让你可以简单实现Live Photo的播放。 class PHAsset : PHObject &#123; var playbackStyle: PHAssetPlaybackStyle &#123; get &#125;&#125;enum PHAssetPlaybackStyle : Int &#123; case unsupported case image case imageAnimated case livePhoto case video case videoLooping&#125; playbackStyle属性，是唯一可以用来查看和决定要使用什么样的图片管理器 API、用什么样的视图来表现、以及为该视图设置什么样的 UI 限制。同时，Apple 更新了 PhotoKit 示例应用，包含所有这些新的播放风格。这里介绍下其中的三种，它们和前面提到的Live Photo 效果相关。从imageAnimated开始。 Animated ImageimageManager.requestImageData(for: asset, options: options) &#123; (data, dataUTI, orientation, info) in // 使用示例项目中的 animatedImageView let animatedImage = AnimatedImage(data: data) animatedImageView.animatedImage = animatedImage&#125; iOS 11 有了一个期待已久的新功能。现在，在内置应用“照片”中支持了动画 GIF的播放。如果要在你的应用中播放 GIF，只需要从图像管理器请求图像数据，然后使用图像 IO 和 Core Graphics 进行播放。接下来是Live Photo。 Live PhotoimageManager.requestLivePhoto(for: asset, targetSize: pixelSize, contentMode: .aspectFill, options: options) &#123; (livePhoto, info) in // 使用示例项目中的 PHLivePhotoView livePhotoView.livePhoto = livePhoto&#125; Live Photos一直很受用户的关注，如何在应用中更好地呈现它们，非常重要，也非常简单。在如上的这个例子里，首先从图像管理器请求一张Live Photo，之后设置PHLivePhotoView。在你的应用里，用户可以通过轻触播放一张Live Photo，正如用户在内置“照片”应用里的操作一样。 Looping VideoswiftimageManager.requestPlayerItem(forVideo: asset, options: options) &#123; playerItem, info in DispatchQueue.main.async &#123; let player &#x3D; AVQueuePlayer() playerLooper &#x3D; AVPlayerLooper(player: player, templateItem: playerItem) playerLayer.player &#x3D; player player.play() &#125;&#125; 在今年所推出的视频循环中，既包括弹跳效果，也包括Live Photo的循环效果。现在，在你的应用里播放这些和播放普通视频非常相似。可以请求播放器项目，并使用AVFoundation播放，还可以使用AVPlayerLooper取得循环效果。 可见，表现用户的媒体变得更为轻便，以他们真正想表现的方式，你也可以在自己的应用中，对这些全新的媒体类型，更为创新地表现。 iCloud 照片图库的改进 “iCloud 照片图库”可以与“照片”应用完美搭配使用。当用户开启“iCloud 照片图库”时，用户的照片和视频会被安全上传到 iCloud 中，同时这些更改会同步到用户的其他设备中。自动上传 iCloud 操作的触发条件是，设备连接到 Wi-Fi 且电量充足。根据用户的网络情况，在所有设备和 iCloud.com 上看到同步照片和视频所需的时间可能会不同。 使用 iPhone 拍照的用户，也常会使用“照片”相关的第三方应用。这些用户，大致可以分为 3 类：轻度用户、中度爱好者和重度专业用户。对于重度用户而言，由于自身图库中有很多内容，在第一次使用应用时，需要加载大批量的照片，这个过程中会十分耗时。而且这种耗时的加载状态，会对应用的用户体验大打折扣。 在 iOS 11 中，针对如何更快速高效地操作“大型照片图库”这一点做了优化，后面的内容会依次展开描述。 创建一个用于测试的“大型照片图库”前面提到，如果图库中有大量内容，在应用加载数据时，会处于长时间的加载状态。而你如果想创建一个拥有大批量图片的图库，还是有些难度的。友好的是，Apple 为开发者提供了一个用户创建图库的示例应用：Photo Library Filler 。下载该应用并安装到测试设备，点击“Add Photos” 按钮，它便会迅速生成一个拥有大批量图片的图库供测试使用。 到这里，你就拥有了一个可用于测试的“大型照片图库”。 现在，如何从“照片图库”提取图片看下面这段代码：” value=”本节要介绍的是 Photos APIs 的一些新特性。简单的概括有下面这几点内容： UIImagePickerController 的大幅优化 授权模式的改进 动图的支持 iCloud 照片图库的优化 照片项目的扩展 后续内容，会对这几个点依次展开。 UIImagePickerController 的大幅优化UIImagePickerController是系统提供的和相册及相机交互的一个类，通过这个类，你可以在应用中选择照片和视频。在 iOS 11 里，图片选择器有了许多的改进和新功能的引入。 隐私授权的改进一直以来，Apple 十分关注用户的隐私安全。所以，之前在任何情况下，如果获取 Photos 资源，都需要获取用户的授权才可以进行。正如下面弹窗这样，请求用户的授权。 正因为授权过程的存在，使得应用程序与用户之间产生了矛盾。对于用户而言，需要他们打开一级隐私，这不是用户想要的；而对于应用程序来说，应用在未获取权限的情况下，无法执行相应的程序和操作，即便它自身有很多优秀的功能，都会因为未授权而无法使用。 在 iOS 11 中，如果通过UIImagePickerController 访问相册资源，这个警告弹窗不会再出现，会直接进行程序运行。看到这里，你或许会问：那用户的隐私保护怎么办？ 首先需要介绍一下UIImagePickerController 新的授权模式。自 iOS 11 开始，UIImagePickerController成为了一个自动授权 API。也就是说，当应用程序要显示 API 的内容，将会是从一个自动处理的沙盒和安全环境中获取，应用不再访问用户的Photo Library。 并且，只有用户本人可以和UIImagePickerController UI进行互动。当用户做出一个选择，系统会取出选中的照片或视频，发送到应用中。这样就消除了前面提出的在应用中因为授权而产生的矛盾，同时这也让用户有了更高级别的隐私。因为不存在授权，也就不会再有请求授权。使用起来更为方便了。 元数据的获取更为方便Photos 拥有丰富的元数据(metadata)，内容包括创建日期、照片的格式，及一些其他不同类型的元数据。在 iOS 11 中，获取这些信息变得容易了很多。系统提供了一个全新的键值 UIImagePickerControllerImageURL，会包含所有UIImagePickerController的结果。我们可以使用这里的 URL，将对应数据读入应用并按照需要进行处理。该 URL 是文件 URL，指向一个应用中的临时文件，如果之后想对文件继续操作，建议把文件移动到更永久的文件路径中。 public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let imageURL = info[UIImagePickerControllerImageURL] as? URL &#123; print(imageURL) &#125;&#125; HEIF 图片格式的引入iOS 11 中，Photos 引入了一种新的图片格式HEIF。同时，Apple 意识到生态系统完全接受HEIF需要一段时间，考虑到新类型图片格式的兼容性。Apple 为UIIMagePickerController提供了一个新属性imageExportPresent，让兼容过程变得更为容易。 var imageExportPreset: UIImagePickerControllerImportExportPreset &#123; get set &#125;let imagePicker = UIImagePickerController() imagePicker.imageExportPreset = .compatible self.present(imagePicker, animated: true, completion: nil)let imagePicker = UIImagePickerController() imagePicker.imageExportPreset = .current self.present(imagePicker, animated: true, completion: nil) imageExportPresent拥有两种类型： .compatible (兼容模式) .current (当前模式) 在compatible (兼容模式)下，如果用户选中的源图片是HEIF 格式，系统会通过转换，提供一个 JPEG 格式的图片。当然，JPEG 是该属性的默认值，如果不需要有什么改变，就不用再做更多的事情。 如果，需要获取的照片格式与拍摄时的格式相同，只需把属性值设为current (当前模式)，这样就会得到与 Photo Library 里相同格式的图片，包括HEIF 格式。 视频文件的获取更为方便iOS 11 中，对视频选择的功能，也有了很好的改进。暂时把这部分内容放在一边，先来简单了解下AVFoundation。AVFoundation是 Apple 提供的框架，用于丰富编辑及照片播放。通过AVFoundation导出的素材可以拥有丰富的格式。 值得称赞的是，UIImagePickerController现在也有了类似的功能，引入了一个新属性videoExportPreset。 var videoExportPreset: String &#123; get set &#125; 你可以通过这个方法来告诉系统，你所选中的视频需要以哪种格式返回。这样，你就可以轻松得到预设格式的资源内容了。 我们来看一个例子： import AVFoundationlet imagePicker = UIImagePickerController() imagePicker.videoExportPreset = AVAssetExportPresetHighestQuality self.present(imagePicker, animated: true, completion: nil) 如上代码中，首先，导入AVFoundation；接着，创建一个UIIMagePickerController实例，并描述我们想要资源文件以哪种格式返回（这里我们请求的是最高品质）；之后显示选择器。 当用户做出选择时，无论是什么格式，系统都对其进行交叉编译，得到匹配格式，之后返回给用户。关于可用预设的完整清单，可以通过接口AVAssetExportSession查看。 照片和视频的保存有了新的隐私模式前面，通过一些巧妙的设计，在保护用户隐私的情况下，已经实现了无缝选取。实际上，iOS 11 也对图片和视频的保存做了很多的优化。 在 iOS 11 中，保存一张照片或一段视频到用户的图片库中，系统提供了一个全新的安全模型及权限级别。UIImagePickerController对于保存图片资源及视频资源分别提供了权限级别。一个是UIImageWriteToSavedPhotosAlbum，另一个是UISaveVideoAtPathToSavedPhotosAlbum。 public func UIImageWriteToSavedPhotosAlbum(_ image: UIImage, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?)public func UISaveVideoAtPathToSavedPhotosAlbum(_ videoPath: String, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?) 这两种方式都只会请求添加授权，对于用户来说添加授权是很小的要求。因为这个权限只允许添加内容到用户的 Photo Library，而不涉及到读取权限。所以，很大程度上，用户会愿意给出这个权限。 PHAsset 获取的改进我们来看一个例子： public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let asset = info[UIImagePickerControllerPHAsset] as? PHAsset &#123; print(asset) &#125;&#125; 上述代码中，我们实现了一个代理方法。在获得结果词典时，有了一个全新的键，键名为UIIMagePickerControllerPHAsset。取得该键的值，将会得到对应的资产对象，可以对其进行自由使用。 通过这些改变，增强了用户的隐私保护，也让UIIMagePickerController成为更强大而功能齐全的 API，满足了市面上大部分应用的需求。然而，有时会出现需要和照片框架进行更深入集成的需求，在这些场景下，Apple 推荐使用PhotoKit。 PhotoKit和照片相关的应用，一直以来是 App Store 里最受欢迎的一类。这一次，PhotoKit做了一些改进，可以让你写出拥有更棒用户体验的新功能。 Live Photo 介绍首先一起了解下Live Photo的效果。Live Photo 效果包含： 循环效果 弹跳效果 长曝光效果等 其中循环效果，是通过仔细分析视频帧，并无缝地和这些视频帧无止境循环缝合在一起；弹跳效果，它的工作原理和循环效果也是相似的；最后是长曝光效果，它将分析 Live Photo 的视频帧，创造令人惊艳的静物。 现存的PhotoKit媒体类型有这些： enum PHAssetMediaType : Int &#123; case unknown case image case video case audio &#125; struct PHAssetMediaSubtype : OptionSet &#123; static var photoPanorama static var photoHDR static var photoScreenshot static var photoLive static var photoDepthEffect static var videoStreamed static var videoHighFrameRate static var videoTimelapse &#125; 如果用户拍摄了一段视频，会想在应用中进行观看，并将拍摄的内容以视频方式使用。如果用户拍摄了一张Live Photo，同样会想要在应用中看到内容以Live Photo的方式呈现。为此，iOS 11 提供了三种媒体类型来实现对应目标： image video photoLive Live Photo效果比较复杂。为此，iOS 11 中引入了全新的PHAsset属性playbackStyle，让你可以简单实现Live Photo的播放。 class PHAsset : PHObject &#123; var playbackStyle: PHAssetPlaybackStyle &#123; get &#125;&#125;enum PHAssetPlaybackStyle : Int &#123; case unsupported case image case imageAnimated case livePhoto case video case videoLooping&#125; playbackStyle属性，是唯一可以用来查看和决定要使用什么样的图片管理器 API、用什么样的视图来表现、以及为该视图设置什么样的 UI 限制。同时，Apple 更新了 PhotoKit 示例应用，包含所有这些新的播放风格。这里介绍下其中的三种，它们和前面提到的Live Photo 效果相关。从imageAnimated开始。 Animated ImageimageManager.requestImageData(for: asset, options: options) &#123; (data, dataUTI, orientation, info) in // 使用示例项目中的 animatedImageView let animatedImage = AnimatedImage(data: data) animatedImageView.animatedImage = animatedImage&#125; iOS 11 有了一个期待已久的新功能。现在，在内置应用“照片”中支持了动画 GIF的播放。如果要在你的应用中播放 GIF，只需要从图像管理器请求图像数据，然后使用图像 IO 和 Core Graphics 进行播放。接下来是Live Photo。 Live PhotoimageManager.requestLivePhoto(for: asset, targetSize: pixelSize, contentMode: .aspectFill, options: options) &#123; (livePhoto, info) in // 使用示例项目中的 PHLivePhotoView livePhotoView.livePhoto = livePhoto&#125; Live Photos一直很受用户的关注，如何在应用中更好地呈现它们，非常重要，也非常简单。在如上的这个例子里，首先从图像管理器请求一张Live Photo，之后设置PHLivePhotoView。在你的应用里，用户可以通过轻触播放一张Live Photo，正如用户在内置“照片”应用里的操作一样。 Looping VideoswiftimageManager.requestPlayerItem(forVideo: asset, options: options) &#123; playerItem, info in DispatchQueue.main.async &#123; let player &#x3D; AVQueuePlayer() playerLooper &#x3D; AVPlayerLooper(player: player, templateItem: playerItem) playerLayer.player &#x3D; player player.play() &#125;&#125; 在今年所推出的视频循环中，既包括弹跳效果，也包括Live Photo的循环效果。现在，在你的应用里播放这些和播放普通视频非常相似。可以请求播放器项目，并使用AVFoundation播放，还可以使用AVPlayerLooper取得循环效果。 可见，表现用户的媒体变得更为轻便，以他们真正想表现的方式，你也可以在自己的应用中，对这些全新的媒体类型，更为创新地表现。 iCloud 照片图库的改进 “iCloud 照片图库”可以与“照片”应用完美搭配使用。当用户开启“iCloud 照片图库”时，用户的照片和视频会被安全上传到 iCloud 中，同时这些更改会同步到用户的其他设备中。自动上传 iCloud 操作的触发条件是，设备连接到 Wi-Fi 且电量充足。根据用户的网络情况，在所有设备和 iCloud.com 上看到同步照片和视频所需的时间可能会不同。 使用 iPhone 拍照的用户，也常会使用“照片”相关的第三方应用。这些用户，大致可以分为 3 类：轻度用户、中度爱好者和重度专业用户。对于重度用户而言，由于自身图库中有很多内容，在第一次使用应用时，需要加载大批量的照片，这个过程中会十分耗时。而且这种耗时的加载状态，会对应用的用户体验大打折扣。 在 iOS 11 中，针对如何更快速高效地操作“大型照片图库”这一点做了优化，后面的内容会依次展开描述。 创建一个用于测试的“大型照片图库”前面提到，如果图库中有大量内容，在应用加载数据时，会处于长时间的加载状态。而你如果想创建一个拥有大批量图片的图库，还是有些难度的。友好的是，Apple 为开发者提供了一个用户创建图库的示例应用：Photo Library Filler 。下载该应用并安装到测试设备，点击“Add Photos” 按钮，它便会迅速生成一个拥有大批量图片的图库供测试使用。 到这里，你就拥有了一个可用于测试的“大型照片图库”。 现在，如何从“照片图库”提取图片看下面这段代码： let assets = PHAsset.fetchAssets(with: options) 这个方法用于从用户的“照片图库”提取图片，等号右侧用于提取资产，左侧为提取结果。 let options = PHFetchOptions()options.predicate = NSPredicate(format: &amp;quot;isFavorite = %d&amp;quot;, true)options.sortDescriptors = [NSSortDescriptor(key: &amp;quot;creationDate&amp;quot;, ascending: true)]let assets = PHAsset.fetchAssets(with: options) 在上述代码中，首先提取库里所有的 Asset，并进行筛选，筛选条件为isFavorite = true，之后按照对应的创建日期进行排序。这时，如果在这些自定义提取里发现耗时，那么简化这里的筛选条件会十分必要。不同的筛选方式，可能会意味着查询耗时的巨大差异。造成这种差异的原因是你的操作可能在数据库优化路径之外进行，同时又试图回到优化路径中，这样就产生了不同的耗时差距。 比这种自定义提取更好的是，尽可能避免这种操作。例如下面这个例子中，我们实际上提取的是用户最喜欢的智能相册。然后在智能相册里提取 Asset。这样既可以使用已有的关键字和排序描述符，还可以保证操作是在数据库优化路径中进行的。 let smartAlbums = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumFavorites, options: nil)let assets = PHAsset.fetchAssets(in: smartAlbums.firstObject, options: nil) 接着，看下返回结果。返回对象是一个PHFetchResult类型的对象。PHFetchResult 类型非常像一个数列，并且可以像数组一样来使用。但从内部实现来看，PHFetchResult和数列的工作机制还是完全不同的。并且这也是PhotoKit在大型图库操作方面，能够如此快速高效的原因之一。 我们来看看它的内部工作机制。 最开始，它只包含一个标识符列表。这意味着可以迅速返回对应的 Asset。但开始使用后，有更多工作必须执行。我们以一个枚举作为例子。 在这里，我们从索引 0 开始枚举。目前只有一个标识符，你还需要从数据库里提取元数据。为此创建一个PHAsset 对象，以便将 Asset 的元数据返回给你。 实际上，同时也创建了一个批处理。 当我们继续枚举时，索引 1 和 2实际已经在内存中了。枚举继续，它将访问硬盘，获取后续 Asset 的元数据。 在提取结果量级较小的情况下，这样的提取，并不会有太大的影响。但如果提取结果包含10万个 Asset。其中，每一批都需要占用几 kb 内存。如果是10w 批，那将会产生几百兆的内存用量。更糟糕的是，每一批都需要几毫秒的提取时间，如果有10w 批，就需要消耗 10s来枚举这样的一个大型提取结果。所以，应该尽量避免枚举操作。 在 PHFetchResult 中查询 Asset 更优的方式实际开发过程中，枚举操作总是可能会出现的。这里列举一个例子。现在，你需要从一个提取结果中查询一个Asset 的索引。 第一种方式，可以通过枚举该提取结果，通过“等于”比较返回的对象，来获取对应Asset 的索引。但是，枚举会非常耗时，所以更好的方法是通过另一种方式，使用高端 API。 如上，通过使用indexOfObject来进行 Asset 索引的查询。而indexOfObject方法内部是通过比较“对象标识符”，以找到符合条件的 Asset，这样就不会有附加的“硬盘访问”和“数据库提取”。进而避免了第一种方式中，因为枚举出现的耗时操作。同样的，对containtsObject也是如此。 照片项目的拓展一直以来，Apple 允许用户围绕照片创建丰富的有创意的项目。 PHProjectExtensionController 的引入现在，“照片”中添加了一个新的扩展。对应的，Xcode中也添加了一个新模板，开发者在自己的应用里可以轻松创建这些扩展。此外，“照片”应用会自动发现你的拓展，大大提高了扩展应用被用户知道的概率。不仅如此，Apple 为了让这些扩展更容易为用户所发现，给这些扩展应用提供了App Store的直接链接。该链接会打开App Store窗口，并自动显示支持该扩展的应用。 扩展只存在于开发者的应用内。对于开发者来说，如果你在 App Store 已经有了一个关于 Photos 相关的应用。此时，就可以将扩展代码移动到该扩展空间内，并加以利用。之后，添加一个视图控制器，并实现PHProjectExtensionController协议。一切就位，“照片应用”便可以发现你的扩展了。 在用户选择“扩展应用”，并用它创建一个项目时，&amp;quot;照片应用&amp;quot;会发送一些字节数据（PHProjectExtensionContext、PHProjectInfo）到对应的“扩展应用”。之后“照片应用”得到相应的返回结果，知道可以安装你的视图控制器。 过程中遵循的协议本身，对支持的项目类型有一个可选属性，可用于快速描述想让用户选择的选项。 optional public var supportedProjectTypes: [PHProjectTypeDescription] &#123; get &#125; 在实际使用过程中，用户既可以选择退出，也可以选择直接进入扩展。这些，在视图控制器里也有特定的函数方法。 public protocol PHProjectExtensionController : NSObjectProtocol &#123; //第一次使用该扩展创建项目时调用 public func beginProject(with extensionContext: PHProjectExtensionContext, projectInfo: PHProjectInfo, completion: @escaping (Error?) -&gt; Void) //每次用户回到以前创建的项目时调用 public func resumeProject(with extensionContext: PHProjectExtensionContext, completion: @escaping (Error?) -&gt; Void) //用户离开项目时调用 public func finishProject(completionHandler completion: @escaping () -&gt; Void) &#125; 通过第一个函数方法，我们可以得到上下文及项目详细。在第一次使用该扩展创建项目时，会调用该方法。 第二个函数方法，我们同样可以获得上下文。在每次用户回到扩展项目时，会调用该方法。 最后一个函数方法。如果用户在扩展项目内，当他们决定切换离开，会调用该函数。通过回调，你可以清理任何正在处理的数据，或是关闭任何让处理器忙碌的任务，或是正在执行的动画。 PHProjectExtensionContext 是什么在PHProjectExtensionContext这个容器里，包含两个非常重要的对象。一个是PHProject，另一个是PHPhotoLibrary。 PHProject 介绍// PHProject.h // Photosclass PHProject : PHAssetCollection &#123; var projectExtensionData: Data &#123; get &#125; &#125; PHProject本身只是PHAsset的一个子集。在子集中，创建PHProject，只添加了一个非常重要的属性projectExtensionData。可以用于保存任何你需要的数据，它是你正在使用的资产标识符的列表。也许是一些基本的布局信息或配置信息。同时属性projectExtensionData并不是为了照片缓存、缩略图之类的存在。因为这些功能，你可以快速地创建或把它们缓存到其他位置。为了它小而有用，抛开了这些功能，并且projectExtensionData被限制定为1 兆。因为这里面的信息，是一系列的字符串，所以1 兆大小已经足够了。即使用户不断创建项目，也不会增大用户的库。 PHProjectChangeRequest do &#123; let changeRequest = PHProjectChangeRequest(project: self.project) try self.library.performChangesAndWait &#123; changeRequest.projectExtensionData = NSKeyedArchiver.archivedData(withRootObject: cloudIdentifiers) &#125;&#125; catch &#123; print(&amp;quot;Failed to save project data: \\(error.localizedDescription)&amp;quot;) &#125; 设置数据非常简单。只需按上述实例化，实例化后，可以在Photo Library调用performChangesAndWait函数，在里面将数据设置成任何你想要的样式。 PHProjectInfo 介绍最高层的ProductInfo分为下面这几个区： 当看到这个构造时，可能会问，为什么数组里面还有数组。为什么是这种嵌套结构。但是如果想想“照片”应用里的“回忆”功能，会发现这些是有道理的。 “回忆”本身建立于大量资产之上，允许用户回忆时，可以切换“显示照片摘要”或“显示所有照片”。通过下面的一张图解，可以更清晰地描述为什么使用数组。 Section Contents数组是已排序数组。索引为 0的对象是最优内容，是资产集合最精炼的摘要；而数组末端的对象内容是最多的，包含了所有的照片数据。开发过程中，开发者需要根据具体的需求，选择性地使用。 PHCloudIdentifier 介绍PHCloudIdentifier是一个全新的概念。当你想把数据存到用户的Photo Library时，数据可能会被同步到用户其他的设备中。为了确保在保存的数据，合理地同步到其他设备中，iOS 11 推出了一个新对象PHCloudIdentifier。 //获取当前 Cloud IdentifierscloudIdentifiers += dataDict.value(forKey: &amp;quot;contentIdentifiers&amp;quot;) as! [PHCloudIdentifier]//转换为 Local Identifierslet localIdentifiers = self.library.localIdentifiers(for: cloudIdentifiers) 可以将它看做资产的全局标识符，但也并不像全局字符串那么简单，因为还需要处理同步和同步状态等情况。而这些复杂操作，系统已经为我们做了。你必须要做的唯一操作是，在提取之前，确保你的转换总是从全局标识符到本地标识符。可以通过PHPhotoLibrary里的方法来进行双向转换。 关于“视图布局”的改进 例如上述这种网格布局，对用户来说是很愉快的。如果开发者可以直接访问这个布局，不是会很棒吗？在 iOS 11 中，你确实可以进行访问了。 为了支持访问，系统首先确定了一个坐标系。 如果你查看“回忆”功能，会发现所有内容都被排列在一个由 4x3 单元格构成的网络中。但它是一个非正方形尺寸，不利于拓展。所以又有了下面这样的结构。 例如上述实例图片的的布局，可以被转化为一个由 20 个统一列组成的网络空间。确定了这个坐标系，就可以根据需求任意缩放。 并且，通过这个坐标系，也可以和系统互相传递坐标信息。例如上图的坐标为(0, 0, 8 , 9)。 PHProjectElement 介绍// PHProjectElementclass PHProjectElement : NSObject, NSSecureCoding &#123; //权重的范围是 0.0 - 1.0，默认为 0.5 var weight: Double &#123; get &#125; //元素在网络布局中的坐标 var placement: CGRect &#123; get &#125; &#125; 在Section Content里，系统提供了一组元素。所有元素都是PHProjectElement的子集。这里有两个非常重要的属性： placement（位置） weight（权重） “位置”属性，前面已经有所介绍了，这里介绍下“权重”属性。再次回到“回忆”功能，在大量资产中如果想确定最相关的照片，系统需要有自己的评分系统。这里，评分系统通过给每个元素一个权重值，来代表每个元素的重要性。权重值从0.0到1.0，默认值是0.5，也就是说，权重值为0.5的资产代表普通。 RegionsOfInterest 是什么var regionsOfInterest: [PHProjectRegionOfInterest] &#123; get &#125; 这里，有这样的一个概念，称为“兴趣区”。也就是这里的regionsOfInterest属性，这是PHProjectAssetElement所特有的。 在macOS API里，已经有很多方法，可以用来进行面部识别，从而寻找图片中的脸。但从这些方法无法知道这些脸的相关性。来看下面一副示例图： 你会注意到，这些脸部有对应的标识符。在不同的照片里相同的脸，会看到被标记为相同的标识符。这样的表示十分有趣。如果你正在处理动画、幻灯片等效果，这将非常有用。因为你现在可以真正把大集合中的图片位置彼此联系起来了。对于体验上的改进来说，这会是一个很棒的属性。 总结本节主要介绍了 Photos APIs 的新特性，主要包含了以下几点内容： 改进的授权模式 大幅优化的 UIImagePickerController 全新的图片格式 HEIF 大型图片库的创建 及为 Photos 创建项目扩展 回头来看开篇提出的三点疑问： 如何以一种不违反用户信任的方式获取及保存内容到相册？ 是否可以为 Photo Library 创建扩展内容？ 如何在应用中简单、高效地实现这些操作？ 这些，在新的 Photos APIs 里都有了相应的解决方案。综上可以看到 Photos 也在越来越完善，可扩展性越来越强，功能也在越来越强大。 相关资料 WWDC 2017 Session 505 - What’s New in Photos APIs WWDC 2017 Session 505 - Creating Large Photo Libraries for Testing 开发者文档 - Photos 开发者文档 - PhotosUI PhotoKit 示例应用 “ link_users=”{}” data-body=”本节要介绍的是 Photos APIs 的一些新特性。简单的概括有下面这几点内容： UIImagePickerController 的大幅优化 授权模式的改进 动图的支持 iCloud 照片图库的优化 照片项目的扩展 后续内容，会对这几个点依次展开。 UIImagePickerController 的大幅优化UIImagePickerController是系统提供的和相册及相机交互的一个类，通过这个类，你可以在应用中选择照片和视频。在 iOS 11 里，图片选择器有了许多的改进和新功能的引入。 隐私授权的改进一直以来，Apple 十分关注用户的隐私安全。所以，之前在任何情况下，如果获取 Photos 资源，都需要获取用户的授权才可以进行。正如下面弹窗这样，请求用户的授权。 正因为授权过程的存在，使得应用程序与用户之间产生了矛盾。对于用户而言，需要他们打开一级隐私，这不是用户想要的；而对于应用程序来说，应用在未获取权限的情况下，无法执行相应的程序和操作，即便它自身有很多优秀的功能，都会因为未授权而无法使用。 在 iOS 11 中，如果通过UIImagePickerController 访问相册资源，这个警告弹窗不会再出现，会直接进行程序运行。看到这里，你或许会问：那用户的隐私保护怎么办？ 首先需要介绍一下UIImagePickerController 新的授权模式。自 iOS 11 开始，UIImagePickerController成为了一个自动授权 API。也就是说，当应用程序要显示 API 的内容，将会是从一个自动处理的沙盒和安全环境中获取，应用不再访问用户的Photo Library。 并且，只有用户本人可以和UIImagePickerController UI进行互动。当用户做出一个选择，系统会取出选中的照片或视频，发送到应用中。这样就消除了前面提出的在应用中因为授权而产生的矛盾，同时这也让用户有了更高级别的隐私。因为不存在授权，也就不会再有请求授权。使用起来更为方便了。 元数据的获取更为方便Photos 拥有丰富的元数据(metadata)，内容包括创建日期、照片的格式，及一些其他不同类型的元数据。在 iOS 11 中，获取这些信息变得容易了很多。系统提供了一个全新的键值 UIImagePickerControllerImageURL，会包含所有UIImagePickerController的结果。我们可以使用这里的 URL，将对应数据读入应用并按照需要进行处理。该 URL 是文件 URL，指向一个应用中的临时文件，如果之后想对文件继续操作，建议把文件移动到更永久的文件路径中。 public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let imageURL = info[UIImagePickerControllerImageURL] as? URL &#123; print(imageURL) &#125;&#125; HEIF 图片格式的引入iOS 11 中，Photos 引入了一种新的图片格式HEIF。同时，Apple 意识到生态系统完全接受HEIF需要一段时间，考虑到新类型图片格式的兼容性。Apple 为UIIMagePickerController提供了一个新属性imageExportPresent，让兼容过程变得更为容易。 var imageExportPreset: UIImagePickerControllerImportExportPreset &#123; get set &#125;let imagePicker = UIImagePickerController() imagePicker.imageExportPreset = .compatible self.present(imagePicker, animated: true, completion: nil)let imagePicker = UIImagePickerController() imagePicker.imageExportPreset = .current self.present(imagePicker, animated: true, completion: nil) imageExportPresent拥有两种类型： .compatible (兼容模式) .current (当前模式) 在compatible (兼容模式)下，如果用户选中的源图片是HEIF 格式，系统会通过转换，提供一个 JPEG 格式的图片。当然，JPEG 是该属性的默认值，如果不需要有什么改变，就不用再做更多的事情。 如果，需要获取的照片格式与拍摄时的格式相同，只需把属性值设为current (当前模式)，这样就会得到与 Photo Library 里相同格式的图片，包括HEIF 格式。 视频文件的获取更为方便iOS 11 中，对视频选择的功能，也有了很好的改进。暂时把这部分内容放在一边，先来简单了解下AVFoundation。AVFoundation是 Apple 提供的框架，用于丰富编辑及照片播放。通过AVFoundation导出的素材可以拥有丰富的格式。 值得称赞的是，UIImagePickerController现在也有了类似的功能，引入了一个新属性videoExportPreset。 var videoExportPreset: String &#123; get set &#125; 你可以通过这个方法来告诉系统，你所选中的视频需要以哪种格式返回。这样，你就可以轻松得到预设格式的资源内容了。 我们来看一个例子： import AVFoundationlet imagePicker = UIImagePickerController() imagePicker.videoExportPreset = AVAssetExportPresetHighestQuality self.present(imagePicker, animated: true, completion: nil) 如上代码中，首先，导入AVFoundation；接着，创建一个UIIMagePickerController实例，并描述我们想要资源文件以哪种格式返回（这里我们请求的是最高品质）；之后显示选择器。 当用户做出选择时，无论是什么格式，系统都对其进行交叉编译，得到匹配格式，之后返回给用户。关于可用预设的完整清单，可以通过接口AVAssetExportSession查看。 照片和视频的保存有了新的隐私模式前面，通过一些巧妙的设计，在保护用户隐私的情况下，已经实现了无缝选取。实际上，iOS 11 也对图片和视频的保存做了很多的优化。 在 iOS 11 中，保存一张照片或一段视频到用户的图片库中，系统提供了一个全新的安全模型及权限级别。UIImagePickerController对于保存图片资源及视频资源分别提供了权限级别。一个是UIImageWriteToSavedPhotosAlbum，另一个是UISaveVideoAtPathToSavedPhotosAlbum。 public func UIImageWriteToSavedPhotosAlbum(_ image: UIImage, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?)public func UISaveVideoAtPathToSavedPhotosAlbum(_ videoPath: String, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?) 这两种方式都只会请求添加授权，对于用户来说添加授权是很小的要求。因为这个权限只允许添加内容到用户的 Photo Library，而不涉及到读取权限。所以，很大程度上，用户会愿意给出这个权限。 PHAsset 获取的改进我们来看一个例子： public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let asset = info[UIImagePickerControllerPHAsset] as? PHAsset &#123; print(asset) &#125;&#125; 上述代码中，我们实现了一个代理方法。在获得结果词典时，有了一个全新的键，键名为UIIMagePickerControllerPHAsset。取得该键的值，将会得到对应的资产对象，可以对其进行自由使用。 通过这些改变，增强了用户的隐私保护，也让UIIMagePickerController成为更强大而功能齐全的 API，满足了市面上大部分应用的需求。然而，有时会出现需要和照片框架进行更深入集成的需求，在这些场景下，Apple 推荐使用PhotoKit。 PhotoKit和照片相关的应用，一直以来是 App Store 里最受欢迎的一类。这一次，PhotoKit做了一些改进，可以让你写出拥有更棒用户体验的新功能。 Live Photo 介绍首先一起了解下Live Photo的效果。Live Photo 效果包含： 循环效果 弹跳效果 长曝光效果等 其中循环效果，是通过仔细分析视频帧，并无缝地和这些视频帧无止境循环缝合在一起；弹跳效果，它的工作原理和循环效果也是相似的；最后是长曝光效果，它将分析 Live Photo 的视频帧，创造令人惊艳的静物。 现存的PhotoKit媒体类型有这些： enum PHAssetMediaType : Int &#123; case unknown case image case video case audio &#125; struct PHAssetMediaSubtype : OptionSet &#123; static var photoPanorama static var photoHDR static var photoScreenshot static var photoLive static var photoDepthEffect static var videoStreamed static var videoHighFrameRate static var videoTimelapse &#125; 如果用户拍摄了一段视频，会想在应用中进行观看，并将拍摄的内容以视频方式使用。如果用户拍摄了一张Live Photo，同样会想要在应用中看到内容以Live Photo的方式呈现。为此，iOS 11 提供了三种媒体类型来实现对应目标： image video photoLive Live Photo效果比较复杂。为此，iOS 11 中引入了全新的PHAsset属性playbackStyle，让你可以简单实现Live Photo的播放。 class PHAsset : PHObject &#123; var playbackStyle: PHAssetPlaybackStyle &#123; get &#125;&#125;enum PHAssetPlaybackStyle : Int &#123; case unsupported case image case imageAnimated case livePhoto case video case videoLooping&#125; playbackStyle属性，是唯一可以用来查看和决定要使用什么样的图片管理器 API、用什么样的视图来表现、以及为该视图设置什么样的 UI 限制。同时，Apple 更新了 PhotoKit 示例应用，包含所有这些新的播放风格。这里介绍下其中的三种，它们和前面提到的Live Photo 效果相关。从imageAnimated开始。 Animated ImageimageManager.requestImageData(for: asset, options: options) &#123; (data, dataUTI, orientation, info) in // 使用示例项目中的 animatedImageView let animatedImage = AnimatedImage(data: data) animatedImageView.animatedImage = animatedImage&#125; iOS 11 有了一个期待已久的新功能。现在，在内置应用“照片”中支持了动画 GIF的播放。如果要在你的应用中播放 GIF，只需要从图像管理器请求图像数据，然后使用图像 IO 和 Core Graphics 进行播放。接下来是Live Photo。 Live PhotoimageManager.requestLivePhoto(for: asset, targetSize: pixelSize, contentMode: .aspectFill, options: options) &#123; (livePhoto, info) in // 使用示例项目中的 PHLivePhotoView livePhotoView.livePhoto = livePhoto&#125; Live Photos一直很受用户的关注，如何在应用中更好地呈现它们，非常重要，也非常简单。在如上的这个例子里，首先从图像管理器请求一张Live Photo，之后设置PHLivePhotoView。在你的应用里，用户可以通过轻触播放一张Live Photo，正如用户在内置“照片”应用里的操作一样。 Looping VideoswiftimageManager.requestPlayerItem(forVideo: asset, options: options) &#123; playerItem, info in DispatchQueue.main.async &#123; let player &#x3D; AVQueuePlayer() playerLooper &#x3D; AVPlayerLooper(player: player, templateItem: playerItem) playerLayer.player &#x3D; player player.play() &#125;&#125; 在今年所推出的视频循环中，既包括弹跳效果，也包括Live Photo的循环效果。现在，在你的应用里播放这些和播放普通视频非常相似。可以请求播放器项目，并使用AVFoundation播放，还可以使用AVPlayerLooper取得循环效果。 可见，表现用户的媒体变得更为轻便，以他们真正想表现的方式，你也可以在自己的应用中，对这些全新的媒体类型，更为创新地表现。 iCloud 照片图库的改进 “iCloud 照片图库”可以与“照片”应用完美搭配使用。当用户开启“iCloud 照片图库”时，用户的照片和视频会被安全上传到 iCloud 中，同时这些更改会同步到用户的其他设备中。自动上传 iCloud 操作的触发条件是，设备连接到 Wi-Fi 且电量充足。根据用户的网络情况，在所有设备和 iCloud.com 上看到同步照片和视频所需的时间可能会不同。 使用 iPhone 拍照的用户，也常会使用“照片”相关的第三方应用。这些用户，大致可以分为 3 类：轻度用户、中度爱好者和重度专业用户。对于重度用户而言，由于自身图库中有很多内容，在第一次使用应用时，需要加载大批量的照片，这个过程中会十分耗时。而且这种耗时的加载状态，会对应用的用户体验大打折扣。 在 iOS 11 中，针对如何更快速高效地操作“大型照片图库”这一点做了优化，后面的内容会依次展开描述。 创建一个用于测试的“大型照片图库”前面提到，如果图库中有大量内容，在应用加载数据时，会处于长时间的加载状态。而你如果想创建一个拥有大批量图片的图库，还是有些难度的。友好的是，Apple 为开发者提供了一个用户创建图库的示例应用：Photo Library Filler 。下载该应用并安装到测试设备，点击“Add Photos” 按钮，它便会迅速生成一个拥有大批量图片的图库供测试使用。 到这里，你就拥有了一个可用于测试的“大型照片图库”。 现在，如何从“照片图库”提取图片看下面这段代码： let assets = PHAsset.fetchAssets(with: options) 这个方法用于从用户的“照片图库”提取图片，等号右侧用于提取资产，左侧为提取结果。 let options = PHFetchOptions()options.predicate = NSPredicate(format: &amp;quot;isFavorite = %d&amp;quot;, true)options.sortDescriptors = [NSSortDescriptor(key: &amp;quot;creationDate&amp;quot;, ascending: true)]let assets = PHAsset.fetchAssets(with: options) 在上述代码中，首先提取库里所有的 Asset，并进行筛选，筛选条件为isFavorite = true，之后按照对应的创建日期进行排序。这时，如果在这些自定义提取里发现耗时，那么简化这里的筛选条件会十分必要。不同的筛选方式，可能会意味着查询耗时的巨大差异。造成这种差异的原因是你的操作可能在数据库优化路径之外进行，同时又试图回到优化路径中，这样就产生了不同的耗时差距。 比这种自定义提取更好的是，尽可能避免这种操作。例如下面这个例子中，我们实际上提取的是用户最喜欢的智能相册。然后在智能相册里提取 Asset。这样既可以使用已有的关键字和排序描述符，还可以保证操作是在数据库优化路径中进行的。 let smartAlbums = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumFavorites, options: nil)let assets = PHAsset.fetchAssets(in: smartAlbums.firstObject, options: nil) 接着，看下返回结果。返回对象是一个PHFetchResult类型的对象。PHFetchResult 类型非常像一个数列，并且可以像数组一样来使用。但从内部实现来看，PHFetchResult和数列的工作机制还是完全不同的。并且这也是PhotoKit在大型图库操作方面，能够如此快速高效的原因之一。 我们来看看它的内部工作机制。 最开始，它只包含一个标识符列表。这意味着可以迅速返回对应的 Asset。但开始使用后，有更多工作必须执行。我们以一个枚举作为例子。 在这里，我们从索引 0 开始枚举。目前只有一个标识符，你还需要从数据库里提取元数据。为此创建一个PHAsset 对象，以便将 Asset 的元数据返回给你。 实际上，同时也创建了一个批处理。 当我们继续枚举时，索引 1 和 2实际已经在内存中了。枚举继续，它将访问硬盘，获取后续 Asset 的元数据。 在提取结果量级较小的情况下，这样的提取，并不会有太大的影响。但如果提取结果包含10万个 Asset。其中，每一批都需要占用几 kb 内存。如果是10w 批，那将会产生几百兆的内存用量。更糟糕的是，每一批都需要几毫秒的提取时间，如果有10w 批，就需要消耗 10s来枚举这样的一个大型提取结果。所以，应该尽量避免枚举操作。 在 PHFetchResult 中查询 Asset 更优的方式实际开发过程中，枚举操作总是可能会出现的。这里列举一个例子。现在，你需要从一个提取结果中查询一个Asset 的索引。 第一种方式，可以通过枚举该提取结果，通过“等于”比较返回的对象，来获取对应Asset 的索引。但是，枚举会非常耗时，所以更好的方法是通过另一种方式，使用高端 API。 如上，通过使用indexOfObject来进行 Asset 索引的查询。而indexOfObject方法内部是通过比较“对象标识符”，以找到符合条件的 Asset，这样就不会有附加的“硬盘访问”和“数据库提取”。进而避免了第一种方式中，因为枚举出现的耗时操作。同样的，对containtsObject也是如此。 照片项目的拓展一直以来，Apple 允许用户围绕照片创建丰富的有创意的项目。 PHProjectExtensionController 的引入现在，“照片”中添加了一个新的扩展。对应的，Xcode中也添加了一个新模板，开发者在自己的应用里可以轻松创建这些扩展。此外，“照片”应用会自动发现你的拓展，大大提高了扩展应用被用户知道的概率。不仅如此，Apple 为了让这些扩展更容易为用户所发现，给这些扩展应用提供了App Store的直接链接。该链接会打开App Store窗口，并自动显示支持该扩展的应用。 扩展只存在于开发者的应用内。对于开发者来说，如果你在 App Store 已经有了一个关于 Photos 相关的应用。此时，就可以将扩展代码移动到该扩展空间内，并加以利用。之后，添加一个视图控制器，并实现PHProjectExtensionController协议。一切就位，“照片应用”便可以发现你的扩展了。 在用户选择“扩展应用”，并用它创建一个项目时，&amp;quot;照片应用&amp;quot;会发送一些字节数据（PHProjectExtensionContext、PHProjectInfo）到对应的“扩展应用”。之后“照片应用”得到相应的返回结果，知道可以安装你的视图控制器。 过程中遵循的协议本身，对支持的项目类型有一个可选属性，可用于快速描述想让用户选择的选项。 optional public var supportedProjectTypes: [PHProjectTypeDescription] &#123; get &#125; 在实际使用过程中，用户既可以选择退出，也可以选择直接进入扩展。这些，在视图控制器里也有特定的函数方法。 public protocol PHProjectExtensionController : NSObjectProtocol &#123; //第一次使用该扩展创建项目时调用 public func beginProject(with extensionContext: PHProjectExtensionContext, projectInfo: PHProjectInfo, completion: @escaping (Error?) -&gt; Void) //每次用户回到以前创建的项目时调用 public func resumeProject(with extensionContext: PHProjectExtensionContext, completion: @escaping (Error?) -&gt; Void) //用户离开项目时调用 public func finishProject(completionHandler completion: @escaping () -&gt; Void) &#125; 通过第一个函数方法，我们可以得到上下文及项目详细。在第一次使用该扩展创建项目时，会调用该方法。 第二个函数方法，我们同样可以获得上下文。在每次用户回到扩展项目时，会调用该方法。 最后一个函数方法。如果用户在扩展项目内，当他们决定切换离开，会调用该函数。通过回调，你可以清理任何正在处理的数据，或是关闭任何让处理器忙碌的任务，或是正在执行的动画。 PHProjectExtensionContext 是什么在PHProjectExtensionContext这个容器里，包含两个非常重要的对象。一个是PHProject，另一个是PHPhotoLibrary。 PHProject 介绍// PHProject.h // Photosclass PHProject : PHAssetCollection &#123; var projectExtensionData: Data &#123; get &#125; &#125; PHProject本身只是PHAsset的一个子集。在子集中，创建PHProject，只添加了一个非常重要的属性projectExtensionData。可以用于保存任何你需要的数据，它是你正在使用的资产标识符的列表。也许是一些基本的布局信息或配置信息。同时属性projectExtensionData并不是为了照片缓存、缩略图之类的存在。因为这些功能，你可以快速地创建或把它们缓存到其他位置。为了它小而有用，抛开了这些功能，并且projectExtensionData被限制定为1 兆。因为这里面的信息，是一系列的字符串，所以1 兆大小已经足够了。即使用户不断创建项目，也不会增大用户的库。 PHProjectChangeRequest do &#123; let changeRequest = PHProjectChangeRequest(project: self.project) try self.library.performChangesAndWait &#123; changeRequest.projectExtensionData = NSKeyedArchiver.archivedData(withRootObject: cloudIdentifiers) &#125;&#125; catch &#123; print(&amp;quot;Failed to save project data: \\(error.localizedDescription)&amp;quot;) &#125; 设置数据非常简单。只需按上述实例化，实例化后，可以在Photo Library调用performChangesAndWait函数，在里面将数据设置成任何你想要的样式。 PHProjectInfo 介绍最高层的ProductInfo分为下面这几个区： 当看到这个构造时，可能会问，为什么数组里面还有数组。为什么是这种嵌套结构。但是如果想想“照片”应用里的“回忆”功能，会发现这些是有道理的。 “回忆”本身建立于大量资产之上，允许用户回忆时，可以切换“显示照片摘要”或“显示所有照片”。通过下面的一张图解，可以更清晰地描述为什么使用数组。 Section Contents数组是已排序数组。索引为 0的对象是最优内容，是资产集合最精炼的摘要；而数组末端的对象内容是最多的，包含了所有的照片数据。开发过程中，开发者需要根据具体的需求，选择性地使用。 PHCloudIdentifier 介绍PHCloudIdentifier是一个全新的概念。当你想把数据存到用户的Photo Library时，数据可能会被同步到用户其他的设备中。为了确保在保存的数据，合理地同步到其他设备中，iOS 11 推出了一个新对象PHCloudIdentifier。 //获取当前 Cloud IdentifierscloudIdentifiers += dataDict.value(forKey: &amp;quot;contentIdentifiers&amp;quot;) as! [PHCloudIdentifier]//转换为 Local Identifierslet localIdentifiers = self.library.localIdentifiers(for: cloudIdentifiers) 可以将它看做资产的全局标识符，但也并不像全局字符串那么简单，因为还需要处理同步和同步状态等情况。而这些复杂操作，系统已经为我们做了。你必须要做的唯一操作是，在提取之前，确保你的转换总是从全局标识符到本地标识符。可以通过PHPhotoLibrary里的方法来进行双向转换。 关于“视图布局”的改进 例如上述这种网格布局，对用户来说是很愉快的。如果开发者可以直接访问这个布局，不是会很棒吗？在 iOS 11 中，你确实可以进行访问了。 为了支持访问，系统首先确定了一个坐标系。 如果你查看“回忆”功能，会发现所有内容都被排列在一个由 4x3 单元格构成的网络中。但它是一个非正方形尺寸，不利于拓展。所以又有了下面这样的结构。 例如上述实例图片的的布局，可以被转化为一个由 20 个统一列组成的网络空间。确定了这个坐标系，就可以根据需求任意缩放。 并且，通过这个坐标系，也可以和系统互相传递坐标信息。例如上图的坐标为(0, 0, 8 , 9)。 PHProjectElement 介绍// PHProjectElementclass PHProjectElement : NSObject, NSSecureCoding &#123; //权重的范围是 0.0 - 1.0，默认为 0.5 var weight: Double &#123; get &#125; //元素在网络布局中的坐标 var placement: CGRect &#123; get &#125; &#125; 在Section Content里，系统提供了一组元素。所有元素都是PHProjectElement的子集。这里有两个非常重要的属性： placement（位置） weight（权重） “位置”属性，前面已经有所介绍了，这里介绍下“权重”属性。再次回到“回忆”功能，在大量资产中如果想确定最相关的照片，系统需要有自己的评分系统。这里，评分系统通过给每个元素一个权重值，来代表每个元素的重要性。权重值从0.0到1.0，默认值是0.5，也就是说，权重值为0.5的资产代表普通。 RegionsOfInterest 是什么var regionsOfInterest: [PHProjectRegionOfInterest] &#123; get &#125; 这里，有这样的一个概念，称为“兴趣区”。也就是这里的regionsOfInterest属性，这是PHProjectAssetElement所特有的。 在macOS API里，已经有很多方法，可以用来进行面部识别，从而寻找图片中的脸。但从这些方法无法知道这些脸的相关性。来看下面一副示例图： 你会注意到，这些脸部有对应的标识符。在不同的照片里相同的脸，会看到被标记为相同的标识符。这样的表示十分有趣。如果你正在处理动画、幻灯片等效果，这将非常有用。因为你现在可以真正把大集合中的图片位置彼此联系起来了。对于体验上的改进来说，这会是一个很棒的属性。 总结本节主要介绍了 Photos APIs 的新特性，主要包含了以下几点内容： 改进的授权模式 大幅优化的 UIImagePickerController 全新的图片格式 HEIF 大型图片库的创建 及为 Photos 创建项目扩展 回头来看开篇提出的三点疑问： 如何以一种不违反用户信任的方式获取及保存内容到相册？ 是否可以为 Photo Library 创建扩展内容？ 如何在应用中简单、高效地实现这些操作？ 这些，在新的 Photos APIs 里都有了相应的解决方案。综上可以看到 Photos 也在越来越完善，可扩展性越来越强，功能也在越来越强大。 相关资料 WWDC 2017 Session 505 - What’s New in Photos APIs WWDC 2017 Session 505 - Creating Large Photo Libraries for Testing 开发者文档 - Photos 开发者文档 - PhotosUI PhotoKit 示例应用","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://blog.jonyfang.com/categories/WWDC/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://blog.jonyfang.com/tags/WWDC/"}]},{"title":"HTTP 和 HTTPS","slug":"2016-05-15-http-and-https","date":"2016-05-14T16:00:00.000Z","updated":"2021-01-12T10:03:10.555Z","comments":true,"path":"2016/05/15/2016-05-15-http-and-https/","link":"","permalink":"https://blog.jonyfang.com/2016/05/15/2016-05-15-http-and-https/","excerpt":"","text":"OSI 七层模型OSI（Open System Interconnection），由底层到高层分别为： 物理层 数据链路层 网络层 传输层：TCP/UDP 会话层 表示层 应用层：HTTP TCP/UDPTCPTCP 中连接的建立需要三次握手，在通信结束时断开连接需要四次挥手。一个连接的建立与断开，正常过程至少需要来回送 7 个包才能完成。 建立 TCP 连接时的三次握手： 客户端向服务器发送一个 SYN（synchronous）,客户端进入 SYN_SEND 状态 服务器收到 SYN 包后，服务器进入 SYN_RECV 状态，发出 SYN+ACK（Acknowledgement） 客户端收到 SYN+ACK 后发出 ACK 确认给服务器,客户端进入 ESTABLISH 状态。 服务器收到 ACK 后，服务器进入 ESTABLISH 状态。 建立连接后，传输数据。 断开 TCP 连接时的四次挥手： 客户端发送发送一个 FIN，等待服务器返回 ACK 和 FIN，客户端进入 FIN_WAIT_1 状态； 服务器接收 FIN，发出一个收到 FIN 的 ACK 确认，服务器进入 Close Wait 状态； 客户端收到 ACK，继续等待服务器的 FIN，客户端进入 FIN_WAIT_2 状态； 服务器发送 FIN，服务器等待客户端收到 FIN 的 ACK，服务器进入 LAST_ACK 状态； 客户端收到 FIN，发出 ACK，客户端进入 TIME_WAIT 状态（2MSL等待状态）；等到 2MSL 后，客户端进入 CLOSE 状态 服务器接收 ACK，服务器进入 CLOSE 状态； 连接断开。 UDPUDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。 特点： 无需建立连接（减少延迟） 实现简单：无需维护连接状态 头部开销小 没有拥塞控制：应用可以更好的控制发送时间和发送速率 TCP 与 UDP 的区别 TCP 面向连接；UDP 是无连接的，即发送数据之前不需要建立连接； TCP 提供可靠的服务。即通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP首部开销 20 字节；UDP 的首部开销小，只有 8 个字节 SocketSocket 是对 TCP/IP 协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过 Socket，我们才能使用 TCP/IP 协议。 在 socket 编程中，客户端执行 connect() 时,将触发三次握手。在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 Socket 连接与 HTTP 连接的不同。通常情况下 Socket 连接是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但实际应用中，客户端到服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断开，因此需要通过轮询告诉网络，该连接处于活跃状态。 而 HTTP 连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。 长连接在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。 连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。 每个 TCP 连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完成后都不断开，下次处理时直接发送数据包就可以了，不用建立 TCP 连接。 短连接指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接 连接→数据传输→关闭连接； HTTP一次完整的 HTTP 请求过程： 从 TCP 三次握手建立连接成功后开始 客户端按指定格式向服务端发送 HTTP 请求 服务端接受请求后，解析 HTTP 请求，处理完业务逻辑，返回一个 HTTP 响应给客户端 HTTP 的响应内容有标准的格式 HTTP 请求报文 一个 HTTP 请求报文组成部分有： 请求行：请求方法（GET/POST/DELETE/PUT/HEAD）、URL 路径、HTTP 的版本号 请求头部：缓存、客户端信息等 空行 请求数据 请求方法： HTTP 1.0 定义的方法： GET：请求指定的页面信息，并返回实体主体。 HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 POST：向指定资源提交数据进行处理请求（修改）。数据被包含在请求体中 HTTP 1.1 新增的方法： PUT：从客户端向服务器传送的数据取代指定的文档的内容。 Delete：请求服务器删除指定的页面。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：预留给能够将连接改为管道方式的代理服务器。 OPTIONS：允许客户端查看服务器的性能。 HTTP 返回报文 一个 HTTP 返回报文组成部分有： 状态行：有 HTTP 协议版本号，状态码和状态说明 响应头部 空行 响应包体 状态码： 200：请求成功 301：被请求的资源已永久移动到新位置。服务器返回此响应（GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 404：没有找到 405：方法不允许 408：请求超时 500：服务器内部错误 HTTP 长连接HTTP1.1 开始，默认 TCP 保持长连接，即任意一端没有提出断开连接，则会一直保持连接状态。一次长连接可进行多次请求和响应，这样可以减少建议连接和断开连接的开销，减少服务器负载，加快 HTTP 请求和响应。 CookiesHTTP 是无状态协议，但有时客户端与服务端需要保持某些状态，于是引入 Cookie 技术。Cookie 是通过在请求和响应报文中写入 Cookie 信息来控制客户端状态。 Cookie 根据从服务端发送的响应报文中的一个 Set-Cookie 头部信息，通知客户端来保持 Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入 Cookie 后发送出去。 服务端发现客户端发送来的 Cookie 后，会去检查这是从哪个客户端发来的连接请求，对比服务器记录，得到状态信息。 Session在服务端保持状态的方案。 HTTPSHTTPS 从最终的数据解析角度，与 HTTP 没有任何的区别。HTTPS 是将 HTTP 协议数据包放到 SSL/TSL层（应用层）加密后，在 TCP/IP 层组成 IP 数据包去传输，以保证传输数据的安全。 对于接收端，在 SSL/TSL 将接收的数据包解密后，将数据传给 HTTP 协议层，就变成了普通的 HTTP 数据。其中 HTTP 和 SSL/TSL 都处于 OSI 模型的应用层。 HTTP 的不足 通信使用明文，内容容易被窃听 不验证通信双方的身份，有可能遭遇伪装 无法证明报文的完整性，有可能遭到篡改 对称加密和非对称加密对称加密：在加密和解密时使用同一个秘钥。 非对称加密：需要一对公钥和私钥，如果通过公钥对数据进行加密，只能通过对应的私钥解密；如果通过私钥对数据进行加密，则只能通过对应的公钥来解密。 SSL/TSL主要交换三个信息： 数字证书该证书包含了公钥等信息，一般由服务器发送给客户端，接收方通过验证这个证书是不是有信赖的 CA 签发，或与本地的证书相对比来判断证书是否可信。如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证。 三个随机数这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的对话秘钥。 先从客户端发送第一个随机数 N1 之后服务器返回第二个 N2（同时发送证书给客户端），两个随机数都是明文的； 而第三个随机数 N3，是客户端通过数字证书的公钥进行非对称加密得到的，发送给服务端。 服务端通过自己的私钥解密得到 N3 这是服务端和客户端都有个三个随机数 N1+N2+N3，两端通过这三个随机数来生成对话秘钥，之后的通信使用这个对话密钥来进行对称加密解密 过程中服务端的私钥始终在服务端，没有经历过网络传输，这样私钥不会被泄露，保证了数据的安全 完整过程如下图： 加密通信协议客户端和服务端商量使用哪一种加密方式，若两者支持的加密方式不匹配，则无法进行通信。 为什么随机数要有三个？ 由于 SSL/TSL 的设计，假设某个客户端提供的随机数不随机，会大大增加对话密钥被破解的风险，而通过 3 个随机数得到的对话密钥，很大程度上保证了随机数的随机性，以此来保证生成的对话密钥的安全性。 HTTPS 抓包原理 抓包程序将服务器返回的证书截获 之后给客户端返回一个抓包程序的证书 客户端发送的数据使用抓包程序给的证书生成的密钥加密 抓包程序得到客户端发送的数据，抓包程序用自己的证书解密出来，再用服务器证书加密 抓包程序再把数据发送给服务器 总结 OSI 七层模型 TCP 3 次握手（SYN + ACK） TCP 4 次挥手（FIN + ACK） UDP（一对多、不需要建立连接） Socket（对 TCP/IP 的封装、connect()、close()、轮询保持活跃） HTTP TCP 握手建立连接 HTTP 请求 返回 HTTP 响应 HTTP 请求报文 请求行（请求方法、URL、HTTP 版本等） 请求头（缓存、客户端信息等） 空行 请求体 请求方法： HTTP 1.0 GET HEAD POST HTTP 1.1 PUT DELETE CONNECT OPTIONS HTTP 返回报文 状态行（HTTP 版本、状态码、状态说明） 响应头 空行 响应体 状态码： 200 301 新位置 404 没找到 405 方法不允许 408 请求超时 500 服务器内部错误 cookie &amp; session HTTP 无状态 Set-Cookie 开启 客户端发请求带 cookie 服务器检查 cookie HTTPS HTTP 不足 明文，窃听 不验证身份，伪装 不保证报文完整，篡改 原理 通过 SSL/TSL（应用层）加密 HTTP 协议数据包 再用 TCP/IP 组成 IP 数据包传输 除了加密解密过程，其他和 HTTP 一样 SSL/TSL 数字证书 三个随机数 N1、N2（+公钥）、N3 加密通信协议确定 HTTPS 抓包原理 抓包程序截获服务器证书 给客户端自己的证书 客户端按该证书公钥加密 抓包软件收到客户端加密数据，自己解密 再用服务器证书加密 发给服务器","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"}]},{"title":"Objc Tips","slug":"2016-04-03-objc-tips","date":"2016-04-02T16:00:00.000Z","updated":"2021-01-07T06:39:35.377Z","comments":true,"path":"2016/04/03/2016-04-03-objc-tips/","link":"","permalink":"https://blog.jonyfang.com/2016/04/03/2016-04-03-objc-tips/","excerpt":"总结记录 Objective-C 使用过程中一些 Tips。","text":"总结记录 Objective-C 使用过程中一些 Tips。 NS_ENUM 和 NS_OPTIONStypedef NS_ENUM(NSInteger, UIViewAnimationCurve) &#123; UIViewAnimationCurveEaseInOut, // slow at beginning and end UIViewAnimationCurveEaseIn, // slow at beginning UIViewAnimationCurveEaseOut, // slow at end UIViewAnimationCurveLinear,&#125;; typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5&#125;;// 用法UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;// 转换为二进制计算UIViewAutoresizing resizing = 000010 | 010000 = 010010// 通过 &amp; 判断是否满足条件之一// resizing &amp; UIViewAutoresizingFlexibleWidth // -&gt; 010010 &amp; 000010 = 000010if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123; // UIViewAutoresizingFlexibleWidth is set&#125; NS_OPTIONS 可以同时选择多个枚举值，使用了移位运算来保证相加结果的唯一性。简而言之，NS_ENUM 在互斥环境下使用；NS_OPTIONS 在多选情况下使用。 简介接口设计模板typedef NS_ENUM(NSInteger, UserSex) &#123; UserSexMale, UserSexFemale&#125;;@interface DIYUser : NSObject&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readwrite, assign) UserSex sex;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(UserSex)sex;+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(UserSex)sex;@end weak 和 assign 对比什么情况下使用 weak？ 用来避免循环引用 OBOutlet 默认为 weak 与 assign 的区别 weak 为该属性定义了一种非拥有关系，不影响引用计数，在属性所指对象销毁时，属性值也会自动置为 nil assign 用来修饰基础类型变量（如 CGFloat、NSInteger） assign 可用于非 OC 对象，weak 必须用于 OC 对象 weak 的实现原理weak 有两种作用： 被 weak 修饰符修饰的弱引用除了不会增加对象的引用计数外 在引用对象被释放后，这个弱引用会自动失效并置为 nil 实现原理 源码入口 objc_initWeak() 查看对象是否有效，无效置空 调用 storeWeak storeWeak 核心方法 weak_unregister_no_lock 和 weak_register_no_lock 都是对 SideTable 的实例进行操作 SideTable 内含有 weak_table_t，是 oc 中 weak 的核心数据结构 weak 表通过哈希表实现 通过目标对象的地址作为 key 检索得到对应弱引用变量地址 需要注意：一个 key 可能对应多个弱引用变量地址，放存放在 weak_entry weak_register_no_lock 先校验是否满足校验条件（计数方式、是否在析构，是否能弱引用） 通过弱引用对象的地址，在 weak_table 查找 weak_entry 找到，在 weak_entry 中的 referrers 添加新的弱引用地址 若未找到，新建 weak_entry 并添加 数组中 referrers 起始为静态数组，如果在操作过程中发现静态数组空间不够用切换为动态数组，如果动态数组超过总空间 3/4，扩容一倍 weak_unregister_no_lock 根据对象地址，找出 weak_entry 删除 weak_entry 中的弱引用地址 如果最后发现 weak_entry 空了，从 weak_table 移除 自动置为 nil 底层触发 clearDeallocating 方法 先校验对象是否满足弱引用 dealloc 对象 dealloc 时，通过 this 指针（对象指针），找到 SideTable。再通过对象地址在 SideTable 上找到所有的弱引用指针，逐个置 nil atomic 和 nonatomicatomic 属性使用了互斥锁。一般情况下不适用 atomic，因为并不能保证线程安全，若要实现线程安全。 如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，则即使声明为 atomic，也还是会读到不同的属性值。 copy 和 mutableCopyNSString、NSArray、NSDictionary 常用 copy。因为各自对应了可变类型 NSMutableString、NSMutableArray、NSMutableDictionary，防止内容在不知情的情况下被更改。所以使用 copy 来复制一份不可变的。 对 NSMutableArray 使用 copy添加、删除、修改组内的元素时，程序会因为找不到对应的方法而崩溃，原因是 copy 复制了一份不可变的 NSArray 对象。错误代码如下： @property (nonatomic, copy) NSMutableArray *mutableArray;NSMutableArray *array = [NSMutableArray arrayWithObjects:@1, @2, nil];self.mutableArray = array;[self.mutableArray removeObjectAtIndex:0]; strong 修饰 NSArray 时@property (nonatomic, strong) NSArray *array;NSArray *array = @[ @1, @2, @3, @4 ];NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];self.array = mutableArray;[mutableArray removeAllObjects];;NSLog(@\"%@\",self.array);[mutableArray addObjectsFromArray:array];self.array = [mutableArray copy];[mutableArray removeAllObjects];;NSLog(@\"%@\",self.array); 打印结果： 2016-04-03 00:10:10.765 DIYArrayCopyDemo[10681:713670] ()2016-04-03 00:10:10.766 DIYArrayCopyDemo[10681:713670] ( 1, 2, 3, 4) 所以 strong 的问题很明显，数据存在被篡改风险。 对象拷贝 声明该类遵循 NSCopying 协议 实现 NSCopying 协议方法 -copyWithZone: - (id)copyWithZone:(NSZone *)zone &#123; DIYUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age sex:_sex]; copy-&gt;_friends = [_friends mutableCopy]; return copy;&#125;// 对象也进行深拷贝// 写专门的深拷贝方法- (id)deepCopy &#123; DIYUser *copy = [[[self class] alloc] initWithName:_name age:_age sex:_sex]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;&#125; 集合/非集合类对象 copy非集合类对象： 不可变对象： copy：指针拷贝 mutableCopy：内容拷贝 可变对象： copy：内容拷贝 mutableCopy：内容拷贝 集合类对象：NSArray、NSDictionary、NSSet 等 不可变对象： copy：指针拷贝 mutableCopy：单层深拷贝。（如对 NSArray，是拷贝 array 这个对象，但 Array 内部元素任是指针拷贝） 可变对象： copy：单层深拷贝 mutableCopy：单层深拷贝 [array copy] //浅拷贝[array mutableCopy] //单层深拷贝[mutableArray copy] //单层深拷贝[mutableArray mutableCopy] //单层深拷贝 @property@property = ivar + getter + setter，即属性 = 实例变量 + 存取方法。 完成属性定义后，编译器在编译期会自动编写访问这些属性所需要的方法，即“自动合成”。除了生成 getter、setter 外，编译器还会向类中添加适当类型的实例变量，名称为 _propertyName。我们也可以通过 @synthesize 来指定实例变量的名称。 @property 大致的实现过程属性的源码实现结构： 偏移量 setter、getter 实现函数 ivar_list：成员变量列表 method_list：方法列表 prop_list：属性列表 实现过程： 每增加一个属性，系统就会在 ivar_list 中添加一个成员变量；在 method_list 中添加对应的 setter 和 getter 方法；在 prop_list 中添加一个属性。 之后计算该属性在对象中的偏移量，给出 setter、getter 方法对应的实现。setter 方法中从偏移量位置开始赋值；getter 方法中从偏移量开始取值。 @protocol 和 category 如何使用 @propertyprotocol 中使用 property 只会生成 setter 和 getter 方法声明。我们使用属性的目的是，希望遵循协议的对象能实现该属性。 category 使用 @property 只会生成 setter 和 getter 方法的声明。如果我们需要给 category 增加属性的实现，需要借助 runtime 函数： objc_setAssociatedObject objc_getAssociatedObject @property 的修饰符归类 原子性 atomic nonatomic 读写权限 readwrite readonly 内存管理语义 assign strong weak unsafe_unretained copy 方法名 getter=，如 getter=isOn setter= nullable nonnull null_resettable nullable ARC 下不显示关键字是，默认为： 基本类型 atomic readwrite assign 普通 OC 对象 atomic readwrite strong @synthesize 和 @dynamic @property 如果都没写，默认为：@synthesize = _var; @systhesize 语义是，默认让编译器加上 setter 和 getter 方法 @dynamic（动态绑定）作用：告诉编译器，属性的 setter、getter 方法不自动生成 什么时候不会 autosynthesis？ 同时重写了 setter 和 getter 重写了只读属性的 getter 使用了 @dynamic @protocol 中定义的所有属性 category 中定义的所有属性 重写的属性 注意点： 若子类重写了父类属性，必须用 @synthesize 来手动合成 ivar","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"}]},{"title":"KVC 梳理","slug":"2016-03-25-objc-kvc","date":"2016-03-24T16:00:00.000Z","updated":"2021-01-07T06:39:35.376Z","comments":true,"path":"2016/03/25/2016-03-25-objc-kvc/","link":"","permalink":"https://blog.jonyfang.com/2016/03/25/2016-03-25-objc-kvc/","excerpt":"KVC 即键值编码。是一种可以不通过存取方法，直接通过属性名称字符串简介访问属性的机制。","text":"KVC 即键值编码。是一种可以不通过存取方法，直接通过属性名称字符串简介访问属性的机制。 KVC 用法- (id)valueForKey:(NSString *)key;- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (void)setValue:(id)value forKeyPath:(NSString *)keyPath; KVC 可以通过传入属性名称的字符串来进行取值和赋值；KVC 也可以通过 path（如 student.name）来对多层级属性取值或赋值。 KVC 的原理setValue:forKey:调用步骤： 调用 setValue:forKey: 查找 set 或 _set 命名的 setter，按照这个顺序查找，如果找到，调用这个方法并传入值 若上述没找到对应的 setter，但 accessInstanceVariablesDirectly 类属性返回 YES，按序查找命名规则为 _key、_isKey、key、isKey 的实例变量。若找到则将 value 赋值给实例变量。 若还未找到 setter 或实例变量，则调用 setValue:forUndefinedKey: 方法，并默认抛出一个异常 valueForKey:调用步骤： 按序查找 get&lt;Key&gt; &lt;Key&gt; is&lt;Key&gt; 的 getter 方法，若找到直接调用 若方法的返回结果类型是一个对象指针，则直接返回结果 若类型为基本数据类型，则转为 NSNumber 返回；否则转为 NSValue 返回 若上述未找到 getter，则查找 countOf&lt;Key&gt;、objectIn&lt;Key&gt;AtIndex:、&lt;Key&gt;AtIndexes 方法 若 countOf&lt;Key&gt; 和另外两方法中一个找到，则返回一个可以响应 NSArray 所有方法的集合代理。发送给这个代理集合的 NSArray 消息方法，以 countOf&lt;Key&gt;、objectIn&lt;Key&gt;AtIndex:、&lt;Key&gt;AtIndexes 这几个方法组合的形式调用。 若上述未找到，继续查找 countOf&lt;Key&gt; enumeratorOf&lt;Key&gt; memberOf&lt;Key&gt; 方法。若都查到，返回一个可以相应 NSSet 所有方法的集合代理。再以方法组合形式调用 NSSet 消息方法。 若上述未找到，若类方法 accessInstanceVariablesDirectly 返回 YES，按序查找 _&lt;Key&gt; _is&lt;Key&gt; &lt;Key&gt; is&lt;Key&gt; 实例变量。若找到，返回相应的实例变量。 若任未找到，调用 valueForUndefinedKey: 方法，并默认抛出一个异常 2019.07.12 - iOS13 起遇到的问题2019.07.12 更新，记录 iOS13 系统禁止 KVC 访问的几种解决方案。 UITextFieldUITextField *textField = [UITextField new];[textField valueForKey:@\"_placeholderLabel\"]; 但 iOS13 中 UITextField 重写了 valueForKey:，拦截了外部的取值： @implementation UITextField- (id)valueForKey:(NSString *)key &#123; if ([key isEqualToString:@\"_placeholderLabel\"]) &#123; [NSException raise:NSGenericException format:@\"Access to UITextField's _placeholderLabel ivar is prohibited. This is an application bug\"]; &#125; [super valueForKey:key];&#125;@end 解决方案：取消下划线。 [textField valueForKey:@\"placeholderLabel\"]; UISearchBarUISearchBar *bar = [UISearchBar new];[bar setValue:@\"test\" forKey:@\"_cancelButtonText\"]UIView *searchField = [bar valueForKey:@\"_searchField\"]; iOS13 中重写了 set_cancleButtonText，拦截了 KVC： - (void)set_cancelButtonText:(NSString *)text &#123; [NSException raise:NSGenericException format:@\"Access to UISearchBar's set_cancelButtonText: ivar is prohibited. This is an application bug\"]; [self _setCancelButtonText];&#125;- (void)_searchField &#123; [NSException raise:NSGenericException format:@\"Access to UISearchBar's _searchField ivar is prohibited. This is an application bug\"]; [self searchField];&#125; 解决方案：直接调用 _setCancelButtonText、searchField。 UISearchBar *bar = [UISearchBar new];[bar setValue:@\"test\" forKey:@\"_setCancelButtonText\"]UIView *searchField = [bar valueForKey:@\"searchField\"];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"}]},{"title":"KVO 梳理","slug":"2016-03-25-objc-kvo","date":"2016-03-24T16:00:00.000Z","updated":"2021-01-12T09:53:53.625Z","comments":true,"path":"2016/03/25/2016-03-25-objc-kvo/","link":"","permalink":"https://blog.jonyfang.com/2016/03/25/2016-03-25-objc-kvo/","excerpt":"本篇是对 KVO(Key-Value Observing) 的梳理。内容结构：KVO 基本使用、KVO 实现原理、自己实现 KVO。","text":"本篇是对 KVO(Key-Value Observing) 的梳理。内容结构：KVO 基本使用、KVO 实现原理、自己实现 KVO。 KVO 基本使用主要的几个方法： -addObserver:forKeyPath:options:context:：注册观察者，开始监听。 -observeValueForKeyPath:ofObject:change:context:：回调，按需求添加业务代码。 -removeObserver:forKeyPath:：移除观察者。 实例代码： - (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [[Person alloc]init]; self.person.age = 15; // 注册监听 [self.person addObserver:self forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; // 值变更 self.person.age = 20; // 值变更 self.person.age = 30;&#125;// 监听回调- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; NSLog(@\"change = %@, keyPath =%@, object =%@, context=%@\", change, keyPath, object, context); NSLog(@\"属性新值为：%@\",change[NSKeyValueChangeNewKey]); NSLog(@\"属性旧值为：%@\",change[NSKeyValueChangeOldKey]);&#125;- (void)dealloc &#123; // 移除观察 [self.person removeObserver:self forKeyPath:@\"age\"];&#125; KVO 实现原理KVO 是 Objective-C 中对观察者模式的实现。KVO 的实现依赖于 Objective-C 的 Runtime 机制。当某个类的对象第一次被观察时，系统就会在 runtime 动态创建该类的一个派生类，在这个派生类中重写原类中任何被观察对象的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制。 如现有一 Person 类，它对于的派生类会命名为：NSKVONotifying_Person。每个类对象的 isa 指针都指向它所属的类，在一个类对象第一次被观察时，系统会将 isa 指针指向动态生成的派生类。在给被监控属性赋值时，执行的是派生类的 setter 方法。 KVO 的通知依赖于 NSObject 的两个方法：willChangeValueForKey: 和 didChangeValueForKey:。被观察属性发生变化时，对应的调用过程如下： 被改变前，调用 willChangeValueForKey:，记录旧值 改变被观察属性 被改变后，调用 didChangeValueForKey:，记录新值 接着调用 observeValueForKey:ofObject:change:context: 实现原理的过程图： KVO 的不足KVO 很明显的一个问题是，提供了一个单一回调。所有的属性变化，都会通过同一个方法回调。在内部再通过 key 来 ifelse 判断分别处理。理想的情况是，我们希望对应的属性变化，只触发对应的回调，而不影响其他属性。 我们可以通过手动实现 KVO 来解决这个问题。 自己实现 KVO前面我们已经知道 KVO 的实现原理。大致流程为： 当某个类的对象被观察时 系统会动态创建一个该类的派生类，派生类 superClass 指向原类 修改被观察对象的 isa 指针，使其指向派生类 在派生类中重写 setter 方法，在方法中加入 observer 实现源码比较长，附带在最后： //// NSObject+KVO.h// Demo//// Created by JonyFang on 2016/3/25.// Copyright © 2016 JonyFang. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;typedef void(^FFObserverHandler)(id object, NSString *key, id oldValue, id newValue);@interface NSObject (KVO)- (void)ff_addObserver:(NSObject *)object forKey:(NSString *)key withBlock:(FFObserverHandler)handler;- (void)ff_removeObserver:(NSObject *)object forKey:(NSString *)key;@end //// NSObject+KVO.m// Demo//// Created by JonyFang on 2016/3/25.// Copyright © 2016 JonyFang. All rights reserved.//#import \"NSObject+KVO.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;static NSString *const kFFKVOClassPrefix = @\"FFObserver_\";static NSString *const kFFKVOAssociatedObject = @\"FFKVOAssociatedObject\";@interface FFKVObserver : NSObject@property (nonatomic, weak) NSObject *observer;@property (nonatomic, copy) NSString *key;@property (nonatomic, copy) FFObserverHandler handler;@end@implementation FFKVObserver- (instancetype)initWithObserver:(NSObject *)observer forKey:(NSString *)key handler:(FFObserverHandler)handler &#123; if (self = [super init]) &#123; _observer = observer; _key = key; _handler = handler; &#125; return self;&#125;@end// key = propertyName，以 person 为例// 过程：person -&gt; setPerson:static NSString *setterForKey(NSString *key) &#123; if (key.length &lt;= 0) &#123; return nil; &#125; NSString *firstStr = [[key substringToIndex:1] uppercaseString]; NSString *leaveStr = [key substringFromIndex:1]; return [NSString stringWithFormat:@\"set%@%@:\", firstStr, leaveStr];&#125;// 过程：setPerson: -&gt; personstatic NSString *getterBySetter(NSString *setter) &#123; if (setter.length &lt;= 0 || ![setter hasPrefix: @\"set\"] || ![setter hasSuffix: @\":\"]) &#123; return nil; &#125; NSRange range = NSMakeRange(3, setter.length - 4); NSString *getter = [setter substringWithRange: range]; NSString *firstStr = [[getter substringToIndex: 1] lowercaseString]; getter = [getter stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString: firstStr]; return getter;&#125;static void KVO_Setter(id self, SEL _cmd, id newValue) &#123; NSString *setterName = NSStringFromSelector(_cmd); NSString *getterName = getterBySetter(setterName); if (!getterName) &#123; @throw [NSException exceptionWithName: NSInvalidArgumentException reason: [NSString stringWithFormat: @\"unrecognized selector sent to instance %p\", self] userInfo: nil]; return; &#125; id oldValue = [self valueForKey: getterName]; struct objc_super superClass = &#123; .receiver = self, .super_class = class_getSuperclass(object_getClass(self)) &#125;; [self willChangeValueForKey: getterName]; void (*objc_msgSendSuperKVO)(void *, SEL, id) = (void *)objc_msgSendSuper; objc_msgSendSuperKVO(&amp;superClass, _cmd, newValue); [self didChangeValueForKey: getterName]; //获取所有监听回调对象进行回调 NSMutableArray * observers = objc_getAssociatedObject(self, (__bridge const void *)kFFKVOAssociatedObject); for (FFKVObserver *ob in observers) &#123; if ([ob.key isEqualToString: getterName]) &#123; dispatch_async(dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; ob.handler(self, getterName, oldValue, newValue); &#125;); &#125; &#125;&#125;static Class KVO_Class(id self) &#123; return class_getSuperclass(object_getClass(self));&#125;// ==================@implementation NSObject (KVO)- (void)ff_addObserver:(NSObject *)object forKey:(NSString *)key withBlock:(FFObserverHandler)handler &#123; //step 1 get setter method, if not, throw exception SEL setterSelector = NSSelectorFromString(setterForKey(key)); Method setterMethod = class_getInstanceMethod([self class], setterSelector); if (!setterMethod) &#123; @throw [NSException exceptionWithName: NSInvalidArgumentException reason: [NSString stringWithFormat: @\"unrecognized selector sent to instance %@\", self] userInfo: nil]; return; &#125; // 自己的类作为被观察者类 Class observedClass = object_getClass(self); NSString *className = NSStringFromClass(observedClass); // 如果被监听者没有 `FFObserver_`，创建新类 if (![className hasPrefix: kFFKVOClassPrefix]) &#123; // 为被观察对象的类创建一个新的带有 `FFObserver_` 前缀的子类 observedClass = [self createKVOClassWithOriginalClassName:className]; // 创建新的子类，并添加新的方法 // object 内部的 isa 变量指向它的 class。这个变量可以被改变，而不需要重新创建 // 这一步即创建我们需要的新 class object_setClass(self, observedClass); &#125; // 判断是否有方法 if (![self hasSelector:setterSelector]) &#123; const char * types = method_getTypeEncoding(setterMethod); // 将原来的 setter 方法替换为新的 setter 方法 // 通过 runtime 的 Method Swizzling class_addMethod(observedClass, setterSelector, (IMP)KVO_Setter, types); &#125; // 新建一个观察者类 // 这个类的实现写在同一个 class，相当于导入一个类：`FFKVOObserver` // 这个类的作用是观察者，负责 Block 回调 FFKVObserver *observer = [[FFKVObserver alloc] initWithObserver:object forKey:key handler:handler]; // 因为观察者实例都有前缀 `FFKVOAssociatedObject` // 通过共同前缀，获取`观察者数组` // 再将新建的 observer 加入数组 // // 因为 objc_getAssociatedObject 的参数要求，需要转换为 void // 在 ARC 有效时，通过 (__bridge void *) 能够实现 id 和 void * 的相互转换 NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge void *)kFFKVOAssociatedObject); // 若没有新建 if (!observers) &#123; observers = [NSMutableArray array]; objc_setAssociatedObject(self, (__bridge void *)kFFKVOAssociatedObject, observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [observers addObject:observer];&#125;- (void)ff_removeObserver:(NSObject *)object forKey:(NSString *)key &#123; NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge void *)kFFKVOAssociatedObject); FFKVObserver *tmp = nil; for (FFKVObserver *ob in observers) &#123; if (ob.observer == object &amp;&amp; [ob.key isEqualToString: key]) &#123; tmp = ob; break; &#125; &#125; [observers removeObject:tmp];&#125;- (Class)createKVOClassWithOriginalClassName:(NSString *)className &#123; NSString *kvoClassName = [kFFKVOClassPrefix stringByAppendingString: className]; Class observedClass = NSClassFromString(kvoClassName); if (observedClass) &#123; return observedClass; &#125; // 创建以 `FFObserver_` 为类名前缀的新类 Class originalClass = object_getClass(self); Class kvoClass = objc_allocateClassPair(originalClass, kvoClassName.UTF8String, 0); // 获取监听对象的 class 方法实现代码，然后替换新建类的 class 实现 Method classMethod = class_getInstanceMethod(originalClass, @selector(class)); const char *types = method_getTypeEncoding(classMethod); class_addMethod(kvoClass, @selector(class), (IMP)KVO_Class, types); objc_registerClassPair(kvoClass); return kvoClass;&#125;- (BOOL)hasSelector:(SEL)selector &#123; Class observedClass = object_getClass(self); unsigned int methodCount = 0; Method *methodList = class_copyMethodList(observedClass, &amp;methodCount); for (int i = 0; i &lt; methodCount; i++) &#123; SEL thisSelector = method_getName(methodList[i]); if (thisSelector == selector) &#123; free(methodList); return YES; &#125; &#125; free(methodList); return NO;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"}]},{"title":"Associated Objects 实现原理","slug":"2016-03-16-objc-associated-objects","date":"2016-03-15T16:00:00.000Z","updated":"2021-01-07T06:39:35.376Z","comments":true,"path":"2016/03/16/2016-03-16-objc-associated-objects/","link":"","permalink":"https://blog.jonyfang.com/2016/03/16/2016-03-16-objc-associated-objects/","excerpt":"在上一篇《Category 梳理》里面提到 Category 可以添加实例方法、添加类方法、添加协议，但是不能添加属性。原因是 objc_category 结构体中没有属性（实例）列表，即使我们声明了属性，编译器也不会帮我们生成对应的 setter/getter。所以这种情况下，如果调用这些属性，会出现崩溃的情况。但这个问题是可以解决的。OC 是一门动态语言，方法真正的实现是通过 runtime 来完成的，虽然系统未给我们生成 setter/getter，但我们可以通过 runtime 来手动添加需要的 setter/getter 方法。即引申除了将要梳理的 Associated Objects。","text":"在上一篇《Category 梳理》里面提到 Category 可以添加实例方法、添加类方法、添加协议，但是不能添加属性。原因是 objc_category 结构体中没有属性（实例）列表，即使我们声明了属性，编译器也不会帮我们生成对应的 setter/getter。所以这种情况下，如果调用这些属性，会出现崩溃的情况。但这个问题是可以解决的。OC 是一门动态语言，方法真正的实现是通过 runtime 来完成的，虽然系统未给我们生成 setter/getter，但我们可以通过 runtime 来手动添加需要的 setter/getter 方法。即引申除了将要梳理的 Associated Objects。 Associated Objects（关联对象）可以给类动态的添加实例变量，可以增强类结构的灵活性。 如何使用应用示例代码： #import &lt;Foundation/Foundation.h&gt;@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end #import \"NSObject+AssociatedObject.h\"#import &lt;objc/runtime.h&gt;static const char kAssociatedObject;@implementation NSObject (AssociatedObject)- (id)associatedObject &#123; return objc_getAssociatedObject(self, &amp;kAssociatedObject);&#125;- (void)setAssociatedObject:(id)associatedObject &#123; objc_setAssociatedObject(self, &amp;kAssociatedObject, associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 核心函数方法： objc_setAssociatedObject：可以为一个对象设置一个关联对象 objc_getAssociatedObject：获取一个对象的关联对象 objc_removeAssociatedObjects：移除一个关联对象 源码实现已经知道了对象的关联代码，那是怎么关联的呢？看下对应的源码实现。 objc_setAssociatedObjectvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123; _object_set_associative_reference(object, (void *)key, value, policy);&#125; 进入 objc_setAssociatedObject 方法后，看到其内部调用了 _object_set_associative_reference 方法。源码如下： void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. // 如果设置新的 value 非 nil // 首先查看被关联对象的 AssociationHashMap 是否存在 // 若存在，去更新； // 若不存在，则新建 ObjectAssociationMap，并加入 key-value 映射 // 同时，setHasAssociatedObjects() AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. // 若 value 为 nil，移除关联对象 // old_association 指向要被移除的对象 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). // 校验是否有需要释放的对象 // 如果有，释放旧的关联对象 if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 注释大概描述了 _object_set_associative_reference 的实现过程，再来细看下涉及到方法和数据结构。 acquireValue()static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return objc_retain(value); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125; 根据关联策略对应处理对象，将处理结果返回。 AssociationsManagerclass AssociationsManager &#123; // associative references: object pointer -&gt; PtrPtrHashMap. static AssociationsHashMap *_map;public: AssociationsManager() &#123; AssociationsManagerLock.lock(); &#125; ~AssociationsManager() &#123; AssociationsManagerLock.unlock(); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;; AssociationsManager 是一个管理对象，维护一个带锁的 AssociationsHashMap，构造函数加锁，析构函数解锁。 AssociationsHashMap// ...ObjectAssociationMap *refs = new ObjectAssociationMap;associations[disguised_object] = refs;// ... 是一个无序 hash 表。key 是对象的地址；value 是 ObjectAssociationMap。 ObjectAssociationMapObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value);&#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value);&#125; 是一个无序 hash 表。key 是我们传入的 key；value 是 ObjcAssociation。 ObjcAssociationclass ObjcAssociation &#123; uintptr_t _policy; id _value;public: ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125; ObjcAssociation() : _policy(0), _value(nil) &#123;&#125; uintptr_t policy() const &#123; return _policy; &#125; id value() const &#123; return _value; &#125; bool hasValue() &#123; return _value != nil; &#125;&#125;; 是一个关联对象的封装。里面维护了关联对象的值（value）和关联策略（policy）。 objc_getAssociatedObjectobjc_getAssociatedObject 内部调用 _object_get_associative_reference。源码如下： id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; objc_autorelease(value); &#125; return value;&#125; _object_get_associative_reference() 首先通过对象指针获取 AssociationsHashMap；再通过 key 在 ObjectAssociationMap 里获取对应的 ObjcAssociation 并取到 value 和 policy；根据 policy 对应调用 objc_retain() 或 objc_autorelease()。 objc_removeAssociatedObjectsvoid objc_removeAssociatedObjects(id object) &#123; if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123; _object_remove_assocations(object); &#125;&#125; objc_removeAssociatedObjects 内部会先判断对象是否有关联对象，若有则调用 _object_remove_assocations()。对应源码如下： void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second); &#125; // remove the secondary table. delete refs; associations.erase(i); &#125; &#125; // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 即遍历取到所有的 AssociationsHashMap，并释放。 释放机制涉及到对象释放，我们首先想到的即为 dealloc，逐步看下 dealloc 过程中，是如何释放 assocations 的。 dealloc() 源码： - (void)dealloc &#123; _objc_rootDealloc(self);&#125; _objc_rootDealloc() 源码： void_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125; rootDealloc() 源码： inline voidobjc_object::rootDealloc()&#123; if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) &#123; assert(!sidetable_present()); free(this); &#125; else &#123; object_dispose((id)this); &#125;&#125; object_dispose() 源码： id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; objc_destructInstance() 源码： void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj-&gt;clearDeallocating(); &#125; return obj;&#125; 到这里会看到我们熟悉的 hasAssociatedObjects()，如果对象有关联对象，则将他们释放。 参考阅读： Associated Objects","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"}]},{"title":"Category 实现原理","slug":"2016-03-13-objc-cetegory","date":"2016-03-12T16:00:00.000Z","updated":"2021-01-07T06:39:35.376Z","comments":true,"path":"2016/03/13/2016-03-13-objc-cetegory/","link":"","permalink":"https://blog.jonyfang.com/2016/03/13/2016-03-13-objc-cetegory/","excerpt":"本篇是整理之前的笔记，梳理下在 runtime 层面是怎么处理的 Category。","text":"本篇是整理之前的笔记，梳理下在 runtime 层面是怎么处理的 Category。 分析源码基于：DeveloperErenLiu/RuntimeAnalyze/objc4-750 Category 的数据结构Category 在底层是一个结构体，如下： struct objc_category &#123; char * _Nonnull category_name OBJC2_UNAVAILABLE; char * _Nonnull class_name OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable instance_methods OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable class_methods OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE; 看到 Category 中有： 实例方法列表 类方法列表 协议列表 属性列表 大致可以猜测出 Category 可以做的有： 添加实例方法 添加类方法 实现协议 添加属性 我们知道的是：Category 不支持添加实例变量。原因是，类对象在编译时内存布局就已经确定，而 Categroy 的工作是在 Runtime 时生效，这时如果添加实例方法会破坏内存布局。 Category 的编译编译器会在编译时将 OC 对象编译为 Runtime 需要的结构体，Category 也会这样。我们 Cland 一下，看下结果。 示例代码： // FFClass@interface FFClass : NSObject@end@implementation FFClass@end// FFClass+FFCategory@interface FFClass (FFCategory)&lt;NSCopying&gt;@property (nonatomic, strong) FFClass *prop;- (void)hello;@end@implementation FFClass (FFCategory)- (void)hello &#123; //&#125;@end 执行如下命令： xcrun -sdk iphonesimulator clang -rewrite-objc FFClass.m 得到编译以后的 cpp 文件，会看到： static struct _category_t _OBJC_$_CATEGORY_FFClass_$_FFCategory __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; \"FFClass\", 0, // &amp;OBJC_CLASS_$_FFClass, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_FFClass_$_FFCategory, 0, (const struct _protocol_list_t *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_FFClass_$_FFCategory, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_FFClass_$_FFCategory,&#125;; 对应查找看到 _method_list_t、_protocol_list_t、_prop_list_t，这些即是我们的方法列表、属性列表和协议列表。对应的结构体如下： //方法static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_FFClass_$_FFCategory __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"hello\"&#125;&#125;&#125;;//协议static struct /*_protocol_list_t*/ &#123; long protocol_count; // Note, this is 32/64 bit struct _protocol_t *super_protocols[1];&#125; _OBJC_CATEGORY_PROTOCOLS_$_FFClass_$_FFCategory __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, &amp;_OBJC_PROTOCOL_NSCopying&#125;;//属性static struct /*_prop_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_FFClass_$_FFCategory __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_prop_t), 1, prop&#125;; 到这里编译后的内容即如上代码。 Runtime 的处理苹果的动态链接器（dyld）在启动 App 时，会进入 runtime 的初始化，调用 _objc_init()。其结构如下： void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 看到进行了一系列的初始化，如环境初始化、static 初始、锁初始化等。官方的注释： dyld will call the &quot;mapped&quot; function with already loaded objc images. mapped 即这里的 map_images，进入 map_images 看下实现。 voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[])&#123; mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);&#125; 跟着方法调用，进入下一步 map_images_nolock，这里大概进行的通过 Objective-C metadata 找到所有的 images，最后判断 images 数量是否 &gt;0，若 &gt;0 调用 _read_images()。在 _read_images() 源码里，我们提取出 Category 相关的处理代码： void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)&#123; // 1. 初始化工作、判断回收机制 // 2. 一些针对 OSX 的处理 // 3. 获取所有的类 // 4. 建立 hash，建立类名和类的映射 // 5. 注册 SEL // 6. 加载 protocol // 7. 实现 class 在 runtime 生成类对象 // 8. Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; if (PrintConnecting) &#123; _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \" \"missing weak-linked target class\", cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category -%s(%s) %s\", cls-&gt;nameForLogging(), cat-&gt;name, classExists ? \"on existing class\" : \"\"); &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category +%s(%s)\", cls-&gt;nameForLogging(), cat-&gt;name); &#125; &#125; &#125; &#125; ts.log(\"IMAGE TIMES: discover categories\"); // Category discovery MUST BE LAST to avoid potential races // when other threads call the new category code before // this thread finishes its fixups. // ...&#125; 根据源码分步来看。 获取 catlist通过 _getObjc2CategoryList 获取编译后的 Category 集合。 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); 判断 Category 对应的类是否存在前面已经拿到了 catlist，接着遍历 catlist，通过 remapClass 在类的 hash 表中查找这个类是否存在，如果不存在，直接处理下一个。 category_t *cat = catlist[i];Class cls = remapClass(cat-&gt;cls);if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; if (PrintConnecting) &#123; _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \" \"missing weak-linked target class\", cat-&gt;name, cat); &#125; continue;&#125; 实例方法、协议、属性的处理在找到了 Category 对应的类之后，接着判断 Category 的实例方法、协议、属性是否存在。如果存在，则绑定这个 Category 到类中，之后生成新的类信息，将方法列表、属性列表、协议列表合并。最后输出 log。 bool classExists = NO;if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category -%s(%s) %s\", cls-&gt;nameForLogging(), cat-&gt;name, classExists ? \"on existing class\" : \"\"); &#125;&#125; 我们看到了两个方法 addUnattachedCategoryForClass 和 remethodizeClass。addUnattachedCategoryForClass 是将未绑定的 Category 映射到 class 上。该方法的源码如下： static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader)&#123; runtimeLock.assertLocked(); // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead NXMapTable *cats = unattachedCategories(); category_list *list; list = (category_list *)NXMapGet(cats, cls); if (!list) &#123; list = (category_list *) calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1); &#125; else &#123; list = (category_list *) realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1)); &#125; list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;; NXMapInsert(cats, cls, list);&#125; 实现过程： 在 map 中查找执行 class 的 catlist。如果找到，将 cat 加到 catlist 中；如果没找到，通过 cat 新建一个 catlist。 remethodizeClass 的作用是重新生成类的实例方法列表、协议列表、属性列表。对应源码如下： static void remethodizeClass(Class cls)&#123; category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; if (PrintConnecting) &#123; _objc_inform(\"CLASS: attaching categories to class '%s' %s\", cls-&gt;nameForLogging(), isMeta ? \"(meta)\" : \"\"); &#125; attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; 实现过程： 通过 cls 获取它的 catlist，使用了 unattachedCategoriesForClass 方法。 之后通过 attachCategories 将 cats 合并到 cls 中 attachCategories 的源码： static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 实现过程： 获取 Category 对应的方法列表、属性列表、协议列表 之后通过 attachLists 来合并这些项 attachLists 的源码： void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;&#125; 添加列表时，先基于旧容量根据添加数扩容，得到新的内存空间。之后使用 memmove 将旧的项移到列表后面，使用 memcpy 将新的项放到列表前面。这也解释了为什么 Category 方法会覆盖类的方法。因为方法如果同名，Category 的方法一定在前面，会被先找到，如果找到了方法 runtime 不会再继续查找。 处理类方法和协议if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category +%s(%s)\", cls-&gt;nameForLogging(), cat-&gt;name); &#125;&#125; 和实例方法一样，调用 addUnattachedCategoryForClass 和 remethodizeClass，通过 cls-&gt;ISA()。 总结 Category 会在编译阶段编译成 category_t 结构体。 runtime 会将 class 和 category 做一个映射。 Category 的方法总会在 class 的方法之前，所以会覆盖 class 的方法。但方法是保留的。 Category 可以处理实例方法、协议、属性、类方法，但不能处理实例变量","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"}]},{"title":"iOS 中的锁","slug":"2016-03-11-ios-lock","date":"2016-03-10T16:00:00.000Z","updated":"2021-01-12T10:10:13.653Z","comments":true,"path":"2016/03/11/2016-03-11-ios-lock/","link":"","permalink":"https://blog.jonyfang.com/2016/03/11/2016-03-11-ios-lock/","excerpt":"我们在使用多线程访问同一块资源时，常会面临数据安全的问题。为了能够保证每次只有一个线程在访问同一块资源，我们需要借助锁。本篇归类记录 iOS 常见的八种锁是什么及怎么样。","text":"我们在使用多线程访问同一块资源时，常会面临数据安全的问题。为了能够保证每次只有一个线程在访问同一块资源，我们需要借助锁。本篇归类记录 iOS 常见的八种锁是什么及怎么样。 自旋锁 &amp; 互斥锁互斥锁： 当上一个线程的任务没有执行完毕时（被锁住），在下一个线程来后会进入休眠状态等待任务执行完毕。在上一个线程的任务执行完毕，下一个线程才会自动唤醒并执行任务。 所谓休眠，即在访问被锁定资源时，调用者线程会休眠，此时 CPU 可以调度其他线程工作。知道被锁资源释放锁，此时自动唤醒休眠线程。 自旋锁： 区别于互斥锁，在上一个线程的任务没执行完毕时，下一个线程不会进入睡眠，而是进入忙等待状态（不断地循环检查锁是否可用）。当上一个线程任务执行完毕，下一个线程立即执行任务。 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环检测，知道被锁资源释放锁。 优缺点对比： 自旋锁优点在于，自旋锁不会引起调用者休眠，所以不会进行线程调度、CPU 时间片轮转等耗时操作。所以如果能在很短的时间内获得锁，自旋锁的效率会远高于互斥锁。 自旋锁缺点在于，会一直占用 CPU，在被访问资源未解锁时，会一直运转（自旋）占用 CPU。如果不能在很短的时间内获得锁，会使 CPU 效率降低。自旋锁不能实现递归调用。 互斥锁： @synchronized NSLock pthread_mutex NSConditionLock NSCondition NSRecursiveLock 自旋锁： atomic OSSPinLock dispatch_semaphore_t @synchronized@synchronized 结构所做的事情和锁类似，它可以防止不同的线程同事执行同一段代码。相比较 NSLock（后面再介绍），不需要创建锁对象、不需要加锁解锁，使用方便可读性强。 先看一个 NSLock 的示例： @interface ThreadSafeQueue : NSObject@end@implementation ThreadSafeQueue &#123; NSMutableArray *_elements; NSLock *_lock;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; _elements = [NSMutableArray array]; _lock = [[NSLock alloc] init]; &#125; return self;&#125;- (void)push:(id)element &#123; [_lock lock]; [_elements addObject:element]; [_lock unlock];&#125;@end 再看下用 @synchronized 结构的实现： @interface ThreadSafeQueue : NSObject@end@implementation ThreadSafeQueue &#123; NSMutableArray *_elements;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; _elements = [NSMutableArray array]; &#125; return self;&#125;- (void)push:(id)element &#123; // 用 self 或 _elements 效果相同 @synchronized (self) &#123; [_elements addObject:element]; &#125;&#125;@end NSLock lock unlock trylock：尝试加锁，若成功 return YES，若失败 return NO lockBeforeDate：在 Date 前尝试加锁，若成功 return YES，若失败 return NO 示例： NSLock *lock = [NSLock new];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; sleep(3); [lock unlock];&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; BOOL isLocked = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:4]]; if (isLocked) &#123; [lock unlock]; &#125; else &#123; // &#125;&#125;); dispatch_semaphore 信号量 dispatch_semaphore_create(1)：传入值必须 &gt;= 0，若传入 0 会阻塞线程并等待 timeout，时间到后再执行下面的语句。 dispatch_semaphore_wait(signal, overTime)：加锁，信号量 -1 dispatch_semaphore_signal(signal)：解锁，信号量 +1 信号量的值可以拿停车位对比理解，信号量（车位）为 0 时，需要等待，信号量（车位） &gt;0 时可以继续调度函数。 示例： dispatch_semaphore_t signal = dispatch_semaphore_create(1);dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(signal, overTime); //signal 值 -1 dispatch_semaphore_signal(signal); //signal 值 +1&#125;); pthread_mutex需要带入头文件 #import &lt;pthread.h&gt; 使用示例： #import &lt;pthread.h&gt;static pthread_mutex_t pLock;pthread_mutex_init(&amp;pLock, NULL);//1. 线程 1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;pLock); sleep(3); pthread_mutex_unlock(&amp;pLock);&#125;);//2. 线程 2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (pthread_mutex_trylock(&amp;pLock)) &#123; pthread_mutex_unlock(&amp;pLock); &#125;&#125;); NSConditionLock 条件锁 NSConditionLock 可以实现任务之间的依赖。 示例代码： NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];// 线程 1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cLock tryLockWhenCondition:0]) &#123; NSLog(@\"OP1\"); [cLock unlockWithCondition:1]; &#125; else &#123; NSLog(@\"PFILURE\"); &#125;&#125;);// 线程 2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cLock lockWhenCondition:3]; NSLog(@\"OP2\"); [cLock unlockWithCondition:2];&#125;);// 线程 3dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cLock lockWhenCondition:1]; NSLog(@\"OP3\"); [cLock unlockWithCondition:3];&#125;);// 打印结果2016-03-11 15:26:40.737312+0800 Demo[8361:6200252] OP12016-03-11 15:26:40.737590+0800 Demo[8361:6200249] OP32016-03-11 15:26:40.737880+0800 Demo[8361:6200253] OP2 执行过程：0 -&gt; 1 -&gt; 3 -&gt; 2，所以说可以通过 NSConditionLock 实现任务的依赖。 NSCondition wait：进入等待状态 waitUntilDate：等待一定的时间 signal：唤醒一个等待的线程 broadcase：唤醒所有等待的线程 NSRecursiveLock递归锁可以被同一个线程多次请求，而不会引起死锁。主要用在循环和递归操作中。 OSSPinLock使用 OSSpinLock 需要引入头文件： #import &lt;libkern/OSAtomic.h&gt;__block OSSpinLock oslock = OS_SPINLOCK_INIT;//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"线程1 开始上锁\"); OSSpinLockLock(&amp;oslock); sleep(4); NSLog(@\"线程1\"); OSSpinLockUnlock(&amp;oslock); NSLog(@\"线程1 已解锁\"); NSLog(@\"--------------------------------------------------------\");&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"线程2 开始上锁\"); OSSpinLockLock(&amp;oslock); NSLog(@\"线程2\"); OSSpinLockUnlock(&amp;oslock); NSLog(@\"线程2 已解锁\");&#125;);// 打印日志2016-03-11 15:47:03.879471+0800 BuildDemo[8569:6213056] 线程1 开始上锁2016-03-11 15:47:03.879471+0800 BuildDemo[8569:6213053] 线程2 开始上锁2016-03-11 15:47:03.879679+0800 BuildDemo[8569:6213053] 线程22016-03-11 15:47:03.879808+0800 BuildDemo[8569:6213053] 线程2 已解锁2016-03-11 15:47:07.881847+0800 BuildDemo[8569:6213056] 线程12016-03-11 15:47:07.882197+0800 BuildDemo[8569:6213056] 线程1 已解锁2016-03-11 15:47:07.882454+0800 BuildDemo[8569:6213056] --------------------------------------------------------","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"iOS 多线程 - NSOperation","slug":"2016-03-10-ios-operation","date":"2016-03-09T16:00:00.000Z","updated":"2021-01-07T06:39:35.375Z","comments":true,"path":"2016/03/10/2016-03-10-ios-operation/","link":"","permalink":"https://blog.jonyfang.com/2016/03/10/2016-03-10-ios-operation/","excerpt":"iOS 日常开发过程中，涉及到多线程处理的需求，绝大多数可以通过 GCD 来完成。但如果想要给 task 添加依赖、取消、暂停、恢复的需求，GCD 的实现就会变得很复杂。这时就引申除了 NSOperation，NSOperation 是基于 GCD 的封装，提供面向对象的形式。我们可以借助 NSOperation 将每个 task 封装为一个个对象再进行操作，这也使得线程处理的代码逻辑更为清晰易懂。","text":"iOS 日常开发过程中，涉及到多线程处理的需求，绝大多数可以通过 GCD 来完成。但如果想要给 task 添加依赖、取消、暂停、恢复的需求，GCD 的实现就会变得很复杂。这时就引申除了 NSOperation，NSOperation 是基于 GCD 的封装，提供面向对象的形式。我们可以借助 NSOperation 将每个 task 封装为一个个对象再进行操作，这也使得线程处理的代码逻辑更为清晰易懂。 简而言之，NSOperation 相对的优势有： 可以添加操作间的依赖关系 可以设定操作执行的优先级 可以很方便的取消一个操作的执行 可以通过 KVO 观察操作执行的状态： isExecuting isFinished isCancelled NSOperation 用法NSOperation 需要配合 NSOperationQueue 来实现多线程异步执行。默认情况下，NSOperation 单独使用时，系统在当前线程中同步执行操作。NSOperation 是个抽象类，不能用来封装操作。我们可以通过它的子类来封装操作。封装方式有三种： 使用子类 NSInvocationOperation 使用子类 NSBlockOperation 使用自定义继承自 NSOperation 的子类 先在不使用 NSOperationQueue 的情况下单独使用 NSOperation（系统同步执行），看下三种创建方式。 NSInvocationOperation- (void)useInvocationOperation &#123; // 1.创建 NSInvocationOperation 对象 NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 2.调用 start 方法开始执行操作 [op start];&#125;- (void)task1 &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"thread---%@\", [NSThread currentThread]); // 打印当前线程 &#125;&#125;// 打印日志2016-03-10 22:04:09.848818+0800 Demo[985:5832682] thread---&lt;NSThread: 0x600002f54140&gt;&#123;number = 1, name = main&#125;2016-03-10 22:04:11.849534+0800 Demo[985:5832682] thread---&lt;NSThread: 0x600002f54140&gt;&#123;number = 1, name = main&#125; 看到默认在当前线程中执行操作。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。 NSBlockOperation- (void)useBlockOperation &#123; // 1.创建 NSBlockOperation 对象 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 2.调用 start 方法开始执行操作 [op start];&#125;// 打印日志2016-03-10 22:32:58.166336+0800 BuildDemo[1309:5851093] thread---&lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 1, name = main&#125;2016-03-10 22:33:00.167871+0800 BuildDemo[1309:5851093] thread---&lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 1, name = main&#125; 同样默认在当前线程执行操作。但 blockOperationWithBlock: 如果通过 addExecutionBlock: 添加多个操作时，操作有可能会在其他线程（非当前线程）中执行。 - (void)useBlockOperationAddExecutionBlock &#123; // 1.创建 NSBlockOperation 对象 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 2.添加额外的操作 [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"3---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"4---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"5---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"6---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"7---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"8---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.调用 start 方法开始执行操作 [op start];&#125;// 打印日志ß2016-03-10 22:41:06.732530+0800 BuildDemo[1355:5855507] 4---&lt;NSThread: 0x600000203500&gt;&#123;number = 7, name = (null)&#125;2016-03-10 22:41:06.732562+0800 BuildDemo[1355:5855387] 1---&lt;NSThread: 0x60000026c500&gt;&#123;number = 1, name = main&#125;2016-03-10 22:41:06.732563+0800 BuildDemo[1355:5855506] 3---&lt;NSThread: 0x600000227e80&gt;&#123;number = 6, name = (null)&#125;2016-03-10 22:41:06.732600+0800 BuildDemo[1355:5855510] 2---&lt;NSThread: 0x600000220a40&gt;&#123;number = 3, name = (null)&#125;2016-03-10 22:41:08.733836+0800 BuildDemo[1355:5855507] 4---&lt;NSThread: 0x600000203500&gt;&#123;number = 7, name = (null)&#125;2016-03-10 22:41:08.733836+0800 BuildDemo[1355:5855387] 1---&lt;NSThread: 0x60000026c500&gt;&#123;number = 1, name = main&#125;2016-03-10 22:41:08.733886+0800 BuildDemo[1355:5855510] 2---&lt;NSThread: 0x600000220a40&gt;&#123;number = 3, name = (null)&#125;2016-03-10 22:41:08.733890+0800 BuildDemo[1355:5855506] 3---&lt;NSThread: 0x600000227e80&gt;&#123;number = 6, name = (null)&#125;2016-03-10 22:41:10.735331+0800 BuildDemo[1355:5855510] 7---&lt;NSThread: 0x600000220a40&gt;&#123;number = 3, name = (null)&#125;2016-03-10 22:41:10.735331+0800 BuildDemo[1355:5855506] 8---&lt;NSThread: 0x600000227e80&gt;&#123;number = 6, name = (null)&#125;2016-03-10 22:41:10.735333+0800 BuildDemo[1355:5855387] 5---&lt;NSThread: 0x60000026c500&gt;&#123;number = 1, name = main&#125;2016-03-10 22:41:10.735332+0800 BuildDemo[1355:5855507] 6---&lt;NSThread: 0x600000203500&gt;&#123;number = 7, name = (null)&#125;2016-03-10 22:41:12.735989+0800 BuildDemo[1355:5855506] 8---&lt;NSThread: 0x600000227e80&gt;&#123;number = 6, name = (null)&#125;2016-03-10 22:41:12.735989+0800 BuildDemo[1355:5855510] 7---&lt;NSThread: 0x600000220a40&gt;&#123;number = 3, name = (null)&#125;2016-03-10 22:41:12.736083+0800 BuildDemo[1355:5855387] 5---&lt;NSThread: 0x60000026c500&gt;&#123;number = 1, name = main&#125;2016-03-10 22:41:12.736083+0800 BuildDemo[1355:5855507] 6---&lt;NSThread: 0x600000203500&gt;&#123;number = 7, name = (null)&#125; 根据打印结果，我们看到线程是有变化的。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。 自定义继承自 NSOperation 的子类如果如上两种无法满足需求，我们可以自己自定义继承自 NSOperation 的子类。通过重写 main 或 start 方法来自定义 NSOperation 对象。 先看下重写 main 的方式： // FFOperation.h 文件#import &lt;Foundation/Foundation.h&gt;@interface FFOperation : NSOperation@end// FFOperation.m 文件#import \"FFOperation.h\"@implementation FFOperation- (void)main &#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@\"1---%@\", [NSThread currentThread]); &#125; &#125;&#125;@end 使用： - (void)useCustomOperation &#123; FFOperation *op = [[FFOperation alloc] init]; [op start];&#125; 在没有使用 NSOperationQueue 时，在当前线程执行，不开启新线程。 NSOperationQueue配置 maxConcurrentOperationCountNSOperationQueue 有两种队列： 主队列 自定义队列 串行 并发 其中自定义队列是串行或并发，由最大并发数控制。示例代码： // 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.设置最大并发操作数queue.maxConcurrentOperationCount = 1; // 串行队列queue.maxConcurrentOperationCount = 2; // 并发队列queue.maxConcurrentOperationCount = 8; // 并发队列 配置依赖NSOperation 能添加操作之间的依赖关系。NSOperation 提供了 3 中接口供管理和查看依赖： // 添加依赖- (void)addDependency:(NSOperation *)op;// 移除依赖- (void)removeDependency:(NSOperation *)op;// 可用于查看依赖@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 以操作 op2 依赖于操作 op1 为例： - (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.添加依赖 // 让 op2 依赖于 op1，则先执行 op1，再执行 op2 [op2 addDependency:op1]; // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125;// 打印日志2016-03-11 10:57:13.394399+0800 Demo[5104:6020710] 1---&lt;NSThread: 0x600001df2a00&gt;&#123;number = 7, name = (null)&#125;2016-03-11 10:57:15.397272+0800 Demo[5104:6020710] 1---&lt;NSThread: 0x600001df2a00&gt;&#123;number = 7, name = (null)&#125;2016-03-11 10:57:17.401159+0800 Demo[5104:6020710] 2---&lt;NSThread: 0x600001df2a00&gt;&#123;number = 7, name = (null)&#125;2016-03-11 10:57:19.406361+0800 Demo[5104:6020710] 2---&lt;NSThread: 0x600001df2a00&gt;&#123;number = 7, name = (null)&#125; 根据打印日志，可以看到无论运行几次，结果都是 op1 先执行，op2 后执行。 配置优先级NSOperation 提供了 queuePriority（优先级） 属性，可以用于同一队列中的操作。默认新创建的操作对象的优先级都为 NSOperationQueuePriorityNormal。我们可以通过 setQueuePriority: 方法来改变当前操作在同一队列中的执行优先级。优先级有： // 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;; 对于添加到队列中的操作，先根据依赖关系进入就绪状态，再根据相对的优先级开始执行操作。 什么样的操作才能进入就绪状态？ 当一个操作的所有依赖都已经完成时，该操作对象通常会进入就绪状态，等待执行。 queuePriority 属性的作用对象： queuePriority 属性可以决定进入就绪状态的操作之间的开始执行顺序。优先级不能取代依赖。 若一个队列中同时包含高优先级操作和低优先级操作，且两个操作都进入了就绪状态，则队列先执行高优先级操作。 若一个队列同时包含了就绪和未就绪的操作，且未就绪的操作的优先级比就绪操作的优先级高。会先执行已经就绪的相对低优先级的操作。优先级不能取代依赖关系。如果要控制操作间的开始执行顺序，需要通过依赖关系处理。 线程间的通信通常我们会把耗时操作（图片下载、文件上传等）放到其他线程操作，当这些耗时操作完成时，需要到主线程中对应作出回调处理。这是比较常遇到的一个线程间通信的场景，示例代码： - (void)communication &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; // 2.添加操作 [queue addOperationWithBlock:^&#123; // 异步进行耗时操作 for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 进行一些 UI 刷新等操作 for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; &#125;];&#125;// 打印日志2016-03-11 12:03:55.281088+0800 Demo[5557:6061169] 1---&lt;NSThread: 0x6000022768c0&gt;&#123;number = 6, name = (null)&#125;2016-03-11 12:03:57.281512+0800 Demo[5557:6061169] 1---&lt;NSThread: 0x6000022768c0&gt;&#123;number = 6, name = (null)&#125;2016-03-11 12:03:59.282192+0800 Demo[5557:6061041] 2---&lt;NSThread: 0x60000223cbc0&gt;&#123;number = 1, name = main&#125;2016-03-11 12:04:01.283569+0800 Demo[5557:6061041] 2---&lt;NSThread: 0x60000223cbc0&gt;&#123;number = 1, name = main&#125; 通过 log 可以看到线程的切换，达到了线程间通信的目的。 线程同步和线程安全线程安全的概念：当进程中有多个线程同时对某个操作进行操作，如果多线程运行结果和单线程运行结果一致，就表示是线程安全的。一般多线程如果只进行读操作，是线程安全的；若多线程同时有读写操作，需要考虑线程同步，保证线程的安全。 线程同步的概念：自己理解为，现在同时有线程 A 和 B，A 执行到一定程度后需要依赖 B 的处理结果，这是 A 就需要停下来等待 B 给到处理结果后，再进行下面的操作。 举一个需要线程安全的例子：现有两个不同售票窗口，共有 10 张票，两个同时售票，卖完为止。 这里使用 NSLock 来保证线程同步，实例代码如下： - (void)initTicketStatusSave &#123; // 打印当前线程 NSLog(@\"currentThread---%@\",[NSThread currentThread]); self.ticketCount = 10; // 初始化 NSLock 对象 self.lock = [[NSLock alloc] init]; // 1.创建 queue1, queue1 代表 A 售票窗口 NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount = 1; // 2.创建 queue2, queue2 代表 B 票票窗口 NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount = 1; // 3.创建卖票操作 op1 __weak typeof(self) weakSelf = self; NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; [weakSelf saleTicketSafe]; &#125;]; // 4.创建卖票操作 op2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; [weakSelf saleTicketSafe]; &#125;]; // 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;- (void)saleTicketSafe &#123; while (1) &#123; // 加锁 [self.lock lock]; // 如果还有票，继续售卖 if (self.ticketCount &gt; 0) &#123; self.ticketCount--; NSLog(@\"%@\", [NSString stringWithFormat:@\"剩余票数:%ld 窗口:%@\", (long)self.ticketCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; // 解锁 [self.lock unlock]; if (self.ticketCount &lt;= 0) &#123; NSLog(@\"票已售完\"); break; &#125; &#125;&#125;// 打印日志2016-03-11 12:28:47.155040+0800 Demo[5814:6075398] currentThread---&lt;NSThread: 0x600003118c00&gt;&#123;number = 1, name = main&#125;2016-03-11 12:28:47.156066+0800 Demo[5814:6075448] 剩余票数:9 窗口:&lt;NSThread: 0x600003152600&gt;&#123;number = 7, name = (null)&#125;2016-03-11 12:28:47.357156+0800 Demo[5814:6075448] 剩余票数:8 窗口:&lt;NSThread: 0x600003152600&gt;&#123;number = 7, name = (null)&#125;2016-03-11 12:28:47.560797+0800 Demo[5814:6075448] 剩余票数:7 窗口:&lt;NSThread: 0x600003152600&gt;&#123;number = 7, name = (null)&#125;2016-03-11 12:28:47.773323+0800 Demo[5814:6075448] 剩余票数:6 窗口:&lt;NSThread: 0x600003152600&gt;&#123;number = 7, name = (null)&#125;2016-03-11 12:28:47.973762+0800 Demo[5814:6075448] 剩余票数:5 窗口:&lt;NSThread: 0x600003152600&gt;&#123;number = 7, name = (null)&#125;2016-03-11 12:28:48.248293+0800 Demo[5814:6075449] 剩余票数:4 窗口:&lt;NSThread: 0x60000312bb00&gt;&#123;number = 4, name = (null)&#125;2016-03-11 12:28:48.510233+0800 Demo[5814:6075448] 剩余票数:3 窗口:&lt;NSThread: 0x600003152600&gt;&#123;number = 7, name = (null)&#125;2016-03-11 12:28:49.111171+0800 Demo[5814:6075449] 剩余票数:2 窗口:&lt;NSThread: 0x60000312bb00&gt;&#123;number = 4, name = (null)&#125;2016-03-11 12:28:49.507041+0800 Demo[5814:6075449] 剩余票数:1 窗口:&lt;NSThread: 0x60000312bb00&gt;&#123;number = 4, name = (null)&#125;2016-03-11 12:28:49.848690+0800 Demo[5814:6075449] 剩余票数:0 窗口:&lt;NSThread: 0x60000312bb00&gt;&#123;number = 4, name = (null)&#125;2016-03-11 12:28:50.053556+0800 Demo[5814:6075449] 票已售完2016-03-11 12:28:50.053589+0800 Demo[5814:6075448] 票已售完 通过 NSLock 加锁解锁，得到的票数是正确的，这也解决了多线程同步的问题。 总结汇总下 NSOperation 和 NSOperationQueue 的常用属性和方法。 NSOperation 取消操作： // 取消操作，实质是标记 isCancelled 状态- (void)cancel; 判断操作的状态： // 判断操作是否结束- (BOOL)isFinished;// 判断操作是否已标记为取消- (BOOL)isCancelled;// 判断操作是否正在运行 - (BOOL)isExecuting;// 判断操作是否已进入就绪状态（就绪状态与依赖关系有关）- (BOOL)isReady; 操作同步 // 阻塞当前线程，知道对应操作结束。用于线程同步。- (void)waitUntilFinished;// 当操作处理完成，block 回调- (void)setCompletionBlock:(void (^)(void))block;// 添加依赖（让当前操作依赖 op）- (void)addDependency:(NSOperation *)op;// 移除依赖（取消当前操作的依赖）- (void)removeDependency:(NSOperation *)op;// 当前操作所依赖的所有操作对象@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; NSOperationQueue 取消、暂停、恢复操作： // 取消 queue 的所有操作- (void)cancelAllOperations;// 判断队列是否在暂停状态- (BOOL)isSuspended;// 暂停或恢复当前队列中的操作（YES 暂停，NO 恢复）- (void)setSuspended:(BOOL)b; 操作同步 // 阻塞当前线程，知道队列中所有的操作完成- (void)waitUntilAllOperationsAreFinished; 添加、获取操作： // 向队列添加操作对象- (void)addOperationWithBlock:(void (^)(void))block;// 向队列添加多个操作对象，wait 表示是否阻塞当前线程知道队列中所有操作完成- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;// 获取当前队列中所有的操作对象（一个操作结束后，会从该数组移除）- (NSArray *)operations;// 当前队列中的操作数- (NSUInteger)operationCount; 获取队列： // 获取当前队列+ (id)currentQueue;// 获取主队列+ (id)mainQueue; 其他关于取消和恢复： 可以通过 -setSuspended: 暂停或恢复当前 queue 的操作 Operation Queue 的取消和暂停，指当当前在执行的 Operation 执行完毕后，不再执行新的 Operation。暂停的操作可以恢复，但如果操作被取消，该操作会被清空，无法再恢复执行。 参考内容： 并发编程：API 及挑战 NSOperation","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"iOS 多线程 - GCD","slug":"2016-03-09-ios-gcd","date":"2016-03-08T16:00:00.000Z","updated":"2021-01-07T06:39:35.375Z","comments":true,"path":"2016/03/09/2016-03-09-ios-gcd/","link":"","permalink":"https://blog.jonyfang.com/2016/03/09/2016-03-09-ios-gcd/","excerpt":"GCD（Grand Central Dispatch）是苹果提出的一套多线程解决方案，它拥有系统级的线程管理机制，开发者不需要关注线程的生命周期管理，只需要关注要执行的任务。GCD 可用于多核的并行运算，会自动利用更多的 CPU 内核。","text":"GCD（Grand Central Dispatch）是苹果提出的一套多线程解决方案，它拥有系统级的线程管理机制，开发者不需要关注线程的生命周期管理，只需要关注要执行的任务。GCD 可用于多核的并行运算，会自动利用更多的 CPU 内核。 多线程的基础概念先看下 iOS 多线程编程的一些概念。 进程 &amp; 线程 进程（process）：iOS 中指一个正在运行的 App。每个进程可以拥有独立的虚拟内存空间和系统资源，至少包含一个主线程和任意的辅助线程。当一个进程中的主线程退出时，这个进程也会结束。 线程（thread）：指一个独立的代码执行路径。iOS 中线程的底层实现是基于 pthreads。 任务（task）：指一个要执行的任务。如执行一段代码。 串行 &amp; 并发 串行：指一次只能执行一个任务，必须等一个任务执行完成后，才会执行下一个任务。 并发：指允许多个任务同时执行。 两者的区别在于，在于同时允许执行的任务数量。 同步 &amp; 异步 同步：等待在执行的代码完成后，再执行接下来的代码。 异步：在代码调用后，立刻返回，不会等待代码执行的结果。 两者的区别在于，是否等待代码执行完成，即是否阻塞当前线程。 队列iOS 中有两种队列： 串行队列：一次只执行一个任务。 并发队列：允许多个任务同时执行。 iOS 系统通过队列来进行任务的调度，系统根据调度任务的需要和系统当前负载的情况动态创建和销毁线程。 GCD 用法记录 GCD 的一些常规用法。 dispatch_queue_tGCD 提供了 4 种全局队列和 1 个主队列。主队列是串行队列，其余是并行队列，优先级越高，越有限执行。 dispatch_get_main_queue()：主队列，会在主线程执行，串行。 dispatch_get_global_queue(long identifier, unsigned long flags)：全局队列，flags 是苹果预留字段，传入非 0 可能会导致返回 nil，identifier 有四种： #define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN DISPATCH_QUEUE_PRIORITY_HIGH：适用场景是需要及时得到处理结果。 DISPATCH_QUEUE_PRIORITY_DEFAULT：默认优先级。 DISPATCH_QUEUE_PRIORITY_LOW：适用于需要长时间运行的不紧急的任务。 DISPATCH_QUEUE_PRIORITY_BACKGROUND：适用于预加载或不需要用户交互和对时间不敏感的任务。 dispatch_queue_create普通用法创建自定义队列： // 创建串行队列（NULL 默认为串行队列）// 优先级默认为 DISPATCH_QUEUE_PRIORITY_DEFAULTdispatch_queue_t serialQueue = dispatch_queue_create(\"com.jonyfang.serial\", DISPATCH_QUEUE_SERIAL);// 创建并行队列// 优先级默认为 DISPATCH_QUEUE_PRIORITY_DEFAULTdispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.jonyfang.concurrent\", DISPATCH_QUEUE_CONCURRENT); 自定义小优先级也可以通过 dispatch_queue_attr_make_with_qos_class 创建带有优先级的 dispatch_queue_attr_t： dispatch_queue_attr_tdispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t _Nullable attr, dispatch_qos_class_t qos_class, int relative_priority); attr：传入 DISPATCH_QUEUE_SERIAL、NULL 或 DISPATCH_QUEUE_CONCURRENT，表示串行或并行。 qos_class：传入 qos_class 枚举，表示优先级级别。 relative_priority：相对于 qos_class 的相对优先级，qos_class 用于区分大的优先级级别，relative_priority 表示大级别下的小级别。relative_priority 必须大于 QOS_MIN_RELATIVE_PRIORITY（-15） 小于 0，否则将返回 NULL。传入 NULL 只会创建出串行队列。 用法示例： dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_DEFAULT, -2);dispatch_queue_t customQueue = dispatch_queue_create(\"com.jonyfang.custom\", attr); dispatch_set_target_queue指定队列优先级自带的 dispatch_get_global_queue 可以指定优先级；而通过 dispatch_queue_create 生成的 queue 不管是 Serial 还是 Concurrent，它们的执行优先级都默认为 DISPATCH_QUEUE_PRIORITY_DEFAULT。如果我们想改变自定义 queue 的优先级，可以通过 dispatch_set_target_queue。 dispatch_queue_t customQueue = dispatch_queue_create(\"com.jony.serial\", DISPATCH_QUEUE_SERIAL);dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);// 第一个参数为要设置优先级的 queue// 第二个参数是参照物// 将 customQueue 的优先级和 globalQueue 的优先级设置为一样。dispatch_set_target_queue(customQueue, globalQueue);dispatch_async(customQueue, ^&#123; NSLog(@\"CUSTOM-LOW-QUEUE\");&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"GLOBAL-DEFAULT-QUEUE\");&#125;);打印结果：2016-03-09 11:08:49.388 Demo[1408:539481] GLOBAL-DEFAULT-QUEUE2016-03-09 11:08:49.388 Demo[1408:539185] CUSTOM-LOW-QUEUE 改变队列执行方式dispatch_set_target_queue 除了可以指定队列优先级，还可以改变多个队列的执行顺序。当我们想让不同的队列，同步执行，而不再并行执行。可以如下： //1.创建目标队列 dispatch_queue_t targetQueue = dispatch_queue_create(\"com.jony.target\", DISPATCH_QUEUE_SERIAL); //2.创建 3 个串行队列 dispatch_queue_t queue1 = dispatch_queue_create(\"test.1\", DISPATCH_QUEUE_SERIAL); dispatch_queue_t queue2 = dispatch_queue_create(\"test.2\", DISPATCH_QUEUE_SERIAL); dispatch_queue_t queue3 = dispatch_queue_create(\"test.3\", DISPATCH_QUEUE_SERIAL); //3.将 3 个串行队列分别添加到目标队列 dispatch_set_target_queue(queue1, targetQueue); dispatch_set_target_queue(queue2, targetQueue); dispatch_set_target_queue(queue3, targetQueue); dispatch_async(queue1, ^&#123; NSLog(@\"queue.1 in\"); [NSThread sleepForTimeInterval:3.f]; NSLog(@\"queue.1 out\"); &#125;); dispatch_async(queue2, ^&#123; NSLog(@\"queue.2 in\"); [NSThread sleepForTimeInterval:2.f]; NSLog(@\"queue.2 out\"); &#125;); dispatch_async(queue3, ^&#123; NSLog(@\"queue.3 in\"); [NSThread sleepForTimeInterval:1.f]; NSLog(@\"queue.3 out\"); &#125;);//打印结果：2016-03-09 11:37:05.638 Demo[1456:648304] queue.1 in2016-03-09 11:37:08.643 Demo[1456:648304] queue.1 out2016-03-09 11:37:08.644 Demo[1456:648304] queue.2 in2016-03-09 11:37:10.649 Demo[1456:648304] queue.2 out2016-03-09 11:37:10.649 Demo[1456:648304] queue.3 in2016-03-09 11:37:11.652 Demo[1456:648304] queue.3 out aysnc &amp; sync// 异步调用void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);// 同步调用void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); queue：block 执行所在的队列 block：执行的 block 异步调用会立刻返回；但同步调用会阻塞当前线程，等待 block 执行完毕后才继续。 死锁问题： dispatch_queue_t serialQueue = dispatch_queue_create(\"com.jony.serial\", DISPATCH_QUEUE_SERIAL);dispatch_async(serialQueue, ^&#123; dispatch_sync(serialQueue, ^&#123; ///发生死锁 NSLog(@\"Here I am.\"); &#125;);&#125;); 如上代码会发生死锁，原因是：dispatch_async() 和 dispatch_sync() 都被加入了串行队列 serialQueue。dispatch_sync() 想要执行，就必须等待 dispatch_async() 的 Block 执行完毕。而 Block 想要执行完毕，必须先执行完 dispatch_sync()。这样就造成了互相持续等待，发生了死锁。 dispatch_oncedispatch_once 能保证任务只被执行一次，即使多线程调用也是安全的。常用在单例创建、Method Swizzeling。 示例代码： static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // 进行单例创建 // 或 Method Swizzling&#125;); 单例示例代码： @interface FFPerson : NSObject+ (instancetype)shareInstance;@end@implementation FFPerson+ (instancetype)shareInstance &#123; static FFPerson *_person = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _person = [[FFPerson alloc] init]; &#125;); return _person;&#125;@end dispatch_afterdispatch_after 指将一个任务（Block 内代码）延迟一段时间后，再追加到一个队列中执行。 // 延迟 1 秒dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 延迟提交的 block&#125;); dispatch_applydispatch_apply 是同步的调用，不会立刻返回，等待执行完毕后再返回。作用是将一个任务追加到队列中多次执行。该队列串行或并行有队列本身决定。 如遍历一个数组内全部元素： // 遍历 5 次dispatch_apply(5, dispatch_get_main_queue(), ^(size_t index) &#123; // 遍历执行的代码&#125;); dispatch_barrier_asyncdispatch_barrier_async 自己理解为是一个分隔板，dispatch_barrier_async 需要等待 dispatch_barrier_async 之前的任务全部执行完毕才执行，同时 dispatch_barrier_async 之后的任务也会进行等待 dispatch_barrier_async 执行完后才执行。 dispatch_barrier_async 与 dispatch_barrier_sync 的区别： dispatch_barrier_async 体现了异步的特点，不做任何等待直接返回，只保证 block 块开始执行的顺序是按照我们想要的顺序。 dispatch_barrier_sync 不光能按我们想要的顺序执行 Block 内任务，dispatch_barrier_sync 还会等待前面的 Block 执行完成，才会继续后面的代码执行。 示例代码： NSLog(@\"BEGIN\");dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123; // 任务 1 for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"task1 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);dispatch_async(queue, ^&#123; // 任务 2 for (int i = 0; i &lt; 2 ; i++) &#123; NSLog(@\"task2 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);NSLog(@\"task1、task2 后，barrier 前\");dispatch_barrier_async(queue, ^&#123; // barrier for (int i = 0; i &lt; 1 ; i++) &#123; NSLog(@\"barrier 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);dispatch_async(queue, ^&#123; // 任务 3 for (int i = 0; i &lt; 1 ; i++) &#123; NSLog(@\"task3 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);NSLog(@\"END\");// 打印结果：2016-03-09 13:47:17.656139+0800 Demo[4912:51826] BEGIN2016-03-09 13:47:17.656348+0800 Demo[4912:51826] task1、task2 后，barrier 前2016-03-09 13:47:17.656463+0800 Demo[4912:51882] task1 来自线程：&lt;NSThread: 0x60000047f740&gt;&#123;number = 3, name = (null)&#125;2016-03-09 13:47:17.656470+0800 Demo[4912:51884] task2 来自线程：&lt;NSThread: 0x60000047ed00&gt;&#123;number = 4, name = (null)&#125;2016-03-09 13:47:17.656599+0800 Demo[4912:51826] END2016-03-09 13:47:17.656654+0800 Demo[4912:51884] task2 来自线程：&lt;NSThread: 0x60000047ed00&gt;&#123;number = 4, name = (null)&#125;2016-03-09 13:47:17.656654+0800 Demo[4912:51882] task1 来自线程：&lt;NSThread: 0x60000047f740&gt;&#123;number = 3, name = (null)&#125;2016-03-09 13:47:17.657139+0800 Demo[4912:51882] barrier 来自线程：&lt;NSThread: 0x60000047f740&gt;&#123;number = 3, name = (null)&#125;2016-03-09 13:47:17.657313+0800 Demo[4912:51882] task3 来自线程：&lt;NSThread: 0x60000047f740&gt;&#123;number = 3, name = (null)&#125; NSLog(@\"BEGIN\");dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123; //任务1 for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"task1 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);dispatch_async(queue, ^&#123; //任务2 for (int i = 0; i &lt; 2 ; i++) &#123; NSLog(@\"task2 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);NSLog(@\"task1/task2 后，barrier 前：%@\",[NSThread currentThread]);dispatch_barrier_sync(queue, ^&#123; //珊栏 for (int i = 0; i &lt; 1 ; i++) &#123; NSLog(@\"barrier 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);dispatch_async(queue, ^&#123; //任务3 for (int i = 0; i &lt; 1 ; i++) &#123; NSLog(@\"task3 来自线程：%@\",[NSThread currentThread]); &#125;&#125;);NSLog(@\"END\");// 打印结果：2016-03-09 13:54:09.045223+0800 Demo[5014:57352] BEGIN2016-03-09 13:54:09.045461+0800 Demo[5014:57352] task1/task2 后，barrier 前：&lt;NSThread: 0x600000072f00&gt;&#123;number = 1, name = main&#125;2016-03-09 13:54:09.045486+0800 Demo[5014:57400] task2 来自线程：&lt;NSThread: 0x60000026dd80&gt;&#123;number = 4, name = (null)&#125;2016-03-09 13:54:09.045496+0800 Demo[5014:57404] task1 来自线程：&lt;NSThread: 0x600000260b80&gt;&#123;number = 3, name = (null)&#125;2016-03-09 13:54:09.045758+0800 Demo[5014:57400] task2 来自线程：&lt;NSThread: 0x60000026dd80&gt;&#123;number = 4, name = (null)&#125;2016-03-09 13:54:09.045830+0800 Demo[5014:57404] task1 来自线程：&lt;NSThread: 0x600000260b80&gt;&#123;number = 3, name = (null)&#125;2016-03-09 13:54:09.045991+0800 Demo[5014:57352] barrier 来自线程：&lt;NSThread: 0x600000072f00&gt;&#123;number = 1, name = main&#125;2016-03-09 13:54:09.046099+0800 Demo[5014:57352] END2016-03-09 13:54:09.046124+0800 Demo[5014:57404] task3 来自线程：&lt;NSThread: 0x600000260b80&gt;&#123;number = 3, name = (null)&#125; dispatch_group_tdiapatch_group_t 可以用来监控不同队列中的不同任务。当 group 内所有任务完成（Block 执行完毕），GCD 提供了两种告知方式： dispatch_group_wait：会阻塞当前线程（所以不可以放到主线程调用），等待所有任务完成或超时。 dispatch_group_notify：异步执行 Block 内任务，不阻塞。 示例代码： dispatch_queue_t queue = dispatch_queue_create(\"com.jony.concurrent\", DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; NSLog(@\"1\"); sleep(1);&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@\"2\"); sleep(2);&#125;);// 阻塞dispatch_group_wait(group, DISPATCH_TIME_FOREVER); dispatch_queue_t queue = dispatch_queue_create(\"com.jony.concurrent\", DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; NSLog(@\"1\"); sleep(1);&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@\"2\"); sleep(2);&#125;);// 异步dispatch_group_notify(group, queue, ^&#123; NSLog(@\"所有任务完成\");&#125;); dispatch_time_tGCD 也可以用来做定时器。 单次执行： // 执行一次（利用 dispatch_after）dispatch_time_t timer = dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC);dispatch_after(timer, dispatch_get_main_queue(), ^(void)&#123; // 执行事件&#125;); 每隔一秒重复执行： dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 1 * NSEC_PER_SEC, 0); // 每秒执行dispatch_source_set_event_handler(timer, ^&#123; // 执行事件&#125;);dispatch_resume(timer); dispatch_semaphoreDispatch Semaphore 是持有计数的信号，计数为 0 时等待，计数 &gt;= 1 时放行。 dispatch_semaphore 的基本用法： dispatch_semaphore_create 可以生成信号量，参数 value 是信号量计数的初始值； dispatch_semaphore_wait 会让信号量值 -1，当信号量值为 0 时进入等待（直到超时），否则正常执行； dispatch_semaphore_signal 会让信号量值 +1，如果有通过 dispatch_semaphore_wait 函数等待 Dispatch Semaphore 的计数值增加的线程，会由系统唤醒最先等待的线程执行。 // 在 init 等函数初始化_lock = dispatch_semaphore_create(1); dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); // 修改Array或字典等数据的信息dispatch_semaphore_signal(_lock); 常会遇到的链式请求，示例代码： // 链式请求，网络请求需要串行执行，第一个请求成功后再开始第二个请求- (void)requestConfig &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSArray *list = @[@\"1\",@\"2\",@\"3\"]; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [list enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [self fetchConfigWithCompletion:^(NSDictionary *dict) &#123; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); &#125;]; &#125;);&#125;- (void)fetchConfigWithCompletion:(void(^)(NSDictionary *dict))completion &#123; // 进行网络请求 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 模拟网络请求 sleep(2); !completion ? nil : completion(nil); &#125;);&#125; GCD vc NSOperationGCD 由苹果官方提供的一个用于多核编程的解决方案，基于 C 开发。主要用于让应用程序支持多核处理，提高应用性能。NSoperation 是基于 GCD 封装的，相比 GCD 使用更加灵活，功能更强大。 GCD：轻量，以 FIFO 顺序执行任务。使用 GCD 时，我们不用关心任务的调度，交由系统处理。但如果我们想要给任务之间添加依赖关系、取消或暂停一个正在执行的任务，GCD 不能很好地支持。 NSOperation：相比 GCD，NSOperation 会增加一些额外的开销，但具有更高的灵活性和更多的功能。我们可以基于 Operation 给任务之间添加依赖、取消、暂停或恢复一个在执行的任务。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Block 梳理","slug":"2016-03-01-block","date":"2016-02-29T16:00:00.000Z","updated":"2021-01-12T09:57:26.048Z","comments":true,"path":"2016/03/01/2016-03-01-block/","link":"","permalink":"https://blog.jonyfang.com/2016/03/01/2016-03-01-block/","excerpt":"本篇是对 Block 的梳理。","text":"本篇是对 Block 的梳理。 Block 的语法// 局部变量returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;// 属性@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);// 方法参数- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;// 调用方法[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];// typedeftypedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;; 日常开发中，创建 block 常会通过 typedef + property 的方式。 Block 的底层将如下代码通过 clang 的 rewrite 指令生成 c/c++ 描述。 int main(int argc, const char * argv[]) &#123; void(^block)() = ^() &#123; NSLog(@\"hello\"); &#125;; block(); return 0;&#125; clang rewrite 后： static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_v4_8fn73k9s2p5bxbsdm0cvqyd40000gn_T_main_3d0d97_mi_0);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;int main(int argc, const char * argv[]) &#123; void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 会看到几个部分： __main_block_func_0 一个执行函数 __main_block_desc_0 一个 Block 描述结构体 __block_impl 这是 Block 对象 isa：ARC 下有三种类型，分别是 _NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock Flags：标志位，分别有： enum &#123; BLOCK_DEALLOCATING = (0x0001), // runtime BLOCK_REFCOUNT_MASK = (0xfffe), // runtime BLOCK_NEEDS_FREE = (1 &lt;&lt; 24), // runtime BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25), // compiler BLOCK_HAS_CTOR = (1 &lt;&lt; 26), // compiler: helpers have C++ code BLOCK_IS_GC = (1 &lt;&lt; 27), // runtime BLOCK_IS_GLOBAL = (1 &lt;&lt; 28), // compiler BLOCK_USE_STRET = (1 &lt;&lt; 29), // compiler: undefined if !BLOCK_HAS_SIGNATURE BLOCK_HAS_SIGNATURE = (1 &lt;&lt; 30) // compiler&#125;; Resetved：保留位 FuncPtr：block 执行的函数指针地址 __main_block_impl_0 结构体包含了一个__block_impl，__main_block_desc_0 结构体， 还有一个初始化方法 赋值相应字段 main 函数 void(^block)() 转化为第一段 让 block 这个变量指针指向新生产的 __main_block_impl_0 结构体变量。 调用的构造器传入函数地址(__main_block_func_0)和描述字段(__main_block_desc_0_DATA)。 block(); 转化为第二段 大致流程：取出 impl -&gt; 调用实现函数指针（impl.FuncPtr）-&gt; 传入 block（自身） 简而言之，在 main 函数中，先通过 block、func、desc 新建一个 impl，这样就将 block 与 func 进行了绑定。在 block 执行时，执行 block 对应 impl 内的 func 函数。 变量捕获我们知道是 Block 中基础类型的变量会被拷贝值，指针变量会捕获指针变量并强引用。 先模拟一个 block 捕获外部变量的过程： int main(int argc, const char * argv[]) &#123; int i = 0; NSMutableArray *n = [NSMutableArray array]; void(^block)() = ^() &#123; int a = i; [n addObject:@\"1\"]; NSLog(@\"hello\"); &#125;; block(); return 0;&#125; clang resrite 后的代码： struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int i; NSMutableArray *n; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, NSMutableArray *_n, int flags=0) : i(_i), n(_n) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int i = __cself-&gt;i; // bound by copy NSMutableArray *n = __cself-&gt;n; // bound by copy int a = i; ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)n, sel_registerName(\"addObject:\"), (id)(NSString *)&amp;__NSConstantStringImpl__var_folders_v4_8fn73k9s2p5bxbsdm0cvqyd40000gn_T_main_16958d_mi_0); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_v4_8fn73k9s2p5bxbsdm0cvqyd40000gn_T_main_16958d_mi_1); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;n, (void*)src-&gt;n, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;n, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; int i = 0; NSMutableArray *n = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i, n, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 看到 __main_block_impl_0 多出了 2 个变量： int i;NSMutableArray *n; 变量名与我们捕获的一致。即当 Block 捕获一外部变量时，在 Block 内部会维护一个该变量对应的类型变量（基础类型为基础类型，对象为对象的指针并强引用）。 __block 的底层我们知道，在block 中如果想改变一个外部变量的值，需要为该变量声明 __block。 __block 演示代码： int main(int argc, const char * argv[]) &#123; __block int i = 0; __block NSMutableArray *n = [NSMutableArray array]; void(^block)() = ^() &#123; i = 1; n = [NSArray array]; NSLog(@\"hello\"); &#125;; block(); return 0;&#125; clang rewrite 后的代码： struct __Block_byref_i_0 &#123; void *__isa;__Block_byref_i_0 *__forwarding; int __flags; int __size; int i;&#125;;struct __Block_byref_n_1 &#123; void *__isa;__Block_byref_n_1 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSMutableArray *n;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_i_0 *i; // by ref __Block_byref_n_1 *n; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, __Block_byref_n_1 *_n, int flags=0) : i(_i-&gt;__forwarding), n(_n-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref __Block_byref_n_1 *n = __cself-&gt;n; // bound by ref (i-&gt;__forwarding-&gt;i) = 1; (n-&gt;__forwarding-&gt;n) = ((NSArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSArray\"), sel_registerName(\"array\")); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_v4_8fn73k9s2p5bxbsdm0cvqyd40000gn_T_main_ea2303_mi_0); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;n, (void*)src-&gt;n, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;n, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 0&#125;; __attribute__((__blocks__(byref))) __Block_byref_n_1 n = &#123;(void*)0,(__Block_byref_n_1 *)&amp;n, 33554432, sizeof(__Block_byref_n_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\"))&#125;; void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, (__Block_byref_n_1 *)&amp;n, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 可以看到 __main_block_impl_0 中多处了两个结构体对象 __Block_byref_i_0 和 __Block_byref_n_1。 即 __block 修饰的变量，在内部会被转化为 __Block_byref_xx_xx 结构体，属性分别有： __isa：isa 指针 __forwarding：转发对象 __flags：标志位 __size：大小 对象类型会有 __Block_byref_id_object_copy 和 __Block_byref_id_object_dispose __Block_byref 结构体内和捕获外部变量一样，维护一个内部变量 回到 __main_block_impl_0，其内部维护的变成了 __Block_byref 结构体变量。构造函数在构造的时候，会把 __forwarding 指向外部 __block 对象。Block 内值变动时，直接将 __forwarding 所维护的变量拿出来设置值，以达到在 block 内改变变量值。 Block 的三种类型Block 有三种类型，分别为： _NSConcreteStackBlock：指用到外部局部变量、成员属性变量，且没有强指针引用的 block。生命周期由系统控制，返回值后即被系统销毁。 _NSConcreteMallockBlock：有强指针引用或 copy 修饰的成员属性引用，block 会被复制一份到堆中，没有强指针引用时即销毁。有开发者控制。 _NSConcreteGlobalBlock：没用到外界变量或只用到全局变量、静态变量的 block。生命周期为从创建到程序运行结束。 Block 的 copy 和 disposecopycopy 内部实现为 _Block_copy，代码如下： void *_Block_copy(const void *arg) &#123; return _Block_copy_internal(arg, WANTS_ONE);&#125; _Block_copy_internal 对应的简化后的实现： static void *_Block_copy_internal(const void *arg, const int flags) &#123; struct Block_layout *aBlock; const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE; // 1 if (!arg) return NULL; // 2 aBlock = (struct Block_layout *)arg; // 3 if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123; // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock; &#125; // 4 else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123; return aBlock; &#125; // 5 struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return (void *)0; // 6 memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first // 7 result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 1; // 8 result-&gt;isa = _NSConcreteMallocBlock; // 9 if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123; (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup &#125; return result;&#125; 内部处理逻辑： 通过 Block 的 descriptor 获取 block size 直接在堆上创建一个新 block 使用 memmove 拷贝内存空间 将 isa 设置为 _NSConcreteMallocBlock 若 block 是 copy 的，调用 aBlock-&gt;descriptor-&gt;copy 在 block 的 descriptor 中，新增了 2 函数指针：copy 和 dispose。它们会指向 block 捕获变量的 assign 和 retain，这也是 block 会循环引用的原因。 copy 指针最终会调用 _Block_object_assign(...)，会根据不同类型，传入不同 flags。 若 block 引用了对象类型，会传入 BLOCK_FIELD_IS_OBJECT。最终会调用 _Block_retain_object 来 retain 对象，使用 _Block_assign 来赋值。 若 block 引用了 block，会传入 BLOCK_FIELD_IS_BLOCK。最终会调用 _Block_copy_internal 来进行 copy 若 block 引用了 __block 变量，会传入 BLOCK_FIELD_IS_BYREF。最终会调用 _Block_byref_assign_copy 来设置 forwarding 指向 dispose释放过程最终会调用 aBlock-&gt;descriptor-&gt;dispose，与 copy 过程相对应。 __block 中的 __forwarding 若 block 为 _NSConcreteStackBlock，__fordwarding 指向自己。block 内通过 __forwarding-&gt;xxx 访问或修改 __block 修饰的对象。 若 block 被 copy，会 malloc 出一片心空间，__block 变量也会被 copy，同时 copy 会设置 __forwarding，这时将 __forwarding 指向堆上 block 的 __forwarding。同样 block 内可以通过 __forwarding-&gt;xxx 访问或修改 __block 修饰的对象，区别是在堆上。 总结 Block 的结构 Block 捕获外部变量 __block 实现 三种类型 copy dispose _forwarding","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"}]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/categories/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://blog.jonyfang.com/categories/WWDC/"},{"name":"优化相关","slug":"优化相关","permalink":"https://blog.jonyfang.com/categories/%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"技术","slug":"技术","permalink":"https://blog.jonyfang.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"编译原理","slug":"编译原理","permalink":"https://blog.jonyfang.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"底层原理","slug":"底层原理","permalink":"https://blog.jonyfang.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/categories/Objective-C/"},{"name":"开发报错","slug":"开发报错","permalink":"https://blog.jonyfang.com/categories/%E5%BC%80%E5%8F%91%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.jonyfang.com/tags/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://blog.jonyfang.com/tags/WWDC/"},{"name":"App Clips","slug":"App-Clips","permalink":"https://blog.jonyfang.com/tags/App-Clips/"},{"name":"基础","slug":"基础","permalink":"https://blog.jonyfang.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"优化相关","slug":"优化相关","permalink":"https://blog.jonyfang.com/tags/%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://blog.jonyfang.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"编译原理","slug":"编译原理","permalink":"https://blog.jonyfang.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.jonyfang.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"底层原理","slug":"底层原理","permalink":"https://blog.jonyfang.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.jonyfang.com/tags/Objective-C/"},{"name":"开发报错","slug":"开发报错","permalink":"https://blog.jonyfang.com/tags/%E5%BC%80%E5%8F%91%E6%8A%A5%E9%94%99/"}]}